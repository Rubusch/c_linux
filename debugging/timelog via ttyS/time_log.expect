#!/usr/bin/expect --
# Based on Wolfgang Denx post to the u-boot mailing list - slightly modified
# to fit our needs . 
# - start up at 0 on first event,not at the timestamp taken at script startup
# - print relative and absolute time stamp
# - exit when termination pattern occurs
#
# License GPL V2.0
# Changes der.herr@hofr.at 

if { $argc != 1 } {
	puts stderr "Usage: $argv0 terminating_string\n"
	exit 1
}
set pattern [lindex $argv 0]

set timeout -1
set initialized 0

while { 1 } {
	# expect a newline/cariage return
	expect -re "\n\r*" {
		# set start time to 0 at first line receved
		if { ! $initialized } {
			set t1 [ clock clicks ]
			set t3 $t1
			set initialized 1
		}
		set t2 [ clock clicks ]
		set abs [ expr ($t2 - $t1) / 1e6 ]
		set rel [ expr ($t2 - $t3) / 1e6 ]
		set t3 $t2
		# once we reached the pattern - terminate
	        if [regexp -- "$pattern" "$expect_out(buffer)"] {
			puts [format "%8.3f %8.3f %s\r" $abs $rel [string map {\012 \040 \015 \040} "$expect_out(buffer)"]]
			puts "received string '$pattern' - terminating"
			exit 0
		}
		puts [format "%8.3f %8.3f %s\r" $abs $rel [string map {\012 \040 \015 \040} "$expect_out(buffer)"]]
	} \
	eof {
		exit 0
	}
}

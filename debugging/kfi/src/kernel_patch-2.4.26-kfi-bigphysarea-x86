diff -rbBNu linux-2.4.26/Documentation/Configure.help linux-2.4.26-kfi-big/Documentation/Configure.help
--- linux-2.4.26/Documentation/Configure.help	2004-04-14 15:05:24.000000000 +0200
+++ linux-2.4.26-kfi-big/Documentation/Configure.help	2005-01-01 22:57:14.000000000 +0100
@@ -320,6 +320,14 @@
   If you are not sure, say Y; apart from resulting in a 66 KB bigger
   kernel, it won't hurt.
 
+Support for big physical area reservation
+CONFIG_BIGPHYS_AREA
+  Enables kernel support for reserving large areas of physical memory
+  at boot-time for use by certain device drivers (such as video
+  framegrabbers, etc.) which require it. To use this feature, boot
+  the kernel with the boot-time option 'bigphysarea=nnn' where
+  'nnn' is the number of pages (a page is usually 4K) to reserve.
+
 Timer and CPU usage LEDs
 CONFIG_LEDS
   If you say Y here, the LEDs on your machine will be used
diff -rbBNu linux-2.4.26/Documentation/bigphysarea.txt linux-2.4.26-kfi-big/Documentation/bigphysarea.txt
--- linux-2.4.26/Documentation/bigphysarea.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.26-kfi-big/Documentation/bigphysarea.txt	2005-01-01 22:57:14.000000000 +0100
@@ -0,0 +1,64 @@
+Bigphysarea
+===========
+
+This set of functions give you the ability to allocate big
+contineous (DMAable) memory for the entire runtime of Linux.
+Big meaning here more than 128KB, the maximum allocation
+limit of kmalloc(). Due to fragmentation reasons kmalloc()
+is unable to garantee allocs of this order during a prolonged
+run of the kernel. This new pool of memory blob can be used
+during the initialization or use of soundcards of framegrabbers
+which are designed without DMA scatter-gatter capabilities.
+
+For a sample use, see the zoran driver in drivers/char/zr36120_mem.c
+
+Enjoy,
+  Pauline Middelink
+
+How to start
+============
+First add bigphysarea=<number of pages to alloc> to the
+commandline of your kernel. Either do this by adding an
+append= line to your /etc/lilo/conf setup or use some
+magic marker...
+After booting the new kernel there should be a /proc/bigphysarea
+file telling your how many blocks/bytes are available.
+
+The interface description
+=========================
+The big physical area is mainly managed by two functions. The first one,
+
+caddr_t bigphysarea_alloc_pages(int count, int align, int priority)
+
+allocates 'count' pages. The pages are aligned so that there base
+address is a multiple of 'PAGE_SIZE * align'. If you don't need more
+than page alignment, set 'align' to 0 or 1. 'priority' has the same
+meaning as in kmalloc, it can be GFP_ATOMIC (for calls from interrupt
+handlers) or GFP_KERNEL (for usual calls). The base address of the
+allocated area is returned.
+
+Allocation can fail for two reasons, in both cases NULL is
+returned. First, the physical area is scattered too much or there is
+not enough memory, second it is not possible to allocate some memory
+with kmalloc for administration of the physical area (very unlikely).
+
+To free an allocated area, just call
+
+void bigphysarea_free_pages(caddr_t base)
+
+with 'base' set to the value returned by 'bigphysarea_alloc_pages'. 
+
+An example how to use this functions can be found in 'module.c'.
+
+There is still the old interface introduced by M. Welsh:
+
+caddr_t bigphysarea_alloc(int size)
+void bigphysarea_free(caddr_t addr, int size)
+
+The first function allocates 'size' bytes physically continous
+memory. To free the area, bigphysarea_free with a pointer to the area
+and its size has to be called. Due to a new allocation algorithm, the
+size parameter is no longer really needed when freeing an area.
+
+In the current version it is not safe to call any of the functions
+from an interrupt handler.
diff -rbBNu linux-2.4.26/Makefile linux-2.4.26-kfi-big/Makefile
--- linux-2.4.26/Makefile	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/Makefile	2005-01-01 22:57:14.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 26
-EXTRAVERSION =
+EXTRAVERSION =-kfi
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -96,6 +97,11 @@
 ifndef CONFIG_FRAME_POINTER
 CFLAGS += -fomit-frame-pointer
 endif
+
+ifdef CONFIG_KFI
+CFLAGS += -finstrument-functions
+endif
+
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
 #
@@ -205,6 +211,7 @@
 	.tmp* \
 	drivers/char/consolemap_deftbl.c drivers/video/promcon_tbl.c \
 	drivers/char/conmakehash \
+	drivers/char/kfistatic.c \
 	drivers/char/drm/*-mod.c \
 	drivers/pci/devlist.h drivers/pci/classlist.h drivers/pci/gen-devlist \
 	drivers/zorro/devlist.h drivers/zorro/gen-devlist \
diff -rbBNu linux-2.4.26/arch/arm/config.in linux-2.4.26-kfi-big/arch/arm/config.in
--- linux-2.4.26/arch/arm/config.in	2005-01-01 20:54:03.000000000 +0100
+++ linux-2.4.26-kfi-big/arch/arm/config.in	2005-01-01 17:29:15.000000000 +0100
@@ -729,6 +729,8 @@
 dep_bool '  Kernel low-level debugging functions' CONFIG_DEBUG_LL $CONFIG_DEBUG_KERNEL
 dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
 dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
+bool 'Kernel Function Instrumentation' CONFIG_KFI
+dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
 
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
diff -rbBNu linux-2.4.26/arch/arm/config.in.rej linux-2.4.26-kfi-big/arch/arm/config.in.rej
--- linux-2.4.26/arch/arm/config.in.rej	2005-01-01 20:54:03.000000000 +0100
+++ linux-2.4.26-kfi-big/arch/arm/config.in.rej	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-***************
-*** 654,661 ****
-  dep_bool '  Kernel low-level debugging functions' CONFIG_DEBUG_LL $CONFIG_DEBUG_KERNEL
-  dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
-  dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
-- bool 'Kernel Function Instrumentation' CONFIG_KFI
-- dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
-  endmenu
-  
-  source lib/Config.in
---- 654,659 ----
-  dep_bool '  Kernel low-level debugging functions' CONFIG_DEBUG_LL $CONFIG_DEBUG_KERNEL
-  dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
-  dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
-  endmenu
-  
-  source lib/Config.in
diff -rbBNu linux-2.4.26/arch/i386/boot/compressed/misc.c linux-2.4.26-kfi-big/arch/i386/boot/compressed/misc.c
--- linux-2.4.26/arch/i386/boot/compressed/misc.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-2.4.26-kfi-big/arch/i386/boot/compressed/misc.c	2005-01-01 17:33:10.000000000 +0100
@@ -79,9 +79,9 @@
 
 static int  fill_inbuf(void);
 static void flush_window(void);
-static void error(char *m);
-static void gzip_mark(void **);
-static void gzip_release(void **);
+//static void error(char *m);
+//static void gzip_mark(void **);
+//static void gzip_release(void **);
   
 /*
  * This is set up by the setup-routine at boot-time
@@ -101,8 +101,12 @@
 static uch *output_data;
 static unsigned long output_ptr = 0;
 
+ 
 static void *malloc(int size);
 static void free(void *where);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
 
 static void puts(const char *);
 
@@ -124,7 +128,7 @@
 
 #include "../../../../lib/inflate.c"
 
-static void *malloc(int size)
+static void __noinstrument *malloc(int size)
 {
 	void *p;
 
@@ -142,21 +146,21 @@
 	return p;
 }
 
-static void free(void *where)
+static void __noinstrument free(void *where)
 {	/* Don't care */
 }
 
-static void gzip_mark(void **ptr)
+static void __noinstrument gzip_mark(void **ptr)
 {
 	*ptr = (void *) free_mem_ptr;
 }
 
-static void gzip_release(void **ptr)
+static void __noinstrument gzip_release(void **ptr)
 {
 	free_mem_ptr = (long) *ptr;
 }
  
-static void scroll(void)
+static void __noinstrument scroll(void)
 {
 	int i;
 
@@ -165,7 +169,7 @@
 		vidmem[i] = ' ';
 }
 
-static void puts(const char *s)
+static void __noinstrument puts(const char *s)
 {
 	int x,y,pos;
 	char c;
@@ -202,7 +206,7 @@
 	outb_p(0xff & (pos >> 1), vidport+1);
 }
 
-static void* memset(void* s, int c, size_t n)
+static void* __noinstrument memset(void* s, int c, size_t n)
 {
 	int i;
 	char *ss = (char*)s;
@@ -211,7 +215,7 @@
 	return s;
 }
 
-static void* memcpy(void* __dest, __const void* __src,
+static void* __noinstrument memcpy(void* __dest, __const void* __src,
 			    size_t __n)
 {
 	int i;
@@ -225,7 +229,7 @@
  * Fill the input buffer. This is called only when the buffer is empty
  * and at least one byte is really needed.
  */
-static int fill_inbuf(void)
+static int __noinstrument fill_inbuf(void)
 {
 	if (insize != 0) {
 		error("ran out of input data\n");
@@ -241,7 +245,7 @@
  * Write the output window window[0..outcnt-1] and update crc and bytes_out.
  * (Used for the decompressed data only.)
  */
-static void flush_window_low(void)
+static void __noinstrument flush_window_low(void)
 {
     ulg c = crc;         /* temporary variable */
     unsigned n;
@@ -259,7 +263,7 @@
     outcnt = 0;
 }
 
-static void flush_window_high(void)
+static void __noinstrument flush_window_high(void)
 {
     ulg c = crc;         /* temporary variable */
     unsigned n;
@@ -275,13 +279,13 @@
     outcnt = 0;
 }
 
-static void flush_window(void)
+static void __noinstrument flush_window(void)
 {
 	if (high_loaded) flush_window_high();
 	else flush_window_low();
 }
 
-static void error(char *x)
+static void __noinstrument error(char *x)
 {
 	puts("\n\n");
 	puts(x);
@@ -299,7 +303,7 @@
 	short b;
 	} stack_start = { & user_stack [STACK_SIZE] , __KERNEL_DS };
 
-static void setup_normal_output_buffer(void)
+static void __noinstrument setup_normal_output_buffer(void)
 {
 #ifdef STANDARD_MEMORY_BIOS_CALL
 	if (EXT_MEM_K < 1024) error("Less than 2MB of memory.\n");
@@ -315,7 +319,7 @@
 	uch *high_buffer_start; int hcount;
 };
 
-static void setup_output_buffer_if_we_run_high(struct moveparams *mv)
+static void __noinstrument setup_output_buffer_if_we_run_high(struct moveparams *mv)
 {
 	high_buffer_start = (uch *)(((ulg)&end) + HEAP_SIZE);
 #ifdef STANDARD_MEMORY_BIOS_CALL
@@ -337,7 +341,7 @@
 	mv->high_buffer_start = high_buffer_start;
 }
 
-static void close_output_buffer_if_we_run_high(struct moveparams *mv)
+static void __noinstrument close_output_buffer_if_we_run_high(struct moveparams *mv)
 {
 	if (bytes_out > low_buffer_size) {
 		mv->lcount = low_buffer_size;
@@ -350,7 +354,7 @@
 }
 
 
-asmlinkage int decompress_kernel(struct moveparams *mv, void *rmode)
+asmlinkage int __noinstrument decompress_kernel(struct moveparams *mv, void *rmode)
 {
 	real_mode = rmode;
 
diff -rbBNu linux-2.4.26/arch/i386/config.in linux-2.4.26-kfi-big/arch/i386/config.in
--- linux-2.4.26/arch/i386/config.in	2005-01-01 20:54:03.000000000 +0100
+++ linux-2.4.26-kfi-big/arch/i386/config.in	2005-01-01 22:58:14.000000000 +0100
@@ -224,6 +224,7 @@
 
 bool 'Math emulation' CONFIG_MATH_EMULATION
 bool 'MTRR (Memory Type Range Register) support' CONFIG_MTRR
+bool 'Support for big physical area reservation' CONFIG_BIGPHYS_AREA
 bool 'Symmetric multi-processing support' CONFIG_SMP
 if [ "$CONFIG_SMP" != "y" ]; then
    bool 'Local APIC support on uniprocessors' CONFIG_X86_UP_APIC
@@ -479,6 +480,7 @@
    bool '  Magic SysRq key' CONFIG_MAGIC_SYSRQ
    bool '  Spinlock debugging' CONFIG_DEBUG_SPINLOCK
    bool '  Compile the kernel with frame pointers' CONFIG_FRAME_POINTER
+   bool 'Kernel Function Instrumentation' CONFIG_KFI
 fi
 
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
diff -rbBNu linux-2.4.26/arch/mips/config-shared.in linux-2.4.26-kfi-big/arch/mips/config-shared.in
--- linux-2.4.26/arch/mips/config-shared.in	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/arch/mips/config-shared.in	2005-01-01 17:27:37.000000000 +0100
@@ -840,6 +840,8 @@
 else
    define_bool CONFIG_CPU_HAS_SYNC y
 fi
+bool 'Kernel Function Instrumentation' CONFIG_KFI
+dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
 endmenu
 
 #
diff -rbBNu linux-2.4.26/drivers/char/Makefile linux-2.4.26-kfi-big/drivers/char/Makefile
--- linux-2.4.26/drivers/char/Makefile	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/drivers/char/Makefile	2005-01-01 22:54:46.000000000 +0100
@@ -24,7 +24,7 @@
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o \
+			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o kfi.o \
 			scx200.o fetchop.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
@@ -334,6 +334,8 @@
   obj-y += ipmi/ipmi.o
 endif
 
+obj-$(CONFIG_KFI) += kfi.o
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
diff -rbBNu linux-2.4.26/drivers/char/Makefile.rej linux-2.4.26-kfi-big/drivers/char/Makefile.rej
--- linux-2.4.26/drivers/char/Makefile.rej	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/drivers/char/Makefile.rej	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-***************
-*** 24,30 ****
-  export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
-  			misc.o pty.o random.o selection.o serial.o \
-  			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-- 			au1000_gpio.o hp_psaux.o nvram.o kfi.o
-  
-  mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
-  
---- 24,30 ----
-  export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
-  			misc.o pty.o random.o selection.o serial.o \
-  			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-+ 			au1000_gpio.o hp_psaux.o nvram.o
-  
-  mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
-  
diff -rbBNu linux-2.4.26/drivers/char/kfi.c linux-2.4.26-kfi-big/drivers/char/kfi.c
--- linux-2.4.26/drivers/char/kfi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.26-kfi-big/drivers/char/kfi.c	2005-01-01 23:18:33.000000000 +0100
@@ -0,0 +1,831 @@
+/*
+ *  drivers/char/kfi.c
+ *
+ *  Kernel Function Instrumentation
+ *
+ *  Copyright (C) 2002  MontaVista Software
+ *
+ *  Support for Function Instrumentation/Profiling feature of
+ *  GCC (-finstrument-functions).
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#include <linux/kfi.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+
+#define KFI_MODULE_NAME "KFI"
+#define PFX KFI_MODULE_NAME
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+#define KFI_MINOR 51
+
+static struct kfi_run* run_head = NULL;
+static struct kfi_run* run_curr = NULL;
+static struct kfi_run* run_tail = NULL;
+
+static int next_run_id = 0;
+static int in_entry_exit = 0;
+
+//static spinlock_t kfi_lock = SPIN_LOCK_UNLOCKED;
+DECLARE_WAIT_QUEUE_HEAD(kfi_wait);
+
+#define CLOCK_SHIFT	3
+/* Would be nice to use probed clock freq (cpu_hz) here, but it
+ * isn't set early enough for some boot measurements.
+ * Set the following for your machine!
+ * Hint: for x86, boot once and look at /proc/cpuinfo */
+//#define CLOCK_FREQ 645206000ULL
+#define CLOCK_FREQ 2992332000ULL
+/* This weird scaling makes it possible to use shifts instead
+ * of divisions, for the conversion to microseconds */
+#define CLOCK_SCALE (((CLOCK_FREQ*1000000)/(1024*1024))>>CLOCK_SHIFT)
+
+static inline unsigned long kfi_readclock(void)
+{
+	unsigned long long ticks;
+
+	rdtscll(ticks);
+	return (unsigned long)((ticks>>CLOCK_SHIFT) & 0xffffffff);
+}
+
+static inline unsigned long kfi_clock_to_usecs(unsigned long clock)
+{
+	/* math to stay in 32-bit regs.  Try to avoid overflows and underflows */
+	if (clock<4096)
+		return (clock<<20)/CLOCK_SCALE;
+	if (clock<(4096<<5))
+		return (clock<<15)/(CLOCK_SCALE>>5);
+	if (clock<(4096<<10))
+		return (clock<<10)/(CLOCK_SCALE>>10);
+	if (clock<(4096<<15))
+		return (clock<<5)/(CLOCK_SCALE>>15);
+	else
+		return clock/(CLOCK_SCALE>>20);
+}
+
+static unsigned long usecs_since_boot = 0;
+static unsigned long last_machine_cycles = 0;
+
+static inline unsigned long __noinstrument
+update_usecs_since_boot(void)
+{
+	unsigned long machine_cycles, delta;
+
+	machine_cycles = kfi_readclock();
+	delta = machine_cycles - last_machine_cycles;
+	delta = kfi_clock_to_usecs(delta);
+
+	usecs_since_boot += delta;
+	
+	last_machine_cycles = machine_cycles;
+	return usecs_since_boot;
+}
+
+static inline struct kfi_entry* __noinstrument
+new_entry(struct kfi_run* run)
+{
+	struct kfi_entry* entry;
+	
+	if (run->next_entry >= run->num_entries)
+		return NULL;
+	
+	entry = &run->log[run->next_entry];
+	run->next_entry++;
+	return entry;
+}
+
+
+static inline int __noinstrument
+find_entry(struct kfi_run* run, void *this_fn, unsigned int pid)
+{
+	int i;
+
+	for (i = run->next_entry-1; i >= 0; i--) {
+		struct kfi_entry* entry = &run->log[i];
+		if (entry->va == this_fn &&
+		    entry->pid == pid &&
+		    entry->delta == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+
+static inline void __noinstrument
+free_entry(struct kfi_run* run, int loc)
+{
+	int i;
+	run->next_entry--;
+	for (i = loc; i < run->next_entry; i++)
+		run->log[i] = run->log[i+1];
+}
+
+
+static inline int __noinstrument
+in_func_list(struct kfi_filters* filters, void* func)
+{
+	int i;
+
+	for (i=0; i < filters->func_list_size; i++) {
+		if (filters->func_list[i] == func)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static inline int __noinstrument
+test_filters(struct kfi_filters* filters, void *this_fn)
+{
+	int in_intr;
+	
+	if (filters->func_list && !in_func_list(filters, this_fn)) {
+#ifdef KFI_DEBUG
+		filters->cnt.func_list++;
+#endif
+		return 1;
+	}
+
+	in_intr = in_interrupt();
+
+	if (filters->no_ints && in_intr) {
+#ifdef KFI_DEBUG
+		filters->cnt.no_ints++;
+#endif
+		return 1;
+	}
+
+	if (filters->only_ints && !in_intr) {
+#ifdef KFI_DEBUG
+		filters->cnt.only_ints++;
+#endif
+		return 1;
+	}
+	
+	return 0;
+}
+
+
+static inline void __noinstrument
+do_func_entry(struct kfi_run* run, void *this_fn, void *call_site)
+{
+	struct kfi_entry* entry;
+
+	if (!(entry = new_entry(run))) {
+		run->complete = 1;
+		run->stop_trigger.mark = update_usecs_since_boot();
+		run->stop_trigger.type = TRIGGER_LOG_FULL;
+		return;
+	}
+	
+	entry->va = this_fn;
+	entry->call_site = call_site;
+	entry->pid = in_interrupt() ? INTR_CONTEXT : current->pid;
+
+	entry->delta = 0;
+	entry->time = update_usecs_since_boot() - run->start_trigger.mark;
+}
+
+static inline void __noinstrument
+do_func_exit(struct kfi_run* run, void *this_fn, void *call_site)
+{
+	struct kfi_entry* entry;
+	unsigned long exittime;
+	unsigned long delta;
+	int entry_i;
+
+	if ((entry_i = find_entry(run, this_fn, in_interrupt() ?
+				  INTR_CONTEXT : current->pid)) < 0) {
+#ifdef KFI_DEBUG
+		run->notfound++;
+#endif
+		return;
+	}
+	
+	entry = &run->log[entry_i];
+
+	// calc delta
+	exittime = update_usecs_since_boot() - run->start_trigger.mark;
+	delta = exittime - entry->time;
+	
+	if ((run->filters.min_delta && delta < run->filters.min_delta) ||
+	    (run->filters.max_delta && delta > run->filters.max_delta)) {
+#ifdef KFI_DEBUG
+		run->filters.cnt.delta++;
+#endif
+		free_entry(run, entry_i);
+	} else {
+		entry->delta = delta;
+	}
+}
+
+
+static inline int __noinstrument test_trigger(struct kfi_run* run,
+					      int start_trigger,
+					      int func_entry,
+					      void* func_addr)
+{
+	unsigned long time, base_time;
+	int ret = 0;
+	struct kfi_trigger* t;
+		
+	t = start_trigger ? &run->start_trigger : &run->stop_trigger;
+
+	switch (t->type) {
+	case TRIGGER_TIME:
+		time = update_usecs_since_boot();
+		if (start_trigger) {
+			/* trigger start time based from boot */
+			base_time = 0;
+		} else {
+			/* trigger stop time based from start trigger time */
+			base_time = run->start_trigger.mark;
+		}
+		
+		if (time >= base_time + t->time) {
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	case TRIGGER_FUNC_ENTRY:
+		if (func_entry && func_addr == t->func_addr) {
+			time = update_usecs_since_boot();
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	case TRIGGER_FUNC_EXIT:
+		if (!func_entry && func_addr == t->func_addr) {
+			time = update_usecs_since_boot();
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+
+static inline void __noinstrument
+func_entry_exit(void *this_fn, void *call_site, int func_entry)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	
+	local_irq_save(flags);
+	if (in_entry_exit) {
+		local_irq_restore(flags);
+		return;
+	}
+	in_entry_exit = 1;
+	
+	update_usecs_since_boot();
+	
+	run = run_curr;
+
+	if (!run || run->complete) {
+		goto entry_exit_byebye;
+	}
+	
+	if (!run->triggered) {
+		if (!(run->triggered = test_trigger(run, 1,
+						    func_entry,
+						    this_fn))) {
+			goto entry_exit_byebye;
+		}
+	}
+
+	if (!test_filters(&run->filters, this_fn)) {
+		if (func_entry)
+			do_func_entry(run, this_fn, call_site);
+		else
+			do_func_exit(run, this_fn, call_site);
+	}
+
+	if (!run->complete) {
+		run->complete = test_trigger(run, 0,
+					     func_entry,
+					     this_fn);
+	}
+
+	if (run->complete) {
+		if (waitqueue_active(&kfi_wait))
+			wake_up_interruptible(&kfi_wait);
+		if (run->next != NULL)
+			run_curr = run->next;
+	}
+	
+ entry_exit_byebye:
+	in_entry_exit = 0;
+	local_irq_restore(flags);
+}
+
+
+void __noinstrument __cyg_profile_func_enter (void *this_fn, void *call_site)
+{
+	func_entry_exit(this_fn, call_site, 1);
+}
+
+void __noinstrument __cyg_profile_func_exit (void *this_fn, void *call_site)
+{
+	func_entry_exit(this_fn, call_site, 0);
+}
+
+
+#define dump_str(buf, len, fmt, arg...) \
+    if (buf) len += sprintf(buf + len, fmt, ## arg); \
+    else len += printk(KERN_EMERG fmt, ## arg)
+
+
+static struct kfi_run* __noinstrument find_run(int id)
+{
+	struct kfi_run* run = run_head;
+
+	while (run && run->id != id)
+		run = run->next;
+
+	return run;
+}
+
+static int __noinstrument
+print_trigger(char* buf, int len, struct kfi_trigger* t, int start_trigger)
+{
+	char trigbuf[80];
+	
+	switch (t->type) {
+	case TRIGGER_DEV:
+		sprintf(trigbuf, "system call\n");
+		break;
+	case TRIGGER_TIME:
+		sprintf(trigbuf, "time at %lu usec from %s\n",
+		       t->time, start_trigger ? "boot" : "start trigger");
+		break;
+	case TRIGGER_FUNC_ENTRY:
+		sprintf(trigbuf, "entry to function 0x%08lx\n",
+			(unsigned long)t->func_addr);
+		break;
+	case TRIGGER_FUNC_EXIT:
+		sprintf(trigbuf, "exit from function 0x%08lx\n",
+			(unsigned long)t->func_addr);
+		break;
+	case TRIGGER_LOG_FULL:
+		sprintf(trigbuf, "log full\n");
+		break;
+	default:
+		sprintf(trigbuf, "?\n");
+		break;
+	}
+
+	dump_str(buf, len, "Logging %s at %lu usec by %s",
+		 (start_trigger ? "started" : "stopped"),
+		 t->mark, trigbuf);
+
+	return len;
+}
+
+int __noinstrument kfi_dump_log(char* buf)
+{
+	int i, len = 0;
+	struct kfi_run* run = run_curr;
+	struct kfi_filters* filters = &run->filters;
+
+	if (!run) {
+		dump_str(buf, len, "\nNo logging run registered\n");
+		return len;
+	}
+
+	if (!run->triggered) {
+		dump_str(buf, len, "\nLogging not yet triggered\n");
+		return len;
+	}
+
+	if (!run->complete) {
+		dump_str(buf, len, "\nLogging is running\n");
+		return len;
+	}
+
+	dump_str(buf, len, "\nKernel Instrumentation Run ID %d\n\n",
+		 run->id);
+	
+	dump_str(buf, len, "Filters:\n");
+	if (filters->func_list_size) {
+		dump_str(buf, len, "\t%d-entry function list\n",
+			 filters->func_list_size);
+	}
+	if (filters->min_delta) {
+		dump_str(buf, len, "\t%ld usecs minimum execution time\n",
+			 filters->min_delta);
+	}
+	if (filters->max_delta) {
+		dump_str(buf, len, "\t%ld usecs maximum execution time\n",
+			 filters->max_delta);
+	}
+	if (filters->no_ints) {
+		dump_str(buf, len, "\tno functions in interrupt context\n");
+	}
+	if (filters->only_ints) {
+		dump_str(buf, len,
+			 "\tno functions NOT in interrupt context\n");
+	}
+	if (filters->func_list) {
+		dump_str(buf, len, "\tfunction list\n");
+	}
+	
+#ifdef KFI_DEBUG
+	dump_str(buf, len, "\nFilter Counters:\n");
+
+	if (filters->min_delta || filters->max_delta) {
+		dump_str(buf, len, "\nExecution time filter count = %d\n",
+			 filters->cnt.delta);
+	}
+	if (filters->no_ints) {
+		dump_str(buf, len,
+			 "No Interrupt functions filter count = %d\n",
+			 filters->cnt.no_ints);
+	}
+	if (filters->only_ints) {
+		dump_str(buf, len,
+			 "Only Interrupt functions filter count = %d\n",
+			 filters->cnt.only_ints);
+	}
+	if (filters->func_list_size) {
+		dump_str(buf, len, "Function List filter count = %d\n",
+			 filters->cnt.func_list);
+	}
+	dump_str(buf, len, "Total entries filtered = %d\n",
+		 filters->cnt.delta +
+		 filters->cnt.no_ints +
+		 filters->cnt.only_ints +
+		 filters->cnt.func_list);
+	dump_str(buf, len, "Entries not found = %d\n", run->notfound);
+#endif	
+	dump_str(buf, len, "\nNumber of entries after filters = %d\n\n",
+		 run->next_entry);
+
+	len += print_trigger(buf, len, &run->start_trigger, 1);
+	len += print_trigger(buf, len, &run->stop_trigger, 0);
+	
+	/* print out header */
+	dump_str(buf, len, "\n");
+	dump_str(buf, len,
+		 " Entry      Delta       PID      Function    Caller\n");
+	dump_str(buf, len,
+		 "--------   --------   --------   --------   --------\n");
+
+	for (i=0; i < run->next_entry; i++) {
+		dump_str(buf, len, "%8lu   %8lu   %7d%s   %08x   %08x\n",
+			 run->log[i].time,
+			 run->log[i].delta,
+			 run->log[i].pid,
+			 (run->log[i].pid == INTR_CONTEXT) ? "i" : " ",
+			 (unsigned int)run->log[i].va,
+			 (unsigned int)run->log[i].call_site);
+	}
+
+	return len;
+}
+
+int __noinstrument kfi_read_proc(char *buf, char **start, off_t fpos,
+				 int length, int *eof, void *data)
+{
+	int len = kfi_dump_log(buf);
+	
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+static void __noinstrument kfi_reset(void)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	
+	run = run_head;
+
+	local_irq_save(flags);
+	if (run_curr)
+		run_curr->complete = 1;
+	local_irq_restore(flags);
+
+	while (run) {
+		struct kfi_run* tmp = run;
+		bigphysarea_free(run->log);
+		if (run->filters.func_list)
+			kfree(run->filters.func_list);
+		run = run->next;
+		kfree(tmp);
+	}
+
+	next_run_id = 0;
+	run_head = run_tail = run_curr = NULL;
+}
+
+
+static int __noinstrument kfi_ioctl(struct inode *inode,
+				    struct file *file,
+				    unsigned int cmd,
+				    unsigned long arg)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	struct kfi_run urun;
+	struct kfi_entry* ulog;
+	void** ufunc_list;
+	int ufunc_list_size;
+	
+	switch (cmd) {
+	case KFI_RESET:
+		kfi_reset();
+		break;
+	case KFI_NEW_RUN:
+		if (verify_area(VERIFY_READ, (void *)arg,
+				sizeof(struct kfi_run)) ||
+		    verify_area(VERIFY_WRITE, (void *)arg,
+				sizeof(struct kfi_run)))
+			return -EFAULT;
+		if ((run = (struct kfi_run*)kmalloc(sizeof(struct kfi_run),
+						    GFP_KERNEL)) == NULL)
+			return -ENOMEM;
+		copy_from_user(&urun, (struct kfi_run*)arg,
+			       sizeof(struct kfi_run));
+		if (urun.num_entries > MAX_RUN_LOG_ENTRIES) {
+			kfree(run);
+			return -EINVAL;
+		}
+		*run = urun;
+		run->id = next_run_id++;
+		run->triggered = run->complete = 0;
+		run->next_entry = 0;
+#ifdef KFI_DEBUG
+		run->notfound = 0;
+		memset(&run->filters.cnt, 0, sizeof(run->filters.cnt));
+#endif
+		run->next = NULL;
+		urun = *run;
+		run->log = (struct kfi_entry*)
+			bigphysarea_alloc(sizeof(struct kfi_entry) * run->num_entries, GFP_KERNEL);
+		if (run->log == NULL) {
+			kfree(run);
+			printk("bigphysarea_alloc failed\n");
+			return -ENOMEM;
+		}
+		memset(run->log, 0,
+		       sizeof(struct kfi_entry) * run->num_entries);
+		
+		if (urun.filters.func_list) {
+			int size;
+			if (urun.filters.func_list_size >
+			    MAX_FUNC_LIST_ENTRIES) {
+				bigphysarea_free(run->log);
+				kfree(run);
+				return -EINVAL;
+			}
+			size = urun.filters.func_list_size * sizeof(void*);
+			if (verify_area(VERIFY_READ,
+					(void *)urun.filters.func_list,
+					size)) {
+				bigphysarea_free(run->log);
+				kfree(run);
+				return -EFAULT;
+			}
+			run->filters.func_list = (void**)kmalloc(size,
+								 GFP_KERNEL);
+			if (run->filters.func_list == NULL) {
+				bigphysarea_free(run->log);
+				kfree(run);
+				return -ENOMEM;
+			}
+			copy_from_user(run->filters.func_list,
+				       urun.filters.func_list,
+				       size);
+		}
+	       
+		/* new run is ready, return it to user */
+		copy_to_user((struct kfi_run*)arg, &urun,
+			     sizeof(struct kfi_run));
+		/* tack it on */
+		local_irq_save(flags);
+		if (!run_tail) {
+			run_head = run_tail = run_curr = run;
+		} else {
+			if (run_curr == run_tail && run_curr->complete)
+				run_curr = run;
+			run_tail->next = run;
+			run_tail = run;
+		}
+		local_irq_restore(flags);
+		break;
+	case KFI_START:
+		local_irq_save(flags);
+		run = run_curr;
+		if (!run || run->complete || run->triggered) {
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+		run->triggered = 1;
+		run->start_trigger.mark = update_usecs_since_boot();
+		run->start_trigger.type = TRIGGER_DEV;
+		local_irq_restore(flags);
+		if (put_user(run->id, (int *)arg))
+			return -EFAULT;
+		break;
+	case KFI_STOP:
+		local_irq_save(flags);
+		run = run_curr;
+		if (!run || run->complete) {
+			local_irq_restore(flags);
+			printk("no active traces\n");
+//			return -EINVAL;
+			return 0;
+		}
+		run->complete = 1;
+		run->stop_trigger.mark = update_usecs_since_boot();
+		run->stop_trigger.type = TRIGGER_DEV;
+		if (run->next != NULL)
+			run_curr = run->next;
+		local_irq_restore(flags);
+		if (waitqueue_active(&kfi_wait))
+			wake_up_interruptible(&kfi_wait);
+		if (put_user(run->id, (int *)arg))
+			return -EFAULT;
+		break;
+	case KFI_READ:
+	case KFI_READ_CURR:
+		if (verify_area(VERIFY_READ, (void *)arg,
+				sizeof(struct kfi_run)) ||
+		    verify_area(VERIFY_WRITE, (void *)arg,
+				sizeof(struct kfi_run)))
+			return -EFAULT;
+		copy_from_user(&urun, (struct kfi_run*)arg,
+			       sizeof(struct kfi_run));
+
+		local_irq_save(flags);
+
+		run = (cmd == KFI_READ_CURR) ? run_curr : find_run(urun.id);
+		if (!run) {
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+
+		if (urun.log != NULL) {
+			if (urun.num_entries < run->num_entries) {
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+			
+			if (!run->complete) {
+				local_irq_restore(flags);
+				if (file->f_flags & O_NONBLOCK)
+					return -EAGAIN;
+				while (!run->complete) {
+					interruptible_sleep_on(&kfi_wait);
+					if (signal_pending(current))
+						return -ERESTARTSYS;
+				}
+				local_irq_save(flags);
+			}
+		}
+
+		ufunc_list_size = urun.filters.func_list_size;
+
+		// save user pointers
+		ulog = urun.log;
+		ufunc_list = urun.filters.func_list;
+		
+		urun = *run; // copy run
+
+		// restore user pointers
+		urun.log = ulog;
+		urun.filters.func_list = ufunc_list;
+		urun.next = NULL;
+
+		local_irq_restore(flags);
+
+		copy_to_user((void*)arg, &urun, sizeof(struct kfi_run));
+
+		if (urun.log != NULL) {
+			int size = run->next_entry * sizeof(struct kfi_entry);
+			if (verify_area(VERIFY_WRITE, (void*)urun.log, size))
+				return -EFAULT;
+			copy_to_user((void*)urun.log, run->log, size);
+		}
+
+		if (ufunc_list != NULL && run->filters.func_list != NULL) {
+			int size;
+			if (ufunc_list_size < run->filters.func_list_size)
+				return -EINVAL;
+			size = run->filters.func_list_size * sizeof(void*);
+			if (verify_area(VERIFY_WRITE, ufunc_list, size))
+				return -EFAULT;
+			copy_to_user(ufunc_list, run->filters.func_list, size);
+		}
+		break;
+	case KFI_READ_TIMER:
+		if (put_user(update_usecs_since_boot(),
+			     (unsigned long *)arg))
+			return -EFAULT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int __noinstrument
+kfi_poll(struct file * filp, poll_table * wait)
+{
+        poll_wait(filp, &kfi_wait, wait);
+        if (run_curr && run_curr->complete)
+                return POLLIN | POLLRDNORM;
+        return 0;
+}
+
+int __noinstrument kfi_open(struct inode *minode, struct file *mfile)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+int __noinstrument kfi_release(struct inode *minode, struct file *mfile)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static loff_t __noinstrument kfi_llseek(struct file *mfile,
+					loff_t offset, int origint)
+{
+	return -ESPIPE;
+}
+
+static struct file_operations kfi_fops = {
+	owner:		THIS_MODULE,
+	llseek:		kfi_llseek,
+	poll:           kfi_poll,
+	ioctl:		kfi_ioctl,
+	open:		kfi_open,
+	release:	kfi_release,
+};
+
+static struct miscdevice kfi_miscdev = {
+	KFI_MINOR,
+	"kfi",
+	&kfi_fops
+};
+
+static int __init __noinstrument kfi_init(void)
+{
+	int ret = misc_register(&kfi_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		return ret;
+	}
+
+	create_proc_read_entry("kfi", 0, NULL,
+			       kfi_read_proc, NULL);
+	return 0;
+}
+
+static void __exit __noinstrument kfi_exit(void)
+{
+        remove_proc_entry("kfi", NULL);
+        misc_deregister(&kfi_miscdev);
+}
+
+
+module_init(kfi_init);
+module_exit(kfi_exit);
+
+EXPORT_SYMBOL(__cyg_profile_func_enter);
+EXPORT_SYMBOL(__cyg_profile_func_exit);
+
diff -rbBNu linux-2.4.26/drivers/scsi/53c8xx_d.h linux-2.4.26-kfi-big/drivers/scsi/53c8xx_d.h
--- linux-2.4.26/drivers/scsi/53c8xx_d.h	1999-12-09 00:17:55.000000000 +0100
+++ linux-2.4.26-kfi-big/drivers/scsi/53c8xx_d.h	2005-01-01 17:54:13.000000000 +0100
@@ -460,7 +458,6 @@
 ; each one.
 
 
-						
 ABSOLUTE NCR53c7xx_msg_abort = 0	; Pointer to abort message
 ABSOLUTE NCR53c7xx_msg_reject = 0       ; Pointer to reject message
 ABSOLUTE NCR53c7xx_zero	= 0		; long with zero in it, use for source
diff -rbBNu linux-2.4.26/include/linux/bigphysarea.h linux-2.4.26-kfi-big/include/linux/bigphysarea.h
--- linux-2.4.26/include/linux/bigphysarea.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.26-kfi-big/include/linux/bigphysarea.h	2005-01-01 22:58:58.000000000 +0100
@@ -0,0 +1,29 @@
+/* linux/mm/bigphysarea.h, M. Welsh (mdw@cs.cornell.edu)
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?)
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ *
+ */
+
+#ifndef __LINUX_BIGPHYSAREA_H
+#define __LINUX_BIGPHYSAREA_H
+
+#include <linux/types.h>
+
+/* original interface */
+extern caddr_t	bigphysarea_alloc(int size);
+extern void	bigphysarea_free(caddr_t addr, int size);
+
+/* new interface */
+extern caddr_t	bigphysarea_alloc_pages(int count, int align, int priority);
+extern void	bigphysarea_free_pages(caddr_t base);
+
+#endif // __LINUX_BIGPHYSAREA_H
diff -rbBNu linux-2.4.26/include/linux/init.h linux-2.4.26-kfi-big/include/linux/init.h
--- linux-2.4.26/include/linux/init.h	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/include/linux/init.h	2005-01-01 22:58:49.000000000 +0100
@@ -156,6 +156,14 @@
 #define __devexitdata __exitdata
 #endif
 
+#ifndef __ASSEMBLY__
+#define __instrument
+#define __noinstrument __attribute__ ((no_instrument_function))
+#ifdef CONFIG_KFI
+extern int kfi_dump_log(char* buf);
+#endif
+#endif
+
 /* Functions marked as __devexit may be discarded at kernel link time, depending
    on config options.  Newer versions of binutils detect references from
    retained sections to discarded sections and flag an error.  Pointers to
diff -rbBNu linux-2.4.26/include/linux/kfi.h linux-2.4.26-kfi-big/include/linux/kfi.h
--- linux-2.4.26/include/linux/kfi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.26-kfi-big/include/linux/kfi.h	2005-01-01 22:54:11.000000000 +0100
@@ -0,0 +1,84 @@
+#ifndef _LINUX_KFI_H
+#define _LINUX_KFI_H
+
+#define KFI_DEBUG
+
+typedef struct kfi_entry {
+	void *va;            /* VA of instrumented function */
+	void *call_site;     /* where this func was called */
+	unsigned long time;  /* function entry time since trigger start time,
+				in usec */
+	unsigned long delta; /* delta time from entry to exit, in usec */
+	int           pid;
+} kfi_entry_t;
+
+#define INTR_CONTEXT -1
+
+typedef enum kfi_trigger_type {
+	TRIGGER_NONE = 0,
+	TRIGGER_TIME,
+	TRIGGER_FUNC_ENTRY,
+	TRIGGER_FUNC_EXIT,
+	TRIGGER_PROC,
+	TRIGGER_DEV,
+	TRIGGER_LOG_FULL
+} kfi_trigger_type_t;
+
+typedef struct kfi_trigger {
+	enum kfi_trigger_type type;
+	union {
+		unsigned long time; // time since boot, in usec
+		void * func_addr;
+	};
+	unsigned long mark; // time at which this trigger occured
+} kfi_trigger_t;
+
+#define MAX_RUN_LOG_ENTRIES 131072
+#define MAX_FUNC_LIST_ENTRIES 512
+
+typedef struct kfi_filters {
+	unsigned long min_delta;
+	unsigned long max_delta;
+	int no_ints;
+	int only_ints;
+	void** func_list;
+	int func_list_size;
+#ifdef KFI_DEBUG
+	struct {
+		int delta;
+		int no_ints;
+		int only_ints;
+		int func_list;
+	} cnt;
+#endif
+} kfi_filters_t;
+
+typedef struct kfi_run {
+	int triggered;
+	int complete;
+	struct kfi_trigger start_trigger;
+	struct kfi_trigger stop_trigger;
+	struct kfi_filters filters;
+	struct kfi_entry* log;
+	int num_entries;
+	int next_entry;
+	int id;
+	struct kfi_run * next;
+
+#ifdef KFI_DEBUG
+	int notfound;
+#endif
+} kfi_run_t;
+
+/* Use 'i' as magic number */
+#define KFI_MAGIC  'i'
+
+#define KFI_RESET      _IO  (KFI_MAGIC, 0)
+#define KFI_NEW_RUN    _IOWR(KFI_MAGIC, 1, struct kfi_run)
+#define KFI_START      _IOR (KFI_MAGIC, 2, int)
+#define KFI_STOP       _IOR (KFI_MAGIC, 3, int)
+#define KFI_READ       _IOWR(KFI_MAGIC, 4, struct kfi_run)
+#define KFI_READ_CURR  _IOWR(KFI_MAGIC, 5, struct kfi_run)
+#define KFI_READ_TIMER _IOR (KFI_MAGIC, 6, unsigned long)
+
+#endif // _LINUX_KFI_H
diff -rbBNu linux-2.4.26/init/main.c linux-2.4.26-kfi-big/init/main.c
--- linux-2.4.26/init/main.c	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/init/main.c	2005-01-01 17:27:38.000000000 +0100
@@ -553,6 +553,12 @@
 
 extern void prepare_namespace(void);
 
+#ifdef CONFIG_KFI_STATIC_RUN
+void to_userspace()
+{
+}
+#endif /* CONFIG_KFI_STATIC_RUN */
+
 static int init(void * unused)
 {
 	struct files_struct *files;
@@ -592,6 +598,10 @@
 	 * trying to recover a really broken machine.
 	 */
 
+#ifdef CONFIG_KFI_STATIC_RUN
+	to_userspace();
+#endif /* CONFIG_KFI_STATIC_RUN */
+
 	if (execute_command)
 		run_init_process(execute_command);
 
diff -rbBNu linux-2.4.26/kernel/ksyms.c linux-2.4.26-kfi-big/kernel/ksyms.c
--- linux-2.4.26/kernel/ksyms.c	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4.26-kfi-big/kernel/ksyms.c	2005-01-01 22:57:14.000000000 +0100
@@ -58,6 +58,9 @@
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
+#ifdef CONFIG_BIGPHYS_AREA
+#include <linux/bigphysarea.h>
+#endif
 
 extern void set_device_ro(kdev_t dev,int flag);
 
@@ -131,6 +134,12 @@
 EXPORT_SYMBOL(kmap_prot);
 EXPORT_SYMBOL(kmap_pte);
 #endif
+#ifdef CONFIG_BIGPHYS_AREA
+EXPORT_SYMBOL(bigphysarea_alloc);
+EXPORT_SYMBOL(bigphysarea_free);
+EXPORT_SYMBOL(bigphysarea_alloc_pages);
+EXPORT_SYMBOL(bigphysarea_free_pages);
+#endif
 
 /* filesystem internal functions */
 EXPORT_SYMBOL(def_blk_fops);
diff -rbBNu linux-2.4.26/kernel/sys.c linux-2.4.26-kfi-big/kernel/sys.c
--- linux-2.4.26/kernel/sys.c	2005-01-01 20:54:04.000000000 +0100
+++ linux-2.4.26-kfi-big/kernel/sys.c	2005-01-01 17:27:38.000000000 +0100
@@ -14,7 +14,9 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
-
+#ifdef CONFIG_KFI
+#include <linux/kfi.h>
+#endif
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
@@ -304,6 +306,9 @@
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "Restarting system.\n");
 		machine_restart(NULL);
 		break;
@@ -318,6 +323,9 @@
 
 	case LINUX_REBOOT_CMD_HALT:
 		notifier_call_chain(&reboot_notifier_list, SYS_HALT, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "System halted.\n");
 		machine_halt();
 		do_exit(0);
@@ -325,6 +333,9 @@
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
 		notifier_call_chain(&reboot_notifier_list, SYS_POWER_OFF, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "Power down.\n");
 		machine_power_off();
 		do_exit(0);
@@ -339,6 +350,9 @@
 
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, buffer);
 		printk(KERN_EMERG "Restarting system with command '%s'.\n", buffer);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		machine_restart(buffer);
 		break;
 
diff -rbBNu linux-2.4.26/lib/inflate.c linux-2.4.26-kfi-big/lib/inflate.c
--- linux-2.4.26/lib/inflate.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.26-kfi-big/lib/inflate.c	2005-01-01 17:34:01.000000000 +0100
@@ -271,7 +271,7 @@
 STATIC unsigned hufts;         /* track memory usage */
 
 
-STATIC int huft_build(b, n, s, d, e, t, m)
+STATIC int __noinstrument huft_build(b, n, s, d, e, t, m)
 unsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
 unsigned n;             /* number of codes (assumed <= N_MAX) */
 unsigned s;             /* number of simple-valued codes (0..s-1) */
@@ -489,7 +489,7 @@
 
 
 
-STATIC int huft_free(t)
+STATIC int __noinstrument huft_free(t)
 struct huft *t;         /* table to free */
 /* Free the malloc'ed tables built by huft_build(), which makes a linked
    list of the tables it made, with the links in a dummy first entry of
@@ -510,7 +510,7 @@
 }
 
 
-STATIC int inflate_codes(tl, td, bl, bd)
+STATIC int __noinstrument inflate_codes(tl, td, bl, bd)
 struct huft *tl, *td;   /* literal/length and distance decoder tables */
 int bl, bd;             /* number of bits decoded by tl[] and td[] */
 /* inflate (decompress) the codes in a deflated (compressed) block.
@@ -619,7 +619,7 @@
 
 
 
-STATIC int inflate_stored()
+STATIC int __noinstrument inflate_stored()
 /* "decompress" an inflated type 0 (stored) block. */
 {
   unsigned n;           /* number of bytes in block */
@@ -675,7 +675,7 @@
 
 
 
-STATIC int inflate_fixed()
+STATIC int __noinstrument inflate_fixed()
 /* decompress an inflated type 1 (fixed Huffman codes) block.  We should
    either replace this with a custom decoder, or at least precompute the
    Huffman tables. */
@@ -729,7 +729,7 @@
 
 
 
-STATIC int inflate_dynamic()
+STATIC int __noinstrument inflate_dynamic()
 /* decompress an inflated type 2 (dynamic Huffman codes) block. */
 {
   int i;                /* temporary variables */
@@ -907,7 +907,7 @@
 
 
 
-STATIC int inflate_block(e)
+STATIC int __noinstrument inflate_block(e)
 int *e;                 /* last block flag */
 /* decompress an inflated block */
 {
@@ -954,7 +954,7 @@
 
 
 
-STATIC int inflate()
+STATIC int __noinstrument inflate()
 /* decompress an inflated entry */
 {
   int e;                /* last block flag */
@@ -1016,7 +1016,7 @@
  * gzip-1.0.3/makecrc.c.
  */
 
-static void
+static void __noinstrument
 makecrc(void)
 {
 /* Not copyrighted 1990 Mark Adler	*/
@@ -1064,7 +1064,7 @@
 /*
  * Do the uncompression!
  */
-static int gunzip(void)
+static int __noinstrument gunzip(void)
 {
     uch flags;
     unsigned char magic[2]; /* magic header */
diff -rbBNu linux-2.4.26/mm/Makefile linux-2.4.26-kfi-big/mm/Makefile
--- linux-2.4.26/mm/Makefile	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.26-kfi-big/mm/Makefile	2005-01-01 22:57:14.000000000 +0100
@@ -18,4 +18,6 @@
 
 obj-$(CONFIG_HIGHMEM) += highmem.o
 
+obj-$(CONFIG_BIGPHYS_AREA) += bigphysarea.o
+
 include $(TOPDIR)/Rules.make
diff -rbBNu linux-2.4.26/mm/bigphysarea.c linux-2.4.26-kfi-big/mm/bigphysarea.c
--- linux-2.4.26/mm/bigphysarea.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.26-kfi-big/mm/bigphysarea.c	2005-01-01 22:57:14.000000000 +0100
@@ -0,0 +1,347 @@
+/* linux/mm/bigphysarea.c, M. Welsh (mdw@cs.cornell.edu)
+ * Copyright (c) 1996 by Matt Welsh.
+ * Extended by Roger Butenuth (butenuth@uni-paderborn.de), October 1997
+ * Extended for linux-2.1.121 till 2.4.0 (June 2000)
+ *     by Pauline Middelink <middelink@polyware.nl>
+ *
+ * This is a set of routines which allow you to reserve a large (?) 
+ * amount of physical memory at boot-time, which can be allocated/deallocated
+ * by drivers. This memory is intended to be used for devices such as 
+ * video framegrabbers which need a lot of physical RAM (above the amount
+ * allocated by kmalloc). This is by no means efficient or recommended;
+ * to be used only in extreme circumstances.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ * 
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/ptrace.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/bigphysarea.h>
+
+static int get_info(char* buf, char**, off_t, int);
+
+typedef struct range_struct {
+	struct range_struct *next;
+	caddr_t base;			/* base of allocated block */
+	size_t  size;			/* size in bytes */
+} range_t;
+
+/*
+ * 0: nothing initialized
+ * 1: bigphysarea_pages initialized
+ * 2: free list initialized
+ */
+static int	init_level = 0;
+static int	bigphysarea_pages = 0;
+static caddr_t	bigphysarea = 0;
+static range_t	*free_list = NULL;
+static range_t	*used_list = NULL;
+static struct resource mem_resource = { "Bigphysarea", 0, 0, IORESOURCE_MEM|IORESOURCE_BUSY };
+
+static
+int __init bigphysarea_init(void)
+{
+	if (bigphysarea_pages == 0 || bigphysarea == 0)
+		return -EINVAL;
+
+	/* create to /proc entry for it */
+	if (!create_proc_info_entry("bigphysarea",0444,&proc_root,get_info)) {
+		// ohoh, no way to free the allocated memory!
+		// continue without proc support, it not fatal in itself
+//		free_bootmem((unsigned long)bigphysarea>>PAGE_SHIFT,bigphysarea_pages<<PAGE_SHIFT);
+//		bigphysarea = 0;
+//		return -ENOMEM;
+	}
+
+	init_level = 1;
+
+	printk(KERN_INFO "bigphysarea: Allocated %d pages at 0x%p.\n",
+	       bigphysarea_pages, bigphysarea);
+
+	return 0;
+}
+
+__initcall(bigphysarea_init);
+
+/*
+ * call when 'bigphysarea=' is given on the commandline.
+ *
+ * Strangely, bootmem is still active during this call, but
+ * during the processing of the initcalls it isn't anymore!
+ * So we alloc the needed memory here instead of bigphysarea_init().
+ */
+static
+int __init bigphysarea_setup(char *str)
+{
+	int par;
+	if (get_option(&str,&par)) {
+		bigphysarea_pages = par;
+		// Alloc the memory
+		bigphysarea = alloc_bootmem_low_pages(bigphysarea_pages<<PAGE_SHIFT);
+		if (!bigphysarea) {
+			printk(KERN_CRIT "bigphysarea: not enough memory for %d pages\n",bigphysarea_pages);
+			return -ENOMEM;
+		}
+
+		// register the resource for it
+		mem_resource.start = bigphysarea;
+		mem_resource.end = mem_resource.start + (bigphysarea_pages<<PAGE_SHIFT);
+		request_resource(&iomem_resource, &mem_resource);
+	}
+	return 1;
+}
+
+__setup("bigphysarea=", bigphysarea_setup);
+
+/*
+ * When we have pages but don't have a freelist, put all pages in
+ * one free list entry. Return 0 on success, 1 on error.
+ */
+static
+int init2(int priority)
+{
+	if (init_level == 1) {
+		free_list = kmalloc(sizeof(range_t), priority);
+		if (free_list != NULL) {
+			free_list->next = NULL;
+			free_list->base = bigphysarea;
+			free_list->size = bigphysarea_pages * PAGE_SIZE;
+			init_level = 2;
+			return 0;
+		}
+	}
+	return 1;
+}
+
+
+/*
+ * Allocate `count' pages from the big physical area. Pages are aligned to
+ * a multiple of `align'. `priority' has the same meaning in kmalloc, it
+ * is needed for management information.
+ * This function may not be called from an interrupt!
+ */
+caddr_t bigphysarea_alloc_pages(int count, int align, int priority)
+{
+	range_t *range, **range_ptr, *new_range, *align_range;
+	caddr_t aligned_base;
+
+	if (init_level < 2)
+		if (init2(priority))
+			return 0;
+	new_range   = NULL;
+	align_range = NULL;
+
+	if (align == 0)
+		align = PAGE_SIZE;
+	else
+		align = align * PAGE_SIZE;
+	/*
+	 * Search a free block which is large enough, even with alignment.
+	 */
+	range_ptr = &free_list;
+	while (*range_ptr != NULL) {
+		range = *range_ptr;
+		aligned_base =
+		  (caddr_t)((((unsigned long)range->base + align - 1) / align) * align);
+		if (aligned_base + count * PAGE_SIZE <= 
+		    range->base + range->size)
+			break;
+	     range_ptr = &range->next;
+	}
+	if (*range_ptr == NULL)
+		return 0;
+	range = *range_ptr;
+	/*
+	 * When we have to align, the pages needed for alignment can
+	 * be put back to the free pool.
+	 * We check here if we need a second range data structure later
+	 * and allocate it now, so that we don't have to check for a
+	 * failed kmalloc later.
+	 */
+	if (aligned_base - range->base + count * PAGE_SIZE < range->size) {
+		new_range = kmalloc(sizeof(range_t), priority);
+		if (new_range == NULL)
+			return NULL;
+	}
+	if (aligned_base != range->base) {
+		align_range = kmalloc(sizeof(range_t), priority);
+		if (align_range == NULL) {
+			if (new_range != NULL)
+				kfree(new_range);
+			return NULL;
+		}
+		align_range->base = range->base;
+		align_range->size = aligned_base - range->base;
+		range->base = aligned_base;
+		range->size -= align_range->size;
+		align_range->next = range;
+		*range_ptr = align_range;
+		range_ptr = &align_range->next;
+	}
+	if (new_range != NULL) {
+		/*
+		 * Range is larger than needed, create a new list element for
+		 * the used list and shrink the element in the free list.
+		 */
+		new_range->base        = range->base;
+		new_range->size        = count * PAGE_SIZE;
+		range->base = new_range->base + new_range->size;
+		range->size = range->size - new_range->size;
+	} else {
+		/*
+		 * Range fits perfectly, remove it from free list.
+		 */
+		*range_ptr = range->next;
+		new_range = range;
+	}
+	/*
+	 * Insert block into used list
+	 */
+	new_range->next = used_list;
+	used_list = new_range;
+
+	return new_range->base;
+}
+
+/*
+ * Free pages allocated with `bigphysarea_alloc_pages'. `base' must be an
+ * address returned by `bigphysarea_alloc_pages'.
+ * This function my not be called from an interrupt!
+ */
+void bigphysarea_free_pages(caddr_t base)
+{
+	range_t *prev, *next, *range, **range_ptr;
+  
+	/*
+	 * Search the block in the used list.
+	 */
+	for (range_ptr = &used_list;
+	     *range_ptr != NULL;
+	     range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base == base)
+			break;
+	if (*range_ptr == NULL) {
+		printk("bigphysarea_free_pages(0x%08x), not allocated!\n",
+		       (unsigned)base);
+		return;
+	}
+	range = *range_ptr;
+	/*
+	 * Remove range from the used list:
+	 */
+	*range_ptr = (*range_ptr)->next;
+	/*
+	 * The free-list is sorted by address, search insertion point
+	 * and insert block in free list.
+	 */
+	for (range_ptr = &free_list, prev = NULL;
+	     *range_ptr != NULL;
+	     prev = *range_ptr, range_ptr = &(*range_ptr)->next)
+		if ((*range_ptr)->base >= base)
+			break;
+	range->next  = *range_ptr;
+	*range_ptr   = range;
+	/*
+	 * Concatenate free range with neighbors, if possible.
+	 * Try for upper neighbor (next in list) first, then
+	 * for lower neighbor (predecessor in list).
+	 */
+	if (range->next != NULL &&
+	    range->base + range->size == range->next->base) {
+		next = range->next;
+		range->size += range->next->size;
+		range->next = next->next;
+		kfree(next);
+	}
+	if (prev != NULL &&
+	    prev->base + prev->size == range->base) {
+		prev->size += prev->next->size;
+		prev->next = range->next;
+		kfree(range);
+	}
+}
+
+caddr_t bigphysarea_alloc(int size)
+{
+	int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+	return bigphysarea_alloc_pages(pages, 1, GFP_KERNEL);
+}
+
+void bigphysarea_free(caddr_t addr, int size)
+{
+	(void)size;
+	bigphysarea_free_pages(addr);
+}
+
+static
+int get_info(char *buf, char **a, off_t b, int c)
+{
+	char    *p = buf;
+	range_t *ptr;
+	int     free_count, free_total, free_max;
+	int     used_count, used_total, used_max;
+
+	if (init_level == 1)
+	  init2(GFP_KERNEL);
+
+	free_count = 0;
+	free_total = 0;
+	free_max   = 0;
+	for (ptr = free_list; ptr != NULL; ptr = ptr->next) {
+		free_count++;
+		free_total += ptr->size;
+		if (ptr->size > free_max)
+			free_max = ptr->size;
+	}
+
+	used_count = 0;
+	used_total = 0;
+	used_max   = 0;
+	for (ptr = used_list; ptr != NULL; ptr = ptr->next) {
+		used_count++;
+		used_total += ptr->size;
+		if (ptr->size > used_max)
+			used_max = ptr->size;
+	}
+
+	if (bigphysarea_pages == 0) {
+		p += sprintf(p, "No big physical area allocated!\n");
+		return  p - buf;
+	}
+	  
+	p += sprintf(p, "Big physical area, size %ld kB\n",
+		     bigphysarea_pages * PAGE_SIZE / 1024);
+	p += sprintf(p, "                       free list:             used list:\n");
+	p += sprintf(p, "number of blocks:      %8d               %8d\n",
+		     free_count, used_count);
+	p += sprintf(p, "size of largest block: %8d kB            %8d kB\n",
+		     free_max / 1024, used_max / 1024);
+	p += sprintf(p, "total:                 %8d kB            %8d kB\n",
+		     free_total / 1024, used_total /1024);
+
+	return  p - buf;
+}

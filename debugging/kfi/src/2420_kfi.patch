diff -rbNu linux-2.4.20-std/Makefile linux-2.4.20-kfi/Makefile
--- linux-2.4.20-std/Makefile	2002-11-29 00:53:16.000000000 +0100
+++ linux-2.4.20-kfi/Makefile	2004-12-30 22:37:56.000000000 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 20
-EXTRAVERSION =
+EXTRAVERSION =-kfi
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -90,9 +90,15 @@
 
 CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
 	  -fno-strict-aliasing -fno-common
+
 ifndef CONFIG_FRAME_POINTER
 CFLAGS += -fomit-frame-pointer
 endif
+
+ifdef CONFIG_KFI
+CFLAGS += -finstrument-functions
+endif
+
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
 #
@@ -201,6 +207,7 @@
 	.tmp* \
 	drivers/char/consolemap_deftbl.c drivers/video/promcon_tbl.c \
 	drivers/char/conmakehash \
+	drivers/char/kfistatic.c \
 	drivers/char/drm/*-mod.c \
 	drivers/pci/devlist.h drivers/pci/classlist.h drivers/pci/gen-devlist \
 	drivers/zorro/devlist.h drivers/zorro/gen-devlist \
diff -rbNu linux-2.4.20-std/arch/arm/config.in linux-2.4.20-kfi/arch/arm/config.in
--- linux-2.4.20-std/arch/arm/config.in	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.20-kfi/arch/arm/config.in	2004-12-30 22:14:48.000000000 +0100
@@ -654,6 +654,8 @@
 dep_bool '  Kernel low-level debugging functions' CONFIG_DEBUG_LL $CONFIG_DEBUG_KERNEL
 dep_bool '    Kernel low-level debugging messages via footbridge serial port' CONFIG_DEBUG_DC21285_PORT $CONFIG_DEBUG_LL $CONFIG_FOOTBRIDGE
 dep_bool '    Kernel low-level debugging messages via UART2' CONFIG_DEBUG_CLPS711X_UART2 $CONFIG_DEBUG_LL $CONFIG_ARCH_CLPS711X
+bool 'Kernel Function Instrumentation' CONFIG_KFI
+dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
 endmenu
 
 source lib/Config.in
diff -rbNu linux-2.4.20-std/arch/i386/boot/Makefile linux-2.4.20-kfi/arch/i386/boot/Makefile
--- linux-2.4.20-std/arch/i386/boot/Makefile	2001-08-05 22:13:19.000000000 +0200
+++ linux-2.4.20-kfi/arch/i386/boot/Makefile	2004-12-30 22:32:45.000000000 +0100
@@ -8,6 +8,7 @@
 # Copyright (C) 1994 by Linus Torvalds
 #
 
+CFLAGS_KERNEL+=-fno-inline
 BOOT_INCL =	$(TOPDIR)/include/linux/config.h \
 		$(TOPDIR)/include/linux/autoconf.h \
 		$(TOPDIR)/include/asm/boot.h
diff -rbNu linux-2.4.20-std/arch/i386/boot/compressed/misc.c linux-2.4.20-kfi/arch/i386/boot/compressed/misc.c
--- linux-2.4.20-std/arch/i386/boot/compressed/misc.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.20-kfi/arch/i386/boot/compressed/misc.c	2004-12-30 22:49:15.000000000 +0100
@@ -128,7 +128,7 @@
 
 #include "../../../../lib/inflate.c"
 
-static void *malloc(int size)
+static void __noinstrument *malloc(int size)
 {
 	void *p;
 
@@ -146,21 +146,21 @@
 	return p;
 }
 
-static void free(void *where)
+static void __noinstrument free(void *where)
 {	/* Don't care */
 }
 
-static void gzip_mark(void **ptr)
+static void __noinstrument gzip_mark(void **ptr)
 {
 	*ptr = (void *) free_mem_ptr;
 }
 
-static void gzip_release(void **ptr)
+static void __noinstrument gzip_release(void **ptr)
 {
 	free_mem_ptr = (long) *ptr;
 }
  
-static void scroll(void)
+static void __noinstrument scroll(void)
 {
 	int i;
 
@@ -169,7 +169,7 @@
 		vidmem[i] = ' ';
 }
 
-static void puts(const char *s)
+static void __noinstrument puts(const char *s)
 {
 	int x,y,pos;
 	char c;
@@ -206,7 +206,7 @@
 	outb_p(0xff & (pos >> 1), vidport+1);
 }
 
-static void* memset(void* s, int c, size_t n)
+static void* __noinstrument memset(void* s, int c, size_t n)
 {
 	int i;
 	char *ss = (char*)s;
@@ -215,7 +215,7 @@
 	return s;
 }
 
-static void* memcpy(void* __dest, __const void* __src,
+static void* __noinstrument memcpy(void* __dest, __const void* __src,
 			    size_t __n)
 {
 	int i;
@@ -229,7 +229,7 @@
  * Fill the input buffer. This is called only when the buffer is empty
  * and at least one byte is really needed.
  */
-static int fill_inbuf(void)
+static int __noinstrument fill_inbuf(void)
 {
 	if (insize != 0) {
 		error("ran out of input data\n");
@@ -245,7 +245,7 @@
  * Write the output window window[0..outcnt-1] and update crc and bytes_out.
  * (Used for the decompressed data only.)
  */
-static void flush_window_low(void)
+static void __noinstrument flush_window_low(void)
 {
     ulg c = crc;         /* temporary variable */
     unsigned n;
@@ -263,7 +263,7 @@
     outcnt = 0;
 }
 
-static void flush_window_high(void)
+static void __noinstrument flush_window_high(void)
 {
     ulg c = crc;         /* temporary variable */
     unsigned n;
@@ -279,13 +279,13 @@
     outcnt = 0;
 }
 
-static void flush_window(void)
+static void __noinstrument flush_window(void)
 {
 	if (high_loaded) flush_window_high();
 	else flush_window_low();
 }
 
-static void error(char *x)
+static void __noinstrument error(char *x)
 {
 	puts("\n\n");
 	puts(x);
@@ -303,7 +303,7 @@
 	short b;
 	} stack_start = { & user_stack [STACK_SIZE] , __KERNEL_DS };
 
-static void setup_normal_output_buffer(void)
+static void __noinstrument setup_normal_output_buffer(void)
 {
 #ifdef STANDARD_MEMORY_BIOS_CALL
 	if (EXT_MEM_K < 1024) error("Less than 2MB of memory.\n");
@@ -319,7 +319,7 @@
 	uch *high_buffer_start; int hcount;
 };
 
-static void setup_output_buffer_if_we_run_high(struct moveparams *mv)
+static void __noinstrument setup_output_buffer_if_we_run_high(struct moveparams *mv)
 {
 	high_buffer_start = (uch *)(((ulg)&end) + HEAP_SIZE);
 #ifdef STANDARD_MEMORY_BIOS_CALL
@@ -341,7 +341,7 @@
 	mv->high_buffer_start = high_buffer_start;
 }
 
-static void close_output_buffer_if_we_run_high(struct moveparams *mv)
+static void __noinstrument close_output_buffer_if_we_run_high(struct moveparams *mv)
 {
 	if (bytes_out > low_buffer_size) {
 		mv->lcount = low_buffer_size;
@@ -354,7 +354,7 @@
 }
 
 
-asmlinkage int decompress_kernel(struct moveparams *mv, void *rmode)
+asmlinkage int __noinstrument decompress_kernel(struct moveparams *mv, void *rmode)
 {
 	real_mode = rmode;
 
diff -rbNu linux-2.4.20-std/arch/i386/config.in linux-2.4.20-kfi/arch/i386/config.in
--- linux-2.4.20-std/arch/i386/config.in	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.20-kfi/arch/i386/config.in	2004-12-30 22:14:48.000000000 +0100
@@ -452,6 +452,8 @@
    bool '  Spinlock debugging' CONFIG_DEBUG_SPINLOCK
    bool '  Compile the kernel with frame pointers' CONFIG_FRAME_POINTER
 fi
+bool 'Kernel Function Instrumentation' CONFIG_KFI
+dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
 
 endmenu
 
diff -rbNu linux-2.4.20-std/arch/m68k/kernel/traps.c linux-2.4.20-kfi/arch/m68k/kernel/traps.c
--- linux-2.4.20-std/arch/m68k/kernel/traps.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.20-kfi/arch/m68k/kernel/traps.c	2004-12-30 22:15:55.000000000 +0100
@@ -446,7 +446,7 @@
 
 /* sun3 version of bus_error030 */
 
-extern inline void bus_error030 (struct frame *fp)
+static inline void bus_error030 (struct frame *fp)
 {
 	unsigned char buserr_type = sun3_get_buserr ();
 	unsigned long addr, errorcode;
diff -rbNu linux-2.4.20-std/arch/m68k/math-emu/multi_arith.h linux-2.4.20-kfi/arch/m68k/math-emu/multi_arith.h
--- linux-2.4.20-std/arch/m68k/math-emu/multi_arith.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.20-kfi/arch/m68k/math-emu/multi_arith.h	2004-12-30 22:15:55.000000000 +0100
@@ -38,13 +38,13 @@
 
 /* Convenience functions to stuff various integer values into int128s */
 
-extern inline void zero128(int128 a)
+static inline void zero128(int128 a)
 {
 	a[LSW128] = a[NLSW128] = a[NMSW128] = a[MSW128] = 0;
 }
 
 /* Human-readable word order in the arguments */
-extern inline void set128(unsigned int i3,
+static inline void set128(unsigned int i3,
 			  unsigned int i2,
 			  unsigned int i1,
 			  unsigned int i0,
@@ -57,7 +57,7 @@
 }
 
 /* Convenience functions (for testing as well) */
-extern inline void int64_to_128(unsigned long long src,
+static inline void int64_to_128(unsigned long long src,
 				int128 dest)
 {
 	dest[LSW128] = (unsigned int) src;
@@ -65,13 +65,13 @@
 	dest[NMSW128] = dest[MSW128] = 0;
 }
 
-extern inline void int128_to_64(const int128 src,
+static inline void int128_to_64(const int128 src,
 				unsigned long long *dest)
 {
 	*dest = src[LSW128] | (long long) src[NLSW128] << 32;
 }
 
-extern inline void put_i128(const int128 a)
+static inline void put_i128(const int128 a)
 {
 	printk("%08x %08x %08x %08x\n", a[MSW128], a[NMSW128],
 	       a[NLSW128], a[LSW128]);
@@ -82,7 +82,7 @@
    Note that these are only good for 0 < count < 32.
  */
 
-extern inline void _lsl128(unsigned int count, int128 a)
+static inline void _lsl128(unsigned int count, int128 a)
 {
 	a[MSW128] = (a[MSW128] << count) | (a[NMSW128] >> (32 - count));
 	a[NMSW128] = (a[NMSW128] << count) | (a[NLSW128] >> (32 - count));
@@ -90,7 +90,7 @@
 	a[LSW128] <<= count;
 }
 
-extern inline void _lsr128(unsigned int count, int128 a)
+static inline void _lsr128(unsigned int count, int128 a)
 {
 	a[LSW128] = (a[LSW128] >> count) | (a[NLSW128] << (32 - count));
 	a[NLSW128] = (a[NLSW128] >> count) | (a[NMSW128] << (32 - count));
@@ -100,7 +100,7 @@
 
 /* Should be faster, one would hope */
 
-extern inline void lslone128(int128 a)
+static inline void lslone128(int128 a)
 {
 	asm volatile ("lsl.l #1,%0\n"
 		      "roxl.l #1,%1\n"
@@ -118,7 +118,7 @@
 		      "3"(a[MSW128]));
 }
 
-extern inline void lsrone128(int128 a)
+static inline void lsrone128(int128 a)
 {
 	asm volatile ("lsr.l #1,%0\n"
 		      "roxr.l #1,%1\n"
@@ -140,7 +140,7 @@
 
    These bit-shift to a multiple of 32, then move whole longwords.  */
 
-extern inline void lsl128(unsigned int count, int128 a)
+static inline void lsl128(unsigned int count, int128 a)
 {
 	int wordcount, i;
 
@@ -159,7 +159,7 @@
 	}
 }
 
-extern inline void lsr128(unsigned int count, int128 a)
+static inline void lsr128(unsigned int count, int128 a)
 {
 	int wordcount, i;
 
@@ -177,18 +177,18 @@
 	}
 }
 
-extern inline int orl128(int a, int128 b)
+static inline int orl128(int a, int128 b)
 {
 	b[LSW128] |= a;
 }
 
-extern inline int btsthi128(const int128 a)
+static inline int btsthi128(const int128 a)
 {
 	return a[MSW128] & 0x80000000;
 }
 
 /* test bits (numbered from 0 = LSB) up to and including "top" */
-extern inline int bftestlo128(int top, const int128 a)
+static inline int bftestlo128(int top, const int128 a)
 {
 	int r = 0;
 
@@ -206,7 +206,7 @@
 
 /* Aargh.  We need these because GCC is broken */
 /* FIXME: do them in assembly, for goodness' sake! */
-extern inline void mask64(int pos, unsigned long long *mask)
+static inline void mask64(int pos, unsigned long long *mask)
 {
 	*mask = 0;
 
@@ -218,7 +218,7 @@
 	HI_WORD(*mask) = (1 << (pos - 32)) - 1;
 }
 
-extern inline void bset64(int pos, unsigned long long *dest)
+static inline void bset64(int pos, unsigned long long *dest)
 {
 	/* This conditional will be optimized away.  Thanks, GCC! */
 	if (pos < 32)
@@ -229,7 +229,7 @@
 			      (HI_WORD(*dest)):"id"(pos - 32));
 }
 
-extern inline int btst64(int pos, unsigned long long dest)
+static inline int btst64(int pos, unsigned long long dest)
 {
 	if (pos < 32)
 		return (0 != (LO_WORD(dest) & (1 << pos)));
@@ -237,7 +237,7 @@
 		return (0 != (HI_WORD(dest) & (1 << (pos - 32))));
 }
 
-extern inline void lsl64(int count, unsigned long long *dest)
+static inline void lsl64(int count, unsigned long long *dest)
 {
 	if (count < 32) {
 		HI_WORD(*dest) = (HI_WORD(*dest) << count)
@@ -250,7 +250,7 @@
 	LO_WORD(*dest) = 0;
 }
 
-extern inline void lsr64(int count, unsigned long long *dest)
+static inline void lsr64(int count, unsigned long long *dest)
 {
 	if (count < 32) {
 		LO_WORD(*dest) = (LO_WORD(*dest) >> count)
@@ -264,7 +264,7 @@
 }
 #endif
 
-extern inline void fp_denormalize(struct fp_ext *reg, unsigned int cnt)
+static inline void fp_denormalize(struct fp_ext *reg, unsigned int cnt)
 {
 	reg->exp += cnt;
 
@@ -306,7 +306,7 @@
 	}
 }
 
-extern inline int fp_overnormalize(struct fp_ext *reg)
+static inline int fp_overnormalize(struct fp_ext *reg)
 {
 	int shift;
 
@@ -324,7 +324,7 @@
 	return shift;
 }
 
-extern inline int fp_addmant(struct fp_ext *dest, struct fp_ext *src)
+static inline int fp_addmant(struct fp_ext *dest, struct fp_ext *src)
 {
 	int carry;
 
@@ -340,7 +340,7 @@
 	return carry;
 }
 
-extern inline int fp_addcarry(struct fp_ext *reg)
+static inline int fp_addcarry(struct fp_ext *reg)
 {
 	if (++reg->exp == 0x7fff) {
 		if (reg->mant.m64)
@@ -357,7 +357,7 @@
 	return 1;
 }
 
-extern inline void fp_submant(struct fp_ext *dest, struct fp_ext *src1, struct fp_ext *src2)
+static inline void fp_submant(struct fp_ext *dest, struct fp_ext *src1, struct fp_ext *src2)
 {
 	/* we assume here, gcc only insert move and a clr instr */
 	asm volatile ("sub.b %1,%0" : "=d,g" (dest->lowmant)
@@ -407,7 +407,7 @@
 	carry;								\
 })
 
-extern inline void fp_multiplymant(union fp_mant128 *dest, struct fp_ext *src1, struct fp_ext *src2)
+static inline void fp_multiplymant(union fp_mant128 *dest, struct fp_ext *src1, struct fp_ext *src2)
 {
 	union fp_mant64 temp;
 
@@ -421,7 +421,7 @@
 	fp_addx96(dest, temp);
 }
 
-extern inline void fp_dividemant(union fp_mant128 *dest, struct fp_ext *src, struct fp_ext *div)
+static inline void fp_dividemant(union fp_mant128 *dest, struct fp_ext *src, struct fp_ext *div)
 {
 	union fp_mant128 tmp;
 	union fp_mant64 tmp64;
@@ -484,7 +484,7 @@
 }
 
 #if 0
-extern inline unsigned int fp_fls128(union fp_mant128 *src)
+static inline unsigned int fp_fls128(union fp_mant128 *src)
 {
 	unsigned long data;
 	unsigned int res, off;
@@ -504,7 +504,7 @@
 	return res + off;
 }
 
-extern inline void fp_shiftmant128(union fp_mant128 *src, int shift)
+static inline void fp_shiftmant128(union fp_mant128 *src, int shift)
 {
 	unsigned long sticky;
 
@@ -594,7 +594,7 @@
 }
 #endif
 
-extern inline void fp_putmant128(struct fp_ext *dest, union fp_mant128 *src, int shift)
+static inline void fp_putmant128(struct fp_ext *dest, union fp_mant128 *src, int shift)
 {
 	unsigned long tmp;
 
@@ -639,7 +639,7 @@
 }
 
 #if 0 /* old code... */
-extern inline int fls(unsigned int a)
+static inline int fls(unsigned int a)
 {
 	int r;
 
@@ -649,7 +649,7 @@
 }
 
 /* fls = "find last set" (cf. ffs(3)) */
-extern inline int fls128(const int128 a)
+static inline int fls128(const int128 a)
 {
 	if (a[MSW128])
 		return fls(a[MSW128]);
@@ -668,12 +668,12 @@
 		return -1;
 }
 
-extern inline int zerop128(const int128 a)
+static inline int zerop128(const int128 a)
 {
 	return !(a[LSW128] | a[NLSW128] | a[NMSW128] | a[MSW128]);
 }
 
-extern inline int nonzerop128(const int128 a)
+static inline int nonzerop128(const int128 a)
 {
 	return (a[LSW128] | a[NLSW128] | a[NMSW128] | a[MSW128]);
 }
@@ -681,7 +681,7 @@
 /* Addition and subtraction */
 /* Do these in "pure" assembly, because "extended" asm is unmanageable
    here */
-extern inline void add128(const int128 a, int128 b)
+static inline void add128(const int128 a, int128 b)
 {
 	/* rotating carry flags */
 	unsigned int carry[2];
@@ -699,7 +699,7 @@
 }
 
 /* Note: assembler semantics: "b -= a" */
-extern inline void sub128(const int128 a, int128 b)
+static inline void sub128(const int128 a, int128 b)
 {
 	/* rotating borrow flags */
 	unsigned int borrow[2];
@@ -717,7 +717,7 @@
 }
 
 /* Poor man's 64-bit expanding multiply */
-extern inline void mul64(unsigned long long a,
+static inline void mul64(unsigned long long a,
 		  unsigned long long b,
 		  int128 c)
 {
@@ -756,7 +756,7 @@
 }
 
 /* Note: unsigned */
-extern inline int cmp128(int128 a, int128 b)
+static inline int cmp128(int128 a, int128 b)
 {
 	if (a[MSW128] < b[MSW128])
 		return -1;
diff -rbNu linux-2.4.20-std/arch/mips/config-shared.in linux-2.4.20-kfi/arch/mips/config-shared.in
--- linux-2.4.20-std/arch/mips/config-shared.in	2002-11-29 00:53:09.000000000 +0100
+++ linux-2.4.20-kfi/arch/mips/config-shared.in	2004-12-30 22:14:48.000000000 +0100
@@ -798,6 +798,8 @@
 if [ "$CONFIG_SMP" != "y" ]; then
    bool 'Run uncached' CONFIG_MIPS_UNCACHED
 fi
+bool 'Kernel Function Instrumentation' CONFIG_KFI
+dep_bool '  Static Instrumentation Configs' CONFIG_KFI_STATIC_RUN $CONFIG_KFI
 endmenu
 
 source lib/Config.in
diff -rbNu linux-2.4.20-std/arch/mips64/kernel/linux32.c linux-2.4.20-kfi/arch/mips64/kernel/linux32.c
--- linux-2.4.20-std/arch/mips64/kernel/linux32.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.20-kfi/arch/mips64/kernel/linux32.c	2004-12-30 22:15:55.000000000 +0100
@@ -2298,7 +2298,7 @@
 	return err;
 }
 
-extern __inline__ void
+static __inline__ void
 sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
diff -rbNu linux-2.4.20-std/arch/parisc/kernel/ioctl32.c linux-2.4.20-kfi/arch/parisc/kernel/ioctl32.c
--- linux-2.4.20-std/arch/parisc/kernel/ioctl32.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.20-kfi/arch/parisc/kernel/ioctl32.c	2004-12-30 22:15:55.000000000 +0100
@@ -3616,7 +3616,7 @@
 
 unsigned int ioctl32_hash_table[1024];
 
-extern inline unsigned long ioctl32_hash(unsigned long cmd)
+static inline unsigned long ioctl32_hash(unsigned long cmd)
 {
 	return ((cmd >> 6) ^ (cmd >> 4) ^ cmd) & 0x3ff;
 }
diff -rbNu linux-2.4.20-std/arch/parisc/kernel/sys_parisc32.c linux-2.4.20-kfi/arch/parisc/kernel/sys_parisc32.c
--- linux-2.4.20-std/arch/parisc/kernel/sys_parisc32.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-2.4.20-kfi/arch/parisc/kernel/sys_parisc32.c	2004-12-30 22:15:55.000000000 +0100
@@ -1779,7 +1779,7 @@
 extern struct socket *sockfd_lookup(int fd, int *err);
 
 /* XXX This as well... */
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/ppc/platforms/pal4.h linux-2.4.20-kfi/arch/ppc/platforms/pal4.h
--- linux-2.4.20-std/arch/ppc/platforms/pal4.h	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/ppc/platforms/pal4.h	2004-12-30 22:15:54.000000000 +0100
@@ -32,7 +32,7 @@
 #define CPC700_MB4SA            0x48
 #define CPC700_MB4EA            0x68
 
-extern inline long
+static inline long
 cpc700_read_memreg(int reg)
 {
 	out_be32((volatile unsigned int *) CPC700_MEM_CFGADDR, reg);
diff -rbNu linux-2.4.20-std/arch/ppc/xmon/xmon.c linux-2.4.20-kfi/arch/ppc/xmon/xmon.c
--- linux-2.4.20-std/arch/ppc/xmon/xmon.c	2002-02-25 20:37:55.000000000 +0100
+++ linux-2.4.20-kfi/arch/ppc/xmon/xmon.c	2004-12-30 22:15:55.000000000 +0100
@@ -150,12 +150,12 @@
 
 static struct pt_regs *xmon_regs[NR_CPUS];
 
-extern inline void sync(void)
+static inline void sync(void)
 {
 	asm volatile("sync; isync");
 }
 
-extern inline void __delay(unsigned int loops)
+static inline void __delay(unsigned int loops)
 {
 	if (loops != 0)
 		__asm__ __volatile__("mtctr %0; 1: bdnz 1b" : :
diff -rbNu linux-2.4.20-std/arch/ppc64/kernel/ioctl32.c linux-2.4.20-kfi/arch/ppc64/kernel/ioctl32.c
--- linux-2.4.20-std/arch/ppc64/kernel/ioctl32.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/ppc64/kernel/ioctl32.c	2004-12-30 22:15:51.000000000 +0100
@@ -756,7 +756,7 @@
 
 extern struct socket *sockfd_lookup(int fd, int *err);
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/ppc64/kernel/open_pic.h linux-2.4.20-kfi/arch/ppc64/kernel/open_pic.h
--- linux-2.4.20-std/arch/ppc64/kernel/open_pic.h	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.20-kfi/arch/ppc64/kernel/open_pic.h	2004-12-30 22:15:52.000000000 +0100
@@ -37,7 +37,7 @@
 extern void openpic_setup_ISU(int isu_num, unsigned long addr);
 extern void openpic_cause_IPI(u_int ipi, u_int cpumask);
 
-extern inline int openpic_to_irq(int irq)
+static inline int openpic_to_irq(int irq)
 {
 	return irq += NUM_8259_INTERRUPTS;
 }
diff -rbNu linux-2.4.20-std/arch/ppc64/kernel/sys_ppc32.c linux-2.4.20-kfi/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.4.20-std/arch/ppc64/kernel/sys_ppc32.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/ppc64/kernel/sys_ppc32.c	2004-12-30 22:15:51.000000000 +0100
@@ -3261,12 +3261,12 @@
 			       __cmsg, __cmsg_len);
 }
 
-extern __inline__ struct socket *socki_lookup(struct inode *inode)
+static __inline__ struct socket *socki_lookup(struct inode *inode)
 {
 	return &inode->u.socket_i;
 }
 
-extern __inline__ struct socket *sockfd_lookup(int fd, int *err)
+static __inline__ struct socket *sockfd_lookup(int fd, int *err)
 {
 	struct file *file;
 	struct inode *inode;
@@ -3288,7 +3288,7 @@
 	return socki_lookup(inode);
 }
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/ppc64/xmon/xmon.c linux-2.4.20-kfi/arch/ppc64/xmon/xmon.c
--- linux-2.4.20-std/arch/ppc64/xmon/xmon.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/ppc64/xmon/xmon.c	2004-12-30 22:15:51.000000000 +0100
@@ -184,7 +184,7 @@
 /*
  * Stuff for reading and writing memory safely
  */
-extern inline void sync(void)
+static inline void sync(void)
 {
 	asm volatile("sync; isync");
 }
diff -rbNu linux-2.4.20-std/arch/s390/kernel/debug.c linux-2.4.20-kfi/arch/s390/kernel/debug.c
--- linux-2.4.20-std/arch/s390/kernel/debug.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/s390/kernel/debug.c	2004-12-30 22:15:55.000000000 +0100
@@ -409,7 +409,7 @@
  * - goto next entry in p_info
  */
 
-extern inline int debug_next_entry(file_private_info_t *p_info)
+static inline int debug_next_entry(file_private_info_t *p_info)
 {
 	debug_info_t *id = p_info->debug_info_snap;
 	if(p_info->act_entry == DEBUG_PROLOG_ENTRY){
@@ -756,7 +756,7 @@
  * - set active entry to next in the ring buffer
  */
 
-extern inline void proceed_active_entry(debug_info_t * id)
+static inline void proceed_active_entry(debug_info_t * id)
 {
 	if ((id->active_entry[id->active_area] += id->entry_size)
 	    > ((PAGE_SIZE << (id->page_order)) - id->entry_size))
@@ -768,7 +768,7 @@
  * - set active area to next in the ring buffer
  */
 
-extern inline void proceed_active_area(debug_info_t * id)
+static inline void proceed_active_area(debug_info_t * id)
 {
 	id->active_area++;
 	id->active_area = id->active_area % id->nr_areas;
@@ -778,7 +778,7 @@
  * get_active_entry:
  */
 
-extern inline debug_entry_t *get_active_entry(debug_info_t * id)
+static inline debug_entry_t *get_active_entry(debug_info_t * id)
 {
 	return (debug_entry_t *) ((char *) id->areas[id->active_area] +
 				  id->active_entry[id->active_area]);
@@ -789,7 +789,7 @@
  * - set timestamp, caller address, cpu number etc.
  */
 
-extern inline debug_entry_t *debug_common(debug_info_t * id, int level, 
+static inline debug_entry_t *debug_common(debug_info_t * id, int level, 
                                     const void *buf, int len, int exception)
 {
 	unsigned long flags;
@@ -838,7 +838,7 @@
  * counts arguments in format string for sprintf view
  */
 
-extern inline int debug_count_numargs(char *string)
+static inline int debug_count_numargs(char *string)
 {
 	int numargs=0;
 
diff -rbNu linux-2.4.20-std/arch/s390/mm/fault.c linux-2.4.20-kfi/arch/s390/mm/fault.c
--- linux-2.4.20-std/arch/s390/mm/fault.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/s390/mm/fault.c	2004-12-30 22:15:55.000000000 +0100
@@ -145,7 +145,7 @@
  *   10       Segment translation  ->  Not present       (nullification)
  *   11       Page translation     ->  Not present       (nullification)
  */
-extern inline void do_exception(struct pt_regs *regs, unsigned long error_code)
+static inline void do_exception(struct pt_regs *regs, unsigned long error_code)
 {
         struct task_struct *tsk;
         struct mm_struct *mm;
diff -rbNu linux-2.4.20-std/arch/s390x/kernel/debug.c linux-2.4.20-kfi/arch/s390x/kernel/debug.c
--- linux-2.4.20-std/arch/s390x/kernel/debug.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/s390x/kernel/debug.c	2004-12-30 22:15:55.000000000 +0100
@@ -409,7 +409,7 @@
  * - goto next entry in p_info
  */
 
-extern inline int debug_next_entry(file_private_info_t *p_info)
+static inline int debug_next_entry(file_private_info_t *p_info)
 {
 	debug_info_t *id = p_info->debug_info_snap;
 	if(p_info->act_entry == DEBUG_PROLOG_ENTRY){
@@ -756,7 +756,7 @@
  * - set active entry to next in the ring buffer
  */
 
-extern inline void proceed_active_entry(debug_info_t * id)
+static inline void proceed_active_entry(debug_info_t * id)
 {
 	if ((id->active_entry[id->active_area] += id->entry_size)
 	    > ((PAGE_SIZE << (id->page_order)) - id->entry_size))
@@ -768,7 +768,7 @@
  * - set active area to next in the ring buffer
  */
 
-extern inline void proceed_active_area(debug_info_t * id)
+static inline void proceed_active_area(debug_info_t * id)
 {
 	id->active_area++;
 	id->active_area = id->active_area % id->nr_areas;
@@ -778,7 +778,7 @@
  * get_active_entry:
  */
 
-extern inline debug_entry_t *get_active_entry(debug_info_t * id)
+static inline debug_entry_t *get_active_entry(debug_info_t * id)
 {
 	return (debug_entry_t *) ((char *) id->areas[id->active_area] +
 				  id->active_entry[id->active_area]);
@@ -789,7 +789,7 @@
  * - set timestamp, caller address, cpu number etc.
  */
 
-extern inline debug_entry_t *debug_common(debug_info_t * id, int level, 
+static inline debug_entry_t *debug_common(debug_info_t * id, int level, 
                                     const void *buf, int len, int exception)
 {
 	unsigned long flags;
@@ -838,7 +838,7 @@
  * counts arguments in format string for sprintf view
  */
 
-extern inline int debug_count_numargs(char *string)
+static inline int debug_count_numargs(char *string)
 {
 	int numargs=0;
 
diff -rbNu linux-2.4.20-std/arch/s390x/kernel/linux32.c linux-2.4.20-kfi/arch/s390x/kernel/linux32.c
--- linux-2.4.20-std/arch/s390x/kernel/linux32.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.20-kfi/arch/s390x/kernel/linux32.c	2004-12-30 22:15:55.000000000 +0100
@@ -2223,7 +2223,7 @@
 extern struct socket *sockfd_lookup(int fd, int *err);
 
 /* XXX This as well... */
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/s390x/mm/fault.c linux-2.4.20-kfi/arch/s390x/mm/fault.c
--- linux-2.4.20-std/arch/s390x/mm/fault.c	2002-11-29 00:53:11.000000000 +0100
+++ linux-2.4.20-kfi/arch/s390x/mm/fault.c	2004-12-30 22:15:55.000000000 +0100
@@ -145,7 +145,7 @@
  *   11       Page translation     ->  Not present       (nullification)
  *   3b       Region third trans.  ->  Not present       (nullification)
  */
-extern inline void do_exception(struct pt_regs *regs, unsigned long error_code)
+static inline void do_exception(struct pt_regs *regs, unsigned long error_code)
 {
         struct task_struct *tsk;
         struct mm_struct *mm;
diff -rbNu linux-2.4.20-std/arch/sparc/kernel/time.c linux-2.4.20-kfi/arch/sparc/kernel/time.c
--- linux-2.4.20-std/arch/sparc/kernel/time.c	2002-08-03 02:39:43.000000000 +0200
+++ linux-2.4.20-kfi/arch/sparc/kernel/time.c	2004-12-30 22:15:52.000000000 +0100
@@ -450,7 +450,7 @@
 	sbus_time_init();
 }
 
-extern __inline__ unsigned long do_gettimeoffset(void)
+static __inline__ unsigned long do_gettimeoffset(void)
 {
 	struct tasklet_struct *t;
 	unsigned long offset = 0;
diff -rbNu linux-2.4.20-std/arch/sparc/mm/srmmu.c linux-2.4.20-kfi/arch/sparc/mm/srmmu.c
--- linux-2.4.20-std/arch/sparc/mm/srmmu.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20-kfi/arch/sparc/mm/srmmu.c	2004-12-30 22:15:53.000000000 +0100
@@ -233,7 +233,7 @@
 { return __pte((pte_val(pte) & SRMMU_CHG_MASK) | pgprot_val(newprot)); }
 
 /* to find an entry in a top-level page table... */
-extern inline pgd_t *srmmu_pgd_offset(struct mm_struct * mm, unsigned long address)
+static inline pgd_t *srmmu_pgd_offset(struct mm_struct * mm, unsigned long address)
 { return mm->pgd + (address >> SRMMU_PGDIR_SHIFT); }
 
 /* Find an entry in the second-level page table.. */
diff -rbNu linux-2.4.20-std/arch/sparc64/kernel/ioctl32.c linux-2.4.20-kfi/arch/sparc64/kernel/ioctl32.c
--- linux-2.4.20-std/arch/sparc64/kernel/ioctl32.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20-kfi/arch/sparc64/kernel/ioctl32.c	2004-12-30 22:15:55.000000000 +0100
@@ -799,7 +799,7 @@
 
 extern struct socket *sockfd_lookup(int fd, int *err);
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/sparc64/kernel/sys_sparc32.c linux-2.4.20-kfi/arch/sparc64/kernel/sys_sparc32.c
--- linux-2.4.20-std/arch/sparc64/kernel/sys_sparc32.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20-kfi/arch/sparc64/kernel/sys_sparc32.c	2004-12-30 22:15:55.000000000 +0100
@@ -2259,7 +2259,7 @@
 extern struct socket *sockfd_lookup(int fd, int *err);
 
 /* XXX This as well... */
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/sparc64/solaris/socket.c linux-2.4.20-kfi/arch/sparc64/solaris/socket.c
--- linux-2.4.20-std/arch/sparc64/solaris/socket.c	2001-02-19 04:49:54.000000000 +0100
+++ linux-2.4.20-kfi/arch/sparc64/solaris/socket.c	2004-12-30 22:15:55.000000000 +0100
@@ -249,12 +249,12 @@
 					   about 80 for AX.25 */
 
 /* XXX These as well... */
-extern __inline__ struct socket *socki_lookup(struct inode *inode)
+static __inline__ struct socket *socki_lookup(struct inode *inode)
 {
 	return &inode->u.socket_i;
 }
 
-extern __inline__ struct socket *sockfd_lookup(int fd, int *err)
+static __inline__ struct socket *sockfd_lookup(int fd, int *err)
 {
 	struct file *file;
 	struct inode *inode;
@@ -274,7 +274,7 @@
 	return socki_lookup(inode);
 }
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/arch/x86_64/ia32/ia32_ioctl.c linux-2.4.20-kfi/arch/x86_64/ia32/ia32_ioctl.c
--- linux-2.4.20-std/arch/x86_64/ia32/ia32_ioctl.c	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20-kfi/arch/x86_64/ia32/ia32_ioctl.c	2004-12-30 22:15:50.000000000 +0100
@@ -716,7 +716,7 @@
 
 extern struct socket *sockfd_lookup(int fd, int *err);
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/drivers/char/Makefile linux-2.4.20-kfi/drivers/char/Makefile
--- linux-2.4.20-std/drivers/char/Makefile	2002-11-29 00:53:12.000000000 +0100
+++ linux-2.4.20-kfi/drivers/char/Makefile	2004-12-30 22:14:48.000000000 +0100
@@ -24,7 +24,7 @@
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-			au1000_gpio.o hp_psaux.o nvram.o
+			au1000_gpio.o hp_psaux.o nvram.o kfi.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
 
@@ -289,6 +289,9 @@
   obj-y += mwave/mwave.o
 endif
 
+obj-$(CONFIG_KFI) += kfi.o
+obj-$(CONFIG_KFI_STATIC_RUN) += kfistatic.o
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
@@ -308,3 +311,7 @@
 
 qtronixmap.c: qtronixmap.map
 	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+kfistatic.c: kfistatic.conf
+	$(TOPDIR)/scripts/mkkfirun.pl $< > $@
+
diff -rbNu linux-2.4.20-std/drivers/char/kfi.c linux-2.4.20-kfi/drivers/char/kfi.c
--- linux-2.4.20-std/drivers/char/kfi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-kfi/drivers/char/kfi.c	2004-12-30 22:14:48.000000000 +0100
@@ -0,0 +1,847 @@
+/*
+ *  drivers/char/kfi.c
+ *
+ *  Kernel Function Instrumentation
+ *
+ *  Copyright (C) 2002  MontaVista Software
+ *
+ *  Support for Function Instrumentation/Profiling feature of
+ *  GCC (-finstrument-functions).
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#include <linux/kfi.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+
+#define KFI_MODULE_NAME "KFI"
+#define PFX KFI_MODULE_NAME
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+#define KFI_MINOR 51
+
+#ifdef CONFIG_KFI_STATIC_RUN
+extern struct kfi_run kfi_run0;
+extern struct kfi_run* kfi_last_run;
+extern const int kfi_num_runs;
+static struct kfi_run* run_head = &kfi_run0;
+static struct kfi_run* run_curr = &kfi_run0;
+static struct kfi_run* run_tail = NULL;
+#else
+static struct kfi_run* run_head = NULL;
+static struct kfi_run* run_curr = NULL;
+static struct kfi_run* run_tail = NULL;
+#endif // CONFIG_KFI_STATIC_RUN
+
+static int next_run_id = 0;
+static int in_entry_exit = 0;
+
+//static spinlock_t kfi_lock = SPIN_LOCK_UNLOCKED;
+DECLARE_WAIT_QUEUE_HEAD(kfi_wait);
+
+#define CLOCK_SHIFT	3
+/* Would be nice to use probed clock freq (cpu_hz) here, but it
+ * isn't set early enough for some boot measurements.
+ * Set the following for your machine!
+ * Hint: for x86, boot once and look at /proc/cpuinfo */
+//#define CLOCK_FREQ 645206000ULL
+#define CLOCK_FREQ 2992332000ULL
+/* This weird scaling makes it possible to use shifts instead
+ * of divisions, for the conversion to microseconds */
+#define CLOCK_SCALE (((CLOCK_FREQ*1000000)/(1024*1024))>>CLOCK_SHIFT)
+
+static inline unsigned long kfi_readclock(void)
+{
+	unsigned long long ticks;
+
+	rdtscll(ticks);
+	return (unsigned long)((ticks>>CLOCK_SHIFT) & 0xffffffff);
+}
+
+static inline unsigned long kfi_clock_to_usecs(unsigned long clock)
+{
+	/* math to stay in 32-bit regs.  Try to avoid overflows and underflows */
+	if (clock<4096)
+		return (clock<<20)/CLOCK_SCALE;
+	if (clock<(4096<<5))
+		return (clock<<15)/(CLOCK_SCALE>>5);
+	if (clock<(4096<<10))
+		return (clock<<10)/(CLOCK_SCALE>>10);
+	if (clock<(4096<<15))
+		return (clock<<5)/(CLOCK_SCALE>>15);
+	else
+		return clock/(CLOCK_SCALE>>20);
+}
+
+static unsigned long usecs_since_boot = 0;
+static unsigned long last_machine_cycles = 0;
+
+static inline unsigned long __noinstrument
+update_usecs_since_boot(void)
+{
+	unsigned long machine_cycles, delta;
+
+	machine_cycles = kfi_readclock();
+	delta = machine_cycles - last_machine_cycles;
+	delta = kfi_clock_to_usecs(delta);
+
+	usecs_since_boot += delta;
+	
+	last_machine_cycles = machine_cycles;
+	return usecs_since_boot;
+}
+
+static inline struct kfi_entry* __noinstrument
+new_entry(struct kfi_run* run)
+{
+	struct kfi_entry* entry;
+	
+	if (run->next_entry >= run->num_entries)
+		return NULL;
+	
+	entry = &run->log[run->next_entry];
+	run->next_entry++;
+	return entry;
+}
+
+
+static inline int __noinstrument
+find_entry(struct kfi_run* run, void *this_fn, unsigned int pid)
+{
+	int i;
+
+	for (i = run->next_entry-1; i >= 0; i--) {
+		struct kfi_entry* entry = &run->log[i];
+		if (entry->va == this_fn &&
+		    entry->pid == pid &&
+		    entry->delta == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+
+static inline void __noinstrument
+free_entry(struct kfi_run* run, int loc)
+{
+	int i;
+	run->next_entry--;
+	for (i = loc; i < run->next_entry; i++)
+		run->log[i] = run->log[i+1];
+}
+
+
+static inline int __noinstrument
+in_func_list(struct kfi_filters* filters, void* func)
+{
+	int i;
+
+	for (i=0; i < filters->func_list_size; i++) {
+		if (filters->func_list[i] == func)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static inline int __noinstrument
+test_filters(struct kfi_filters* filters, void *this_fn)
+{
+	int in_intr;
+	
+	if (filters->func_list && !in_func_list(filters, this_fn)) {
+#ifdef KFI_DEBUG
+		filters->cnt.func_list++;
+#endif
+		return 1;
+	}
+
+	in_intr = in_interrupt();
+
+	if (filters->no_ints && in_intr) {
+#ifdef KFI_DEBUG
+		filters->cnt.no_ints++;
+#endif
+		return 1;
+	}
+
+	if (filters->only_ints && !in_intr) {
+#ifdef KFI_DEBUG
+		filters->cnt.only_ints++;
+#endif
+		return 1;
+	}
+	
+	return 0;
+}
+
+
+static inline void __noinstrument
+do_func_entry(struct kfi_run* run, void *this_fn, void *call_site)
+{
+	struct kfi_entry* entry;
+
+	if (!(entry = new_entry(run))) {
+		run->complete = 1;
+		run->stop_trigger.mark = update_usecs_since_boot();
+		run->stop_trigger.type = TRIGGER_LOG_FULL;
+		return;
+	}
+	
+	entry->va = this_fn;
+	entry->call_site = call_site;
+	entry->pid = in_interrupt() ? INTR_CONTEXT : current->pid;
+
+	entry->delta = 0;
+	entry->time = update_usecs_since_boot() - run->start_trigger.mark;
+}
+
+static inline void __noinstrument
+do_func_exit(struct kfi_run* run, void *this_fn, void *call_site)
+{
+	struct kfi_entry* entry;
+	unsigned long exittime;
+	unsigned long delta;
+	int entry_i;
+
+	if ((entry_i = find_entry(run, this_fn, in_interrupt() ?
+				  INTR_CONTEXT : current->pid)) < 0) {
+#ifdef KFI_DEBUG
+		run->notfound++;
+#endif
+		return;
+	}
+	
+	entry = &run->log[entry_i];
+
+	// calc delta
+	exittime = update_usecs_since_boot() - run->start_trigger.mark;
+	delta = exittime - entry->time;
+	
+	if ((run->filters.min_delta && delta < run->filters.min_delta) ||
+	    (run->filters.max_delta && delta > run->filters.max_delta)) {
+#ifdef KFI_DEBUG
+		run->filters.cnt.delta++;
+#endif
+		free_entry(run, entry_i);
+	} else {
+		entry->delta = delta;
+	}
+}
+
+
+static inline int __noinstrument test_trigger(struct kfi_run* run,
+					      int start_trigger,
+					      int func_entry,
+					      void* func_addr)
+{
+	unsigned long time, base_time;
+	int ret = 0;
+	struct kfi_trigger* t;
+		
+	t = start_trigger ? &run->start_trigger : &run->stop_trigger;
+
+	switch (t->type) {
+	case TRIGGER_TIME:
+		time = update_usecs_since_boot();
+		if (start_trigger) {
+			/* trigger start time based from boot */
+			base_time = 0;
+		} else {
+			/* trigger stop time based from start trigger time */
+			base_time = run->start_trigger.mark;
+		}
+		
+		if (time >= base_time + t->time) {
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	case TRIGGER_FUNC_ENTRY:
+		if (func_entry && func_addr == t->func_addr) {
+			time = update_usecs_since_boot();
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	case TRIGGER_FUNC_EXIT:
+		if (!func_entry && func_addr == t->func_addr) {
+			time = update_usecs_since_boot();
+			t->mark = time; // mark trigger time
+			ret = 1;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+
+static inline void __noinstrument
+func_entry_exit(void *this_fn, void *call_site, int func_entry)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	
+	local_irq_save(flags);
+	if (in_entry_exit) {
+		local_irq_restore(flags);
+		return;
+	}
+	in_entry_exit = 1;
+	
+	update_usecs_since_boot();
+	
+	run = run_curr;
+
+	if (!run || run->complete) {
+		goto entry_exit_byebye;
+	}
+	
+	if (!run->triggered) {
+		if (!(run->triggered = test_trigger(run, 1,
+						    func_entry,
+						    this_fn))) {
+			goto entry_exit_byebye;
+		}
+	}
+
+	if (!test_filters(&run->filters, this_fn)) {
+		if (func_entry)
+			do_func_entry(run, this_fn, call_site);
+		else
+			do_func_exit(run, this_fn, call_site);
+	}
+
+	if (!run->complete) {
+		run->complete = test_trigger(run, 0,
+					     func_entry,
+					     this_fn);
+	}
+
+	if (run->complete) {
+		if (waitqueue_active(&kfi_wait))
+			wake_up_interruptible(&kfi_wait);
+		if (run->next != NULL)
+			run_curr = run->next;
+	}
+	
+ entry_exit_byebye:
+	in_entry_exit = 0;
+	local_irq_restore(flags);
+}
+
+
+void __noinstrument __cyg_profile_func_enter (void *this_fn, void *call_site)
+{
+	func_entry_exit(this_fn, call_site, 1);
+}
+
+void __noinstrument __cyg_profile_func_exit (void *this_fn, void *call_site)
+{
+	func_entry_exit(this_fn, call_site, 0);
+}
+
+
+#define dump_str(buf, len, fmt, arg...) \
+    if (buf) len += sprintf(buf + len, fmt, ## arg); \
+    else len += printk(KERN_EMERG fmt, ## arg)
+
+
+static struct kfi_run* __noinstrument find_run(int id)
+{
+	struct kfi_run* run = run_head;
+
+	while (run && run->id != id)
+		run = run->next;
+
+	return run;
+}
+
+static int __noinstrument
+print_trigger(char* buf, int len, struct kfi_trigger* t, int start_trigger)
+{
+	char trigbuf[80];
+	
+	switch (t->type) {
+	case TRIGGER_DEV:
+		sprintf(trigbuf, "system call\n");
+		break;
+	case TRIGGER_TIME:
+		sprintf(trigbuf, "time at %lu usec from %s\n",
+		       t->time, start_trigger ? "boot" : "start trigger");
+		break;
+	case TRIGGER_FUNC_ENTRY:
+		sprintf(trigbuf, "entry to function 0x%08lx\n",
+			(unsigned long)t->func_addr);
+		break;
+	case TRIGGER_FUNC_EXIT:
+		sprintf(trigbuf, "exit from function 0x%08lx\n",
+			(unsigned long)t->func_addr);
+		break;
+	case TRIGGER_LOG_FULL:
+		sprintf(trigbuf, "log full\n");
+		break;
+	default:
+		sprintf(trigbuf, "?\n");
+		break;
+	}
+
+	dump_str(buf, len, "Logging %s at %lu usec by %s",
+		 (start_trigger ? "started" : "stopped"),
+		 t->mark, trigbuf);
+
+	return len;
+}
+
+int __noinstrument kfi_dump_log(char* buf)
+{
+	int i, len = 0;
+	struct kfi_run* run = run_curr;
+	struct kfi_filters* filters = &run->filters;
+
+	if (!run) {
+		dump_str(buf, len, "\nNo logging run registered\n");
+		return len;
+	}
+
+	if (!run->triggered) {
+		dump_str(buf, len, "\nLogging not yet triggered\n");
+		return len;
+	}
+
+	if (!run->complete) {
+		dump_str(buf, len, "\nLogging is running\n");
+		return len;
+	}
+
+	dump_str(buf, len, "\nKernel Instrumentation Run ID %d\n\n",
+		 run->id);
+	
+	dump_str(buf, len, "Filters:\n");
+	if (filters->func_list_size) {
+		dump_str(buf, len, "\t%d-entry function list\n",
+			 filters->func_list_size);
+	}
+	if (filters->min_delta) {
+		dump_str(buf, len, "\t%ld usecs minimum execution time\n",
+			 filters->min_delta);
+	}
+	if (filters->max_delta) {
+		dump_str(buf, len, "\t%ld usecs maximum execution time\n",
+			 filters->max_delta);
+	}
+	if (filters->no_ints) {
+		dump_str(buf, len, "\tno functions in interrupt context\n");
+	}
+	if (filters->only_ints) {
+		dump_str(buf, len,
+			 "\tno functions NOT in interrupt context\n");
+	}
+	if (filters->func_list) {
+		dump_str(buf, len, "\tfunction list\n");
+	}
+	
+#ifdef KFI_DEBUG
+	dump_str(buf, len, "\nFilter Counters:\n");
+
+	if (filters->min_delta || filters->max_delta) {
+		dump_str(buf, len, "\nExecution time filter count = %d\n",
+			 filters->cnt.delta);
+	}
+	if (filters->no_ints) {
+		dump_str(buf, len,
+			 "No Interrupt functions filter count = %d\n",
+			 filters->cnt.no_ints);
+	}
+	if (filters->only_ints) {
+		dump_str(buf, len,
+			 "Only Interrupt functions filter count = %d\n",
+			 filters->cnt.only_ints);
+	}
+	if (filters->func_list_size) {
+		dump_str(buf, len, "Function List filter count = %d\n",
+			 filters->cnt.func_list);
+	}
+	dump_str(buf, len, "Total entries filtered = %d\n",
+		 filters->cnt.delta +
+		 filters->cnt.no_ints +
+		 filters->cnt.only_ints +
+		 filters->cnt.func_list);
+	dump_str(buf, len, "Entries not found = %d\n", run->notfound);
+#endif	
+	dump_str(buf, len, "\nNumber of entries after filters = %d\n\n",
+		 run->next_entry);
+
+	len += print_trigger(buf, len, &run->start_trigger, 1);
+	len += print_trigger(buf, len, &run->stop_trigger, 0);
+	
+	/* print out header */
+	dump_str(buf, len, "\n");
+	dump_str(buf, len,
+		 " Entry      Delta       PID      Function    Caller\n");
+	dump_str(buf, len,
+		 "--------   --------   --------   --------   --------\n");
+
+	for (i=0; i < run->next_entry; i++) {
+		dump_str(buf, len, "%8lu   %8lu   %7d%s   %08x   %08x\n",
+			 run->log[i].time,
+			 run->log[i].delta,
+			 run->log[i].pid,
+			 (run->log[i].pid == INTR_CONTEXT) ? "i" : " ",
+			 (unsigned int)run->log[i].va,
+			 (unsigned int)run->log[i].call_site);
+	}
+
+	return len;
+}
+
+int __noinstrument kfi_read_proc(char *buf, char **start, off_t fpos,
+				 int length, int *eof, void *data)
+{
+	int len = kfi_dump_log(buf);
+	
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+static void __noinstrument kfi_reset(void)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	
+#ifdef CONFIG_KFI_STATIC_RUN
+	run = kfi_last_run->next;
+#else
+	run = run_head;
+#endif
+
+	local_irq_save(flags);
+	if (run_curr)
+		run_curr->complete = 1;
+	local_irq_restore(flags);
+
+	while (run) {
+		struct kfi_run* tmp = run;
+		kfree(run->log);
+		if (run->filters.func_list)
+			kfree(run->filters.func_list);
+		run = run->next;
+		kfree(tmp);
+	}
+
+	next_run_id = 0;
+	run_head = run_tail = run_curr = NULL;
+}
+
+
+static int __noinstrument kfi_ioctl(struct inode *inode,
+				    struct file *file,
+				    unsigned int cmd,
+				    unsigned long arg)
+{
+	unsigned long flags;
+	struct kfi_run* run;
+	struct kfi_run urun;
+	struct kfi_entry* ulog;
+	void** ufunc_list;
+	int ufunc_list_size;
+	
+	switch (cmd) {
+	case KFI_RESET:
+		kfi_reset();
+		break;
+	case KFI_NEW_RUN:
+		if (verify_area(VERIFY_READ, (void *)arg,
+				sizeof(struct kfi_run)) ||
+		    verify_area(VERIFY_WRITE, (void *)arg,
+				sizeof(struct kfi_run)))
+			return -EFAULT;
+		if ((run = (struct kfi_run*)kmalloc(sizeof(struct kfi_run),
+						    GFP_KERNEL)) == NULL)
+			return -ENOMEM;
+		copy_from_user(&urun, (struct kfi_run*)arg,
+			       sizeof(struct kfi_run));
+		if (urun.num_entries > MAX_RUN_LOG_ENTRIES) {
+			kfree(run);
+			return -EINVAL;
+		}
+		*run = urun;
+		run->id = next_run_id++;
+		run->triggered = run->complete = 0;
+		run->next_entry = 0;
+#ifdef KFI_DEBUG
+		run->notfound = 0;
+		memset(&run->filters.cnt, 0, sizeof(run->filters.cnt));
+#endif
+		run->next = NULL;
+		urun = *run;
+		run->log = (struct kfi_entry*)
+			kmalloc(sizeof(struct kfi_entry) * run->num_entries,
+				GFP_KERNEL);
+		if (run->log == NULL) {
+			kfree(run);
+			return -ENOMEM;
+		}
+		memset(run->log, 0,
+		       sizeof(struct kfi_entry) * run->num_entries);
+		
+		if (urun.filters.func_list) {
+			int size;
+			if (urun.filters.func_list_size >
+			    MAX_FUNC_LIST_ENTRIES) {
+				kfree(run->log);
+				kfree(run);
+				return -EINVAL;
+			}
+			size = urun.filters.func_list_size * sizeof(void*);
+			if (verify_area(VERIFY_READ,
+					(void *)urun.filters.func_list,
+					size)) {
+				kfree(run->log);
+				kfree(run);
+				return -EFAULT;
+			}
+			run->filters.func_list = (void**)kmalloc(size,
+								 GFP_KERNEL);
+			if (run->filters.func_list == NULL) {
+				kfree(run->log);
+				kfree(run);
+				return -ENOMEM;
+			}
+			copy_from_user(run->filters.func_list,
+				       urun.filters.func_list,
+				       size);
+		}
+	       
+		/* new run is ready, return it to user */
+		copy_to_user((struct kfi_run*)arg, &urun,
+			     sizeof(struct kfi_run));
+		/* tack it on */
+		local_irq_save(flags);
+		if (!run_tail) {
+			run_head = run_tail = run_curr = run;
+		} else {
+			if (run_curr == run_tail && run_curr->complete)
+				run_curr = run;
+			run_tail->next = run;
+			run_tail = run;
+		}
+		local_irq_restore(flags);
+		break;
+	case KFI_START:
+		local_irq_save(flags);
+		run = run_curr;
+		if (!run || run->complete || run->triggered) {
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+		run->triggered = 1;
+		run->start_trigger.mark = update_usecs_since_boot();
+		run->start_trigger.type = TRIGGER_DEV;
+		local_irq_restore(flags);
+		if (put_user(run->id, (int *)arg))
+			return -EFAULT;
+		break;
+	case KFI_STOP:
+		local_irq_save(flags);
+		run = run_curr;
+		if (!run || run->complete) {
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+		run->complete = 1;
+		run->stop_trigger.mark = update_usecs_since_boot();
+		run->stop_trigger.type = TRIGGER_DEV;
+		if (run->next != NULL)
+			run_curr = run->next;
+		local_irq_restore(flags);
+		if (waitqueue_active(&kfi_wait))
+			wake_up_interruptible(&kfi_wait);
+		if (put_user(run->id, (int *)arg))
+			return -EFAULT;
+		break;
+	case KFI_READ:
+	case KFI_READ_CURR:
+		if (verify_area(VERIFY_READ, (void *)arg,
+				sizeof(struct kfi_run)) ||
+		    verify_area(VERIFY_WRITE, (void *)arg,
+				sizeof(struct kfi_run)))
+			return -EFAULT;
+		copy_from_user(&urun, (struct kfi_run*)arg,
+			       sizeof(struct kfi_run));
+
+		local_irq_save(flags);
+
+		run = (cmd == KFI_READ_CURR) ? run_curr : find_run(urun.id);
+		if (!run) {
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+
+		if (urun.log != NULL) {
+			if (urun.num_entries < run->num_entries) {
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+			
+			if (!run->complete) {
+				local_irq_restore(flags);
+				if (file->f_flags & O_NONBLOCK)
+					return -EAGAIN;
+				while (!run->complete) {
+					interruptible_sleep_on(&kfi_wait);
+					if (signal_pending(current))
+						return -ERESTARTSYS;
+				}
+				local_irq_save(flags);
+			}
+		}
+
+		ufunc_list_size = urun.filters.func_list_size;
+
+		// save user pointers
+		ulog = urun.log;
+		ufunc_list = urun.filters.func_list;
+		
+		urun = *run; // copy run
+
+		// restore user pointers
+		urun.log = ulog;
+		urun.filters.func_list = ufunc_list;
+		urun.next = NULL;
+
+		local_irq_restore(flags);
+
+		copy_to_user((void*)arg, &urun, sizeof(struct kfi_run));
+
+		if (urun.log != NULL) {
+			int size = run->next_entry * sizeof(struct kfi_entry);
+			if (verify_area(VERIFY_WRITE, (void*)urun.log, size))
+				return -EFAULT;
+			copy_to_user((void*)urun.log, run->log, size);
+		}
+
+		if (ufunc_list != NULL && run->filters.func_list != NULL) {
+			int size;
+			if (ufunc_list_size < run->filters.func_list_size)
+				return -EINVAL;
+			size = run->filters.func_list_size * sizeof(void*);
+			if (verify_area(VERIFY_WRITE, ufunc_list, size))
+				return -EFAULT;
+			copy_to_user(ufunc_list, run->filters.func_list, size);
+		}
+		break;
+	case KFI_READ_TIMER:
+		if (put_user(update_usecs_since_boot(),
+			     (unsigned long *)arg))
+			return -EFAULT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int __noinstrument
+kfi_poll(struct file * filp, poll_table * wait)
+{
+        poll_wait(filp, &kfi_wait, wait);
+        if (run_curr && run_curr->complete)
+                return POLLIN | POLLRDNORM;
+        return 0;
+}
+
+int __noinstrument kfi_open(struct inode *minode, struct file *mfile)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+int __noinstrument kfi_release(struct inode *minode, struct file *mfile)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static loff_t __noinstrument kfi_llseek(struct file *mfile,
+					loff_t offset, int origint)
+{
+	return -ESPIPE;
+}
+
+static struct file_operations kfi_fops = {
+	owner:		THIS_MODULE,
+	llseek:		kfi_llseek,
+	poll:           kfi_poll,
+	ioctl:		kfi_ioctl,
+	open:		kfi_open,
+	release:	kfi_release,
+};
+
+static struct miscdevice kfi_miscdev = {
+	KFI_MINOR,
+	"kfi",
+	&kfi_fops
+};
+
+static int __init __noinstrument kfi_init(void)
+{
+	int ret = misc_register(&kfi_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		return ret;
+	}
+
+#ifdef CONFIG_KFI_STATIC_RUN
+	run_tail = kfi_last_run;
+	next_run_id = kfi_num_runs;
+#endif
+
+	create_proc_read_entry("kfi", 0, NULL,
+			       kfi_read_proc, NULL);
+	return 0;
+}
+
+static void __exit __noinstrument kfi_exit(void)
+{
+        remove_proc_entry("kfi", NULL);
+        misc_deregister(&kfi_miscdev);
+}
+
+
+module_init(kfi_init);
+module_exit(kfi_exit);
+
+EXPORT_SYMBOL(__cyg_profile_func_enter);
+EXPORT_SYMBOL(__cyg_profile_func_exit);
+
diff -rbNu linux-2.4.20-std/drivers/char/kfistatic.conf linux-2.4.20-kfi/drivers/char/kfistatic.conf
--- linux-2.4.20-std/drivers/char/kfistatic.conf	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-kfi/drivers/char/kfistatic.conf	2004-12-30 22:14:48.000000000 +0100
@@ -0,0 +1,6 @@
+begin
+   trigger start entry start_kernel
+   trigger stop entry to_userspace
+   filter time 500,0
+#   filter noint
+end
diff -rbNu linux-2.4.20-std/drivers/isdn/sc/command.c linux-2.4.20-kfi/drivers/isdn/sc/command.c
--- linux-2.4.20-std/drivers/isdn/sc/command.c	2001-12-21 18:41:54.000000000 +0100
+++ linux-2.4.20-kfi/drivers/isdn/sc/command.c	2004-12-30 22:15:40.000000000 +0100
@@ -51,7 +51,7 @@
                 RspMessage *, int);
 extern int sendmessage(int, unsigned int, unsigned int, unsigned int,
                 unsigned int, unsigned int, unsigned int, unsigned int *);
-extern inline void pullphone(char *, char *);
+extern void pullphone(char *, char *);
 
 #ifdef DEBUG
 /*
diff -rbNu linux-2.4.20-std/drivers/message/fusion/linux_compat.h linux-2.4.20-kfi/drivers/message/fusion/linux_compat.h
--- linux-2.4.20-std/drivers/message/fusion/linux_compat.h	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.20-kfi/drivers/message/fusion/linux_compat.h	2004-12-30 22:15:50.000000000 +0100
@@ -75,11 +75,11 @@
 typedef void (*__cleanup_module_func_t)(void);
 #define module_init(x) \
 	int init_module(void) __attribute__((alias(#x))); \
-	extern inline __init_module_func_t __init_module_inline(void) \
+	static inline __init_module_func_t __init_module_inline(void) \
 	{ return x; }
 #define module_exit(x) \
 	void cleanup_module(void) __attribute__((alias(#x))); \
-	extern inline __cleanup_module_func_t __cleanup_module_inline(void) \
+	static inline __cleanup_module_func_t __cleanup_module_inline(void) \
 	{ return x; }
 
 #else
diff -rbNu linux-2.4.20-std/drivers/net/aironet4500.h linux-2.4.20-kfi/drivers/net/aironet4500.h
--- linux-2.4.20-std/drivers/net/aironet4500.h	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.20-kfi/drivers/net/aironet4500.h	2004-12-30 22:15:26.000000000 +0100
@@ -450,7 +450,7 @@
 };
 
 
-extern  __inline__ void
+static  __inline__ void
 awc_fid_queue_init(struct awc_fid_queue * queue){
 
 	unsigned long flags;
diff -rbNu linux-2.4.20-std/drivers/net/au1000_eth.c linux-2.4.20-kfi/drivers/net/au1000_eth.c
--- linux-2.4.20-std/drivers/net/au1000_eth.c	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.20-kfi/drivers/net/au1000_eth.c	2004-12-30 22:15:25.000000000 +0100
@@ -81,8 +81,8 @@
 // externs
 extern  void ack_rise_edge_irq(unsigned int);
 extern int get_ethernet_addr(char *ethernet_addr);
-extern inline void str2eaddr(unsigned char *ea, unsigned char *str);
-extern inline unsigned char str2hexnum(unsigned char c);
+extern void str2eaddr(unsigned char *ea, unsigned char *str);
+extern unsigned char str2hexnum(unsigned char c);
 extern char * __init prom_getcmdline(void);
 
 /*
diff -rbNu linux-2.4.20-std/drivers/net/hamradio/soundmodem/sm.h linux-2.4.20-kfi/drivers/net/hamradio/soundmodem/sm.h
--- linux-2.4.20-std/drivers/net/hamradio/soundmodem/sm.h	2002-08-03 02:39:44.000000000 +0200
+++ linux-2.4.20-kfi/drivers/net/hamradio/soundmodem/sm.h	2004-12-30 22:15:27.000000000 +0100
@@ -363,7 +363,7 @@
 
 /* --------------------------------------------------------------------- */
 
-extern void inline sm_int_freq(struct sm_state *sm)
+static void inline sm_int_freq(struct sm_state *sm)
 {
 #ifdef SM_DEBUG
 	unsigned long cur_jiffies = jiffies;
diff -rbNu linux-2.4.20-std/drivers/net/hamradio/soundmodem/sm_wss.c linux-2.4.20-kfi/drivers/net/hamradio/soundmodem/sm_wss.c
--- linux-2.4.20-std/drivers/net/hamradio/soundmodem/sm_wss.c	2002-11-29 00:53:13.000000000 +0100
+++ linux-2.4.20-kfi/drivers/net/hamradio/soundmodem/sm_wss.c	2004-12-30 22:15:27.000000000 +0100
@@ -100,7 +100,7 @@
 
 /* --------------------------------------------------------------------- */
 
-extern void inline wss_ack_int(struct net_device *dev)
+static void inline wss_ack_int(struct net_device *dev)
 {
 	outb(0, WSS_CODEC_STATUS(dev->base_addr));
 }
diff -rbNu linux-2.4.20-std/drivers/scsi/NCR53C9x.h linux-2.4.20-kfi/drivers/scsi/NCR53C9x.h
--- linux-2.4.20-std/drivers/scsi/NCR53C9x.h	2001-09-14 23:40:00.000000000 +0200
+++ linux-2.4.20-kfi/drivers/scsi/NCR53C9x.h	2004-12-30 22:15:36.000000000 +0100
@@ -639,7 +639,7 @@
 
 
 /* External functions */
-extern inline void esp_cmd(struct NCR_ESP *esp, struct ESP_regs *eregs,
+extern void esp_cmd(struct NCR_ESP *esp, struct ESP_regs *eregs,
 			   unchar cmd);
 extern struct NCR_ESP *esp_allocate(Scsi_Host_Template *, void *);
 extern void esp_deallocate(struct NCR_ESP *);
diff -rbNu linux-2.4.20-std/drivers/scsi/mac_esp.c linux-2.4.20-kfi/drivers/scsi/mac_esp.c
--- linux-2.4.20-std/drivers/scsi/mac_esp.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.20-kfi/drivers/scsi/mac_esp.c	2004-12-30 22:15:34.000000000 +0100
@@ -44,7 +44,7 @@
 #define mac_turnon_irq(x)	mac_enable_irq(x)
 #define mac_turnoff_irq(x)	mac_disable_irq(x)
 
-extern inline void esp_handle(struct NCR_ESP *esp);
+extern void esp_handle(struct NCR_ESP *esp);
 extern void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs);
 
 static int  dma_bytes_sent(struct NCR_ESP * esp, int fifo_count);
diff -rbNu linux-2.4.20-std/drivers/sound/au1000.c linux-2.4.20-kfi/drivers/sound/au1000.c
--- linux-2.4.20-std/drivers/sound/au1000.c	2002-11-29 00:53:14.000000000 +0100
+++ linux-2.4.20-kfi/drivers/sound/au1000.c	2004-12-30 22:15:38.000000000 +0100
@@ -595,7 +595,7 @@
 #define DMABUF_DEFAULTORDER (17-PAGE_SHIFT)
 #define DMABUF_MINORDER 1
 
-extern inline void dealloc_dmabuf(struct au1000_state *s, struct dmabuf *db)
+static inline void dealloc_dmabuf(struct au1000_state *s, struct dmabuf *db)
 {
 	struct page    *page, *pend;
 
@@ -694,14 +694,14 @@
 	return 0;
 }
 
-extern inline int prog_dmabuf_adc(struct au1000_state *s)
+static inline int prog_dmabuf_adc(struct au1000_state *s)
 {
 	stop_adc(s);
 	return prog_dmabuf(s, &s->dma_adc);
 
 }
 
-extern inline int prog_dmabuf_dac(struct au1000_state *s)
+static inline int prog_dmabuf_dac(struct au1000_state *s)
 {
 	stop_dac(s);
 	return prog_dmabuf(s, &s->dma_dac);
diff -rbNu linux-2.4.20-std/drivers/video/riva/fbdev.c linux-2.4.20-kfi/drivers/video/riva/fbdev.c
--- linux-2.4.20-std/drivers/video/riva/fbdev.c	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/drivers/video/riva/fbdev.c	2004-12-30 22:15:43.000000000 +0100
@@ -110,7 +110,7 @@
 static void rivafb_blank(int blank, struct fb_info *info);
 
 extern void riva_setup_accel(struct rivafb_info *rinfo);
-extern inline void wait_for_idle(struct rivafb_info *rinfo);
+extern void wait_for_idle(struct rivafb_info *rinfo);
 
 
 
diff -rbNu linux-2.4.20-std/fs/adfs/adfs.h linux-2.4.20-kfi/fs/adfs/adfs.h
--- linux-2.4.20-std/fs/adfs/adfs.h	2000-09-19 00:14:06.000000000 +0200
+++ linux-2.4.20-kfi/fs/adfs/adfs.h	2004-12-30 22:15:11.000000000 +0100
@@ -107,7 +107,7 @@
 extern struct inode_operations adfs_file_inode_operations;
 extern struct file_operations adfs_file_operations;
 
-extern inline __u32 signed_asl(__u32 val, signed int shift)
+static inline __u32 signed_asl(__u32 val, signed int shift)
 {
 	if (shift >= 0)
 		val <<= shift;
@@ -122,7 +122,7 @@
  *
  * The root directory ID should always be looked up in the map [3.4]
  */
-extern inline int
+static inline int
 __adfs_block_map(struct super_block *sb, unsigned int object_id,
 		 unsigned int block)
 {
diff -rbNu linux-2.4.20-std/fs/devpts/devpts_i.h linux-2.4.20-kfi/fs/devpts/devpts_i.h
--- linux-2.4.20-std/fs/devpts/devpts_i.h	2004-12-30 17:34:02.000000000 +0100
+++ linux-2.4.20-kfi/fs/devpts/devpts_i.h	2004-12-31 14:49:48.000000000 +0100
@@ -32,7 +32,7 @@
 #define DEVPTS_SUPER_MAGIC 0x1cd1
 #define DEVPTS_SBI_MAGIC   0x01da1d02
 
-extern inline struct devpts_sb_info *SBI(struct super_block *sb)
+static inline struct devpts_sb_info *SBI(struct super_block *sb)
 {
 	return (struct devpts_sb_info *)(sb->u.generic_sbp);
 }
diff -rbNu linux-2.4.20-std/fs/freevxfs/vxfs_extern.h linux-2.4.20-kfi/fs/freevxfs/vxfs_extern.h
--- linux-2.4.20-std/fs/freevxfs/vxfs_extern.h	2002-02-25 20:38:08.000000000 +0100
+++ linux-2.4.20-kfi/fs/freevxfs/vxfs_extern.h	2004-12-30 22:15:12.000000000 +0100
@@ -72,7 +72,7 @@
 
 /* vxfs_subr.c */
 extern struct page *		vxfs_get_page(struct address_space *, u_long);
-extern __inline__ void		vxfs_put_page(struct page *);
+extern void		vxfs_put_page(struct page *);
 extern struct buffer_head *	vxfs_bread(struct inode *, int);
 
 #endif /* _VXFS_EXTERN_H_ */
diff -rbNu linux-2.4.20-std/fs/hfs/hfs_btree.h linux-2.4.20-kfi/fs/hfs/hfs_btree.h
--- linux-2.4.20-std/fs/hfs/hfs_btree.h	2001-02-13 23:13:45.000000000 +0100
+++ linux-2.4.20-kfi/fs/hfs/hfs_btree.h	2004-12-30 22:15:11.000000000 +0100
@@ -213,48 +213,48 @@
 
 /* Convert a (struct hfs_bnode *) and an index to the value of the
    n-th offset in the bnode (N >= 1) to the offset */
-extern inline hfs_u16 bnode_offset(const struct hfs_bnode *bnode, int n)
+static inline hfs_u16 bnode_offset(const struct hfs_bnode *bnode, int n)
 { return hfs_get_hs(RECTBL(bnode,n)); }
 
 /* Convert a (struct hfs_bnode *) and an index to the size of the
    n-th record in the bnode (N >= 1) */
-extern inline hfs_u16 bnode_rsize(const struct hfs_bnode *bnode, int n)
+static inline hfs_u16 bnode_rsize(const struct hfs_bnode *bnode, int n)
 { return bnode_offset(bnode, n+1) - bnode_offset(bnode, n); }
 
 /* Convert a (struct hfs_bnode *) to the offset of the empty part */
-extern inline hfs_u16 bnode_end(const struct hfs_bnode *bnode)
+static inline hfs_u16 bnode_end(const struct hfs_bnode *bnode)
 { return bnode_offset(bnode, bnode->ndNRecs + 1); }
 
 /* Convert a (struct hfs_bnode *) to the number of free bytes it contains */
-extern inline hfs_u16 bnode_freespace(const struct hfs_bnode *bnode)
+static inline hfs_u16 bnode_freespace(const struct hfs_bnode *bnode)
 { return HFS_SECTOR_SIZE - bnode_end(bnode)
 	  - (bnode->ndNRecs + 1)*sizeof(hfs_u16); }
 
 /* Convert a (struct hfs_bnode *) X and an index N to
    the address of the record N in the bnode (N >= 1) */
-extern inline void *bnode_datastart(const struct hfs_bnode *bnode)
+static inline void *bnode_datastart(const struct hfs_bnode *bnode)
 { return (void *)(hfs_buffer_data(bnode->buf)+sizeof(struct NodeDescriptor)); }
 
 /* Convert a (struct hfs_bnode *) to the address of the empty part */
-extern inline void *bnode_dataend(const struct hfs_bnode *bnode)
+static inline void *bnode_dataend(const struct hfs_bnode *bnode)
 { return (void *)(hfs_buffer_data(bnode->buf) + bnode_end(bnode)); }
 
 /* Convert various pointers to address of record's key */
-extern inline void *bnode_key(const struct hfs_bnode *bnode, int n)
+static inline void *bnode_key(const struct hfs_bnode *bnode, int n)
 { return (void *)(hfs_buffer_data(bnode->buf) + bnode_offset(bnode, n)); }
-extern inline void *belem_key(const struct hfs_belem *elem)
+static inline void *belem_key(const struct hfs_belem *elem)
 { return bnode_key(elem->bnr.bn, elem->record); }
-extern inline void *brec_key(const struct hfs_brec *brec)
+static inline void *brec_key(const struct hfs_brec *brec)
 { return belem_key(brec->bottom); }
 
 /* Convert various pointers to the address of a record */
-extern inline void *bkey_record(const struct hfs_bkey *key)
+static inline void *bkey_record(const struct hfs_bkey *key)
 { return (void *)key + ROUND(key->KeyLen + 1); }
-extern inline void *bnode_record(const struct hfs_bnode *bnode, int n)
+static inline void *bnode_record(const struct hfs_bnode *bnode, int n)
 { return bkey_record(bnode_key(bnode, n)); }
-extern inline void *belem_record(const struct hfs_belem *elem)
+static inline void *belem_record(const struct hfs_belem *elem)
 { return bkey_record(belem_key(elem)); }
-extern inline void *brec_record(const struct hfs_brec *brec)
+static inline void *brec_record(const struct hfs_brec *brec)
 { return bkey_record(brec_key(brec)); }
 
 /*================ Function Prototypes ================*/
diff -rbNu linux-2.4.20-std/fs/hpfs/hpfs_fn.h linux-2.4.20-kfi/fs/hpfs/hpfs_fn.h
--- linux-2.4.20-std/fs/hpfs/hpfs_fn.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/fs/hpfs/hpfs_fn.h	2004-12-30 22:15:10.000000000 +0100
@@ -61,13 +61,13 @@
  * local time (HPFS) to GMT (Unix)
  */
 
-extern inline time_t local_to_gmt(struct super_block *s, time_t t)
+static inline time_t local_to_gmt(struct super_block *s, time_t t)
 {
 	extern struct timezone sys_tz;
 	return t + sys_tz.tz_minuteswest * 60 + s->s_hpfs_timeshift;
 }
 
-extern inline time_t gmt_to_local(struct super_block *s, time_t t)
+static inline time_t gmt_to_local(struct super_block *s, time_t t)
 {
 	extern struct timezone sys_tz;
 	return t - sys_tz.tz_minuteswest * 60 - s->s_hpfs_timeshift;
@@ -90,7 +90,7 @@
 
 /* The b-tree down pointer from a dir entry */
 
-extern inline dnode_secno de_down_pointer (struct hpfs_dirent *de)
+static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)
 {
   CHKCOND(de->down,("HPFS: de_down_pointer: !de->down\n"));
   return *(dnode_secno *) ((void *) de + de->length - 4);
@@ -98,14 +98,14 @@
 
 /* The first dir entry in a dnode */
 
-extern inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)
+static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)
 {
   return (void *) dnode->dirent;
 }
 
 /* The end+1 of the dir entries */
 
-extern inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)
+static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)
 {
   CHKCOND(dnode->first_free>=0x14 && dnode->first_free<=0xa00,("HPFS: dnode_end_de: dnode->first_free = %d\n",(int)dnode->first_free));
   return (void *) dnode + dnode->first_free;
@@ -113,48 +113,48 @@
 
 /* The dir entry after dir entry de */
 
-extern inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)
+static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)
 {
   CHKCOND(de->length>=0x20 && de->length<0x800,("HPFS: de_next_de: de->length = %d\n",(int)de->length));
   return (void *) de + de->length;
 }
 
-extern inline struct extended_attribute *fnode_ea(struct fnode *fnode)
+static inline struct extended_attribute *fnode_ea(struct fnode *fnode)
 {
 	return (struct extended_attribute *)((char *)fnode + fnode->ea_offs);
 }
 
-extern inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)
+static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)
 {
 	return (struct extended_attribute *)((char *)fnode + fnode->ea_offs + fnode->ea_size_s);
 }
 
-extern inline struct extended_attribute *next_ea(struct extended_attribute *ea)
+static inline struct extended_attribute *next_ea(struct extended_attribute *ea)
 {
 	return (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea->valuelen);
 }
 
-extern inline secno ea_sec(struct extended_attribute *ea)
+static inline secno ea_sec(struct extended_attribute *ea)
 {
 	return *(secno *)((char *)ea + 9 + ea->namelen);
 }
 
-extern inline secno ea_len(struct extended_attribute *ea)
+static inline secno ea_len(struct extended_attribute *ea)
 {
 	return *(secno *)((char *)ea + 5 + ea->namelen);
 }
 
-extern inline char *ea_data(struct extended_attribute *ea)
+static inline char *ea_data(struct extended_attribute *ea)
 {
 	return (char *)((char *)ea + 5 + ea->namelen);
 }
 
-extern inline unsigned de_size(int namelen, secno down_ptr)
+static inline unsigned de_size(int namelen, secno down_ptr)
 {
 	return ((0x1f + namelen + 3) & ~3) + (down_ptr ? 4 : 0);
 }
 
-extern inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)
+static inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)
 {
 	int a;
 	int n;
@@ -166,7 +166,7 @@
 	dst->not_8x3 = n;
 }
 
-extern inline unsigned tstbits(unsigned *bmp, unsigned b, unsigned n)
+static inline unsigned tstbits(unsigned *bmp, unsigned b, unsigned n)
 {
 	int i;
 	if ((b >= 0x4000) || (b + n - 1 >= 0x4000)) return n;
diff -rbNu linux-2.4.20-std/fs/intermezzo/ext_attr.c linux-2.4.20-kfi/fs/intermezzo/ext_attr.c
--- linux-2.4.20-std/fs/intermezzo/ext_attr.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/fs/intermezzo/ext_attr.c	2004-12-30 22:15:12.000000000 +0100
@@ -52,7 +52,7 @@
 #ifdef CONFIG_FS_EXT_ATTR
 #include <linux/ext_attr.h>
 
-extern inline void presto_debug_fail_blkdev(struct presto_file_set *fset,
+extern void presto_debug_fail_blkdev(struct presto_file_set *fset,
                                             unsigned long value);
 
 
diff -rbNu linux-2.4.20-std/fs/udf/balloc.c linux-2.4.20-kfi/fs/udf/balloc.c
--- linux-2.4.20-std/fs/udf/balloc.c	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/fs/udf/balloc.c	2004-12-30 22:15:12.000000000 +0100
@@ -46,7 +46,7 @@
 #define uint(x) xuint(x)
 #define xuint(x) uint ## x ## _t
 
-extern inline int find_next_one_bit (void * addr, int size, int offset)
+static inline int find_next_one_bit (void * addr, int size, int offset)
 {
 	uintBPL_t * p = ((uintBPL_t *) addr) + (offset / BITS_PER_LONG);
 	uintBPL_t result = offset & ~(BITS_PER_LONG-1);
diff -rbNu linux-2.4.20-std/include/asm-alpha/mmu_context.h linux-2.4.20-kfi/include/asm-alpha/mmu_context.h
--- linux-2.4.20-std/include/asm-alpha/mmu_context.h	2000-12-29 23:07:23.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-alpha/mmu_context.h	2004-12-30 22:15:16.000000000 +0100
@@ -21,7 +21,7 @@
 #include <asm/io.h>
 #endif
 
-extern inline unsigned long
+static inline unsigned long
 __reload_thread(struct thread_struct *pcb)
 {
 	register unsigned long a0 __asm__("$16");
@@ -221,7 +221,7 @@
 # endif
 #endif
 
-extern inline int
+static inline int
 init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
 	int i;
@@ -232,7 +232,7 @@
 	return 0;
 }
 
-extern inline void
+static inline void
 destroy_context(struct mm_struct *mm)
 {
 	/* Nothing to do.  */
diff -rbNu linux-2.4.20-std/include/asm-alpha/page.h linux-2.4.20-kfi/include/asm-alpha/page.h
--- linux-2.4.20-std/include/asm-alpha/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/page.h	2004-12-30 22:15:16.000000000 +0100
@@ -67,7 +67,7 @@
 #define PAGE_BUG(page)	BUG()
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-alpha/pci.h linux-2.4.20-kfi/include/asm-alpha/pci.h
--- linux-2.4.20-std/include/asm-alpha/pci.h	2002-02-25 20:38:09.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-alpha/pci.h	2004-12-30 22:15:16.000000000 +0100
@@ -54,7 +54,7 @@
 
 extern void pcibios_set_master(struct pci_dev *dev);
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff -rbNu linux-2.4.20-std/include/asm-alpha/pgtable.h linux-2.4.20-kfi/include/asm-alpha/pgtable.h
--- linux-2.4.20-std/include/asm-alpha/pgtable.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/pgtable.h	2004-12-30 22:15:16.000000000 +0100
@@ -221,16 +221,16 @@
 })
 #endif
 
-extern inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
+static inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
 { pte_t pte; pte_val(pte) = (PHYS_TWIDDLE(physpage) << (32-PAGE_SHIFT)) | pgprot_val(pgprot); return pte; }
 
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { pte_val(pte) = (pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot); return pte; }
 
-extern inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
+static inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
 { pmd_val(*pmdp) = _PAGE_TABLE | ((((unsigned long) ptep) - PAGE_OFFSET) << (32-PAGE_SHIFT)); }
 
-extern inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
+static inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
 { pgd_val(*pgdp) = _PAGE_TABLE | ((((unsigned long) pmdp) - PAGE_OFFSET) << (32-PAGE_SHIFT)); }
 
 #ifndef CONFIG_DISCONTIGMEM
@@ -248,46 +248,46 @@
 })
 #endif
 
-extern inline unsigned long pmd_page(pmd_t pmd)
+static inline unsigned long pmd_page(pmd_t pmd)
 { return PAGE_OFFSET + ((pmd_val(pmd) & _PFN_MASK) >> (32-PAGE_SHIFT)); }
 
-extern inline unsigned long pgd_page(pgd_t pgd)
+static inline unsigned long pgd_page(pgd_t pgd)
 { return PAGE_OFFSET + ((pgd_val(pgd) & _PFN_MASK) >> (32-PAGE_SHIFT)); }
 
-extern inline int pte_none(pte_t pte)		{ return !pte_val(pte); }
-extern inline int pte_present(pte_t pte)	{ return pte_val(pte) & _PAGE_VALID; }
-extern inline void pte_clear(pte_t *ptep)	{ pte_val(*ptep) = 0; }
-
-extern inline int pmd_none(pmd_t pmd)		{ return !pmd_val(pmd); }
-extern inline int pmd_bad(pmd_t pmd)		{ return (pmd_val(pmd) & ~_PFN_MASK) != _PAGE_TABLE; }
-extern inline int pmd_present(pmd_t pmd)	{ return pmd_val(pmd) & _PAGE_VALID; }
-extern inline void pmd_clear(pmd_t * pmdp)	{ pmd_val(*pmdp) = 0; }
-
-extern inline int pgd_none(pgd_t pgd)		{ return !pgd_val(pgd); }
-extern inline int pgd_bad(pgd_t pgd)		{ return (pgd_val(pgd) & ~_PFN_MASK) != _PAGE_TABLE; }
-extern inline int pgd_present(pgd_t pgd)	{ return pgd_val(pgd) & _PAGE_VALID; }
-extern inline void pgd_clear(pgd_t * pgdp)	{ pgd_val(*pgdp) = 0; }
+static inline int pte_none(pte_t pte)		{ return !pte_val(pte); }
+static inline int pte_present(pte_t pte)	{ return pte_val(pte) & _PAGE_VALID; }
+static inline void pte_clear(pte_t *ptep)	{ pte_val(*ptep) = 0; }
+
+static inline int pmd_none(pmd_t pmd)		{ return !pmd_val(pmd); }
+static inline int pmd_bad(pmd_t pmd)		{ return (pmd_val(pmd) & ~_PFN_MASK) != _PAGE_TABLE; }
+static inline int pmd_present(pmd_t pmd)	{ return pmd_val(pmd) & _PAGE_VALID; }
+static inline void pmd_clear(pmd_t * pmdp)	{ pmd_val(*pmdp) = 0; }
+
+static inline int pgd_none(pgd_t pgd)		{ return !pgd_val(pgd); }
+static inline int pgd_bad(pgd_t pgd)		{ return (pgd_val(pgd) & ~_PFN_MASK) != _PAGE_TABLE; }
+static inline int pgd_present(pgd_t pgd)	{ return pgd_val(pgd) & _PAGE_VALID; }
+static inline void pgd_clear(pgd_t * pgdp)	{ pgd_val(*pgdp) = 0; }
 
 /*
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
-extern inline int pte_read(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOR); }
-extern inline int pte_write(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOW); }
-extern inline int pte_exec(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOE); }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-
-extern inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOW; return pte; }
-extern inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOR; return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOE; return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~(__DIRTY_BITS); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~(__ACCESS_BITS); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOW; return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOR; return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOE; return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= __DIRTY_BITS; return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= __ACCESS_BITS; return pte; }
+static inline int pte_read(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOR); }
+static inline int pte_write(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOW); }
+static inline int pte_exec(pte_t pte)		{ return !(pte_val(pte) & _PAGE_FOE); }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+
+static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOW; return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOR; return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_FOE; return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~(__DIRTY_BITS); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~(__ACCESS_BITS); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOW; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOR; return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ pte_val(pte) &= ~_PAGE_FOE; return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= __DIRTY_BITS; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= __ACCESS_BITS; return pte; }
 
 #define PAGE_DIR_OFFSET(tsk,address) pgd_offset((tsk),(address))
 
@@ -300,13 +300,13 @@
 #define pgd_offset(mm, address)	((mm)->pgd+pgd_index(address))
 
 /* Find an entry in the second-level page table.. */
-extern inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
+static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
 {
 	return (pmd_t *) pgd_page(*dir) + ((address >> PMD_SHIFT) & (PTRS_PER_PAGE - 1));
 }
 
 /* Find an entry in the third-level page table.. */
-extern inline pte_t * pte_offset(pmd_t * dir, unsigned long address)
+static inline pte_t * pte_offset(pmd_t * dir, unsigned long address)
 {
 	return (pte_t *) pmd_page(*dir) + ((address >> PAGE_SHIFT) & (PTRS_PER_PAGE - 1));
 }
@@ -317,7 +317,7 @@
  * The Alpha doesn't have any external MMU info:  the kernel page
  * tables contain all the necessary information.
  */
-extern inline void update_mmu_cache(struct vm_area_struct * vma,
+static inline void update_mmu_cache(struct vm_area_struct * vma,
 	unsigned long address, pte_t pte)
 {
 }
@@ -326,7 +326,7 @@
  * Non-present pages:  high 24 bits are offset, next 8 bits type,
  * low 32 bits zero.
  */
-extern inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
+static inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
 { pte_t pte; pte_val(pte) = (type << 32) | (offset << 40); return pte; }
 
 #define SWP_TYPE(x)			(((x).val >> 32) & 0xff)
diff -rbNu linux-2.4.20-std/include/asm-alpha/processor.h linux-2.4.20-kfi/include/asm-alpha/processor.h
--- linux-2.4.20-std/include/asm-alpha/processor.h	2001-10-05 21:11:05.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/processor.h	2004-12-30 22:15:16.000000000 +0100
@@ -97,7 +97,7 @@
  * to be in so that we can fail gracefully.  This is just for ps after
  * all.  -- r~
  */
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	unsigned long fp, sp = t->ksp, base = (unsigned long)t;
  
@@ -154,17 +154,17 @@
 #define ARCH_HAS_PREFETCHW
 #define ARCH_HAS_SPINLOCK_PREFETCH
 
-extern inline void prefetch(const void *ptr)  
+static inline void prefetch(const void *ptr)  
 { 
 	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
 }
 
-extern inline void prefetchw(const void *ptr)  
+static inline void prefetchw(const void *ptr)  
 {
 	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
 }
 
-extern inline void spin_lock_prefetch(const void *ptr)  
+static inline void spin_lock_prefetch(const void *ptr)  
 {
 	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
 }
diff -rbNu linux-2.4.20-std/include/asm-alpha/semaphore.h linux-2.4.20-kfi/include/asm-alpha/semaphore.h
--- linux-2.4.20-std/include/asm-alpha/semaphore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-alpha/semaphore.h	2004-12-30 22:15:16.000000000 +0100
@@ -208,19 +208,19 @@
 }
 
 #if !WAITQUEUE_DEBUG && !defined(CONFIG_DEBUG_SEMAPHORE)
-extern inline void down(struct semaphore *sem)
+static inline void down(struct semaphore *sem)
 {
 	__down(sem);
 }
-extern inline int down_interruptible(struct semaphore *sem)
+static inline int down_interruptible(struct semaphore *sem)
 {
 	return __down_interruptible(sem);
 }
-extern inline int down_trylock(struct semaphore *sem)
+static inline int down_trylock(struct semaphore *sem)
 {
 	return __down_trylock(sem);
 }
-extern inline void up(struct semaphore *sem)
+static inline void up(struct semaphore *sem)
 {
 	__up(sem);
 }
diff -rbNu linux-2.4.20-std/include/asm-alpha/siginfo.h linux-2.4.20-kfi/include/asm-alpha/siginfo.h
--- linux-2.4.20-std/include/asm-alpha/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/siginfo.h	2004-12-30 22:15:16.000000000 +0100
@@ -217,7 +217,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-alpha/softirq.h linux-2.4.20-kfi/include/asm-alpha/softirq.h
--- linux-2.4.20-std/include/asm-alpha/softirq.h	2001-09-08 21:02:31.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/softirq.h	2004-12-30 22:15:16.000000000 +0100
@@ -5,13 +5,13 @@
 #include <asm/atomic.h>
 #include <asm/hardirq.h>
 
-extern inline void cpu_bh_disable(int cpu)
+static inline void cpu_bh_disable(int cpu)
 {
 	local_bh_count(cpu)++;
 	barrier();
 }
 
-extern inline void __cpu_bh_enable(int cpu)
+static inline void __cpu_bh_enable(int cpu)
 {
 	barrier();
 	local_bh_count(cpu)--;
diff -rbNu linux-2.4.20-std/include/asm-alpha/system.h linux-2.4.20-kfi/include/asm-alpha/system.h
--- linux-2.4.20-std/include/asm-alpha/system.h	2001-10-05 03:47:08.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/system.h	2004-12-30 22:15:16.000000000 +0100
@@ -369,7 +369,7 @@
  * it must clobber "memory" (also for interrupts in UP).
  */
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __xchg_u32(volatile int *m, unsigned long val)
 {
 	unsigned long dummy;
@@ -391,7 +391,7 @@
 	return val;
 }
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __xchg_u64(volatile long *m, unsigned long val)
 {
 	unsigned long dummy;
@@ -452,7 +452,7 @@
 
 #define __HAVE_ARCH_CMPXCHG 1
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __cmpxchg_u32(volatile int *m, int old, int new)
 {
 	unsigned long prev, cmp;
@@ -477,7 +477,7 @@
 	return prev;
 }
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __cmpxchg_u64(volatile long *m, unsigned long old, unsigned long new)
 {
 	unsigned long prev, cmp;
diff -rbNu linux-2.4.20-std/include/asm-alpha/uaccess.h linux-2.4.20-kfi/include/asm-alpha/uaccess.h
--- linux-2.4.20-std/include/asm-alpha/uaccess.h	2000-08-29 23:09:15.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/uaccess.h	2004-12-30 22:15:16.000000000 +0100
@@ -46,7 +46,7 @@
 #define access_ok(type,addr,size) \
 	__access_ok(((unsigned long)(addr)),(size),get_fs())
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
@@ -342,7 +342,7 @@
 
 extern void __copy_user(void);
 
-extern inline long
+static inline long
 __copy_tofrom_user_nocheck(void *to, const void *from, long len)
 {
 	/* This little bit of silliness is to get the GP loaded for
@@ -364,7 +364,7 @@
 	return __cu_len;
 }
 
-extern inline long
+static inline long
 __copy_tofrom_user(void *to, const void *from, long len, const void *validate)
 {
 	if (__access_ok((long)validate, len, get_fs())) {
@@ -387,13 +387,13 @@
 #define __copy_to_user(to,from,n)   __copy_tofrom_user_nocheck((to),(from),(n))
 #define __copy_from_user(to,from,n) __copy_tofrom_user_nocheck((to),(from),(n))
 
-extern inline long
+static inline long
 copy_to_user(void *to, const void *from, long n)
 {
 	return __copy_tofrom_user(to, from, n, to);
 }
 
-extern inline long
+static inline long
 copy_from_user(void *to, const void *from, long n)
 {
 	return __copy_tofrom_user(to, from, n, from);
@@ -401,7 +401,7 @@
 
 extern void __do_clear_user(void);
 
-extern inline long
+static inline long
 __clear_user(void *to, long len)
 {
 	/* This little bit of silliness is to get the GP loaded for
@@ -420,7 +420,7 @@
 	return __cl_len;
 }
 
-extern inline long
+static inline long
 clear_user(void *to, long len)
 {
 	if (__access_ok((long)to, len, get_fs())) {
@@ -442,7 +442,7 @@
 
 extern long __strncpy_from_user(char *__to, const char *__from, long __to_len);
 
-extern inline long
+static inline long
 strncpy_from_user(char *to, const char *from, long n)
 {
 	long ret = -EFAULT;
@@ -454,7 +454,7 @@
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
 extern long __strlen_user(const char *);
 
-extern inline long strlen_user(const char *str)
+static inline long strlen_user(const char *str)
 {
 	return access_ok(VERIFY_READ,str,0) ? __strlen_user(str) : 0;
 }
@@ -463,7 +463,7 @@
  * a value greater than N if the limit would be exceeded, else strlen.  */
 extern long __strnlen_user(const char *, long);
 
-extern inline long strnlen_user(const char *str, long n)
+static inline long strnlen_user(const char *str, long n)
 {
 	return access_ok(VERIFY_READ,str,0) ? __strnlen_user(str, n) : 0;
 }
diff -rbNu linux-2.4.20-std/include/asm-alpha/unaligned.h linux-2.4.20-kfi/include/asm-alpha/unaligned.h
--- linux-2.4.20-std/include/asm-alpha/unaligned.h	2000-10-26 22:55:10.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/unaligned.h	2004-12-30 22:15:16.000000000 +0100
@@ -29,19 +29,19 @@
  * Elemental unaligned loads 
  */
 
-extern inline unsigned long __uldq(const unsigned long * r11)
+static inline unsigned long __uldq(const unsigned long * r11)
 {
 	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
 	return ptr->x;
 }
 
-extern inline unsigned long __uldl(const unsigned int * r11)
+static inline unsigned long __uldl(const unsigned int * r11)
 {
 	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
 	return ptr->x;
 }
 
-extern inline unsigned long __uldw(const unsigned short * r11)
+static inline unsigned long __uldw(const unsigned short * r11)
 {
 	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
 	return ptr->x;
@@ -51,25 +51,25 @@
  * Elemental unaligned stores 
  */
 
-extern inline void __ustq(unsigned long r5, unsigned long * r11)
+static inline void __ustq(unsigned long r5, unsigned long * r11)
 {
 	struct __una_u64 *ptr = (struct __una_u64 *) r11;
 	ptr->x = r5;
 }
 
-extern inline void __ustl(unsigned long r5, unsigned int * r11)
+static inline void __ustl(unsigned long r5, unsigned int * r11)
 {
 	struct __una_u32 *ptr = (struct __una_u32 *) r11;
 	ptr->x = r5;
 }
 
-extern inline void __ustw(unsigned long r5, unsigned short * r11)
+static inline void __ustw(unsigned long r5, unsigned short * r11)
 {
 	struct __una_u16 *ptr = (struct __una_u16 *) r11;
 	ptr->x = r5;
 }
 
-extern inline unsigned long __get_unaligned(const void *ptr, size_t size)
+static inline unsigned long __get_unaligned(const void *ptr, size_t size)
 {
 	unsigned long val;
 	switch (size) {
@@ -91,7 +91,7 @@
 	return val;
 }
 
-extern inline void __put_unaligned(unsigned long val, void *ptr, size_t size)
+static inline void __put_unaligned(unsigned long val, void *ptr, size_t size)
 {
 	switch (size) {
 	      case 1:
diff -rbNu linux-2.4.20-std/include/asm-alpha/vga.h linux-2.4.20-kfi/include/asm-alpha/vga.h
--- linux-2.4.20-std/include/asm-alpha/vga.h	2001-10-15 22:47:28.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-alpha/vga.h	2004-12-30 22:15:16.000000000 +0100
@@ -13,7 +13,7 @@
 #define VT_BUF_HAVE_MEMSETW
 #define VT_BUF_HAVE_MEMCPYW
 
-extern inline void scr_writew(u16 val, volatile u16 *addr)
+static inline void scr_writew(u16 val, volatile u16 *addr)
 {
 	if (__is_ioaddr((unsigned long) addr))
 		__raw_writew(val, (unsigned long) addr);
@@ -21,7 +21,7 @@
 		*addr = val;
 }
 
-extern inline u16 scr_readw(volatile const u16 *addr)
+static inline u16 scr_readw(volatile const u16 *addr)
 {
 	if (__is_ioaddr((unsigned long) addr))
 		return __raw_readw((unsigned long) addr);
@@ -29,7 +29,7 @@
 		return *addr;
 }
 
-extern inline void scr_memsetw(u16 *s, u16 c, unsigned int count)
+static inline void scr_memsetw(u16 *s, u16 c, unsigned int count)
 {
 	if (__is_ioaddr((unsigned long) s))
 		memsetw_io(s, c, count);
diff -rbNu linux-2.4.20-std/include/asm-arm/arch-epxa10db/system.h linux-2.4.20-kfi/include/asm-arm/arch-epxa10db/system.h
--- linux-2.4.20-std/include/asm-arm/arch-epxa10db/system.h	2001-10-25 22:53:53.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-arm/arch-epxa10db/system.h	2004-12-30 22:15:18.000000000 +0100
@@ -33,7 +33,7 @@
 	cpu_do_idle(0);
 }
 
-extern __inline__ void arch_reset(char mode)
+static __inline__ void arch_reset(char mode)
 {
 	/* Hmm... We can probably do something with the watchdog... */
 }
diff -rbNu linux-2.4.20-std/include/asm-arm/arch-epxa10db/time.h linux-2.4.20-kfi/include/asm-arm/arch-epxa10db/time.h
--- linux-2.4.20-std/include/asm-arm/arch-epxa10db/time.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-arm/arch-epxa10db/time.h	2004-12-30 22:15:18.000000000 +0100
@@ -42,7 +42,7 @@
 /*
  * Set up timer interrupt, and return the current time in seconds.
  */
-extern __inline__ void setup_timer(void)
+static __inline__ void setup_timer(void)
 {
 
 
diff -rbNu linux-2.4.20-std/include/asm-cris/delay.h linux-2.4.20-kfi/include/asm-cris/delay.h
--- linux-2.4.20-std/include/asm-cris/delay.h	2001-10-08 20:43:54.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-cris/delay.h	2004-12-30 22:15:22.000000000 +0100
@@ -16,7 +16,7 @@
 
 extern void __do_delay(void);	/* Special register call calling convention */
 
-extern __inline__ void __delay(int loops)
+static __inline__ void __delay(int loops)
 {
 	__asm__ __volatile__ (
 			      "move.d %0,$r9\n\t"
@@ -34,7 +34,7 @@
 
 extern unsigned long loops_per_usec; /* arch/cris/mm/init.c */
 
-extern __inline__ void udelay(unsigned long usecs)
+static __inline__ void udelay(unsigned long usecs)
 {
 	__delay(usecs * loops_per_usec);
 }
diff -rbNu linux-2.4.20-std/include/asm-cris/io.h linux-2.4.20-kfi/include/asm-cris/io.h
--- linux-2.4.20-std/include/asm-cris/io.h	2001-10-08 20:43:54.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-cris/io.h	2004-12-30 22:15:22.000000000 +0100
@@ -211,7 +211,7 @@
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
diff -rbNu linux-2.4.20-std/include/asm-cris/locks.h linux-2.4.20-kfi/include/asm-cris/locks.h
--- linux-2.4.20-std/include/asm-cris/locks.h	2001-02-09 01:32:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-cris/locks.h	2004-12-30 22:15:22.000000000 +0100
@@ -10,7 +10,7 @@
  *	to borrow for other processors if it was just assembler.
  */
 
-extern __inline__ void prim_spin_lock(struct spinlock *sp)
+static __inline__ void prim_spin_lock(struct spinlock *sp)
 {
 	int processor=smp_processor_id();
 	
@@ -56,7 +56,7 @@
  *	Release a spin lock
  */
  
-extern __inline__ int prim_spin_unlock(struct spinlock *sp)
+static __inline__ int prim_spin_unlock(struct spinlock *sp)
 {
 	/* This is safe. The decrement is still guarded by the lock. A multilock would
 	   not be safe this way */
@@ -73,7 +73,7 @@
  *	Non blocking lock grab
  */
  
-extern __inline__ int prim_spin_lock_nb(struct spinlock *sp)
+static __inline__ int prim_spin_lock_nb(struct spinlock *sp)
 {
 	if(lock_set_bit(0,&sp->lock))
 		return 0;		/* Locked already */
@@ -86,7 +86,7 @@
  *	These wrap the locking primitives up for usage
  */
  
-extern __inline__ void spinlock(struct spinlock *sp)
+static __inline__ void spinlock(struct spinlock *sp)
 {
 	if(sp->priority<current->lock_order)
 		panic("lock order violation: %s (%d)\n", sp->name, current->lock_order);
@@ -100,7 +100,7 @@
 	}
 }
 
-extern __inline__ void spinunlock(struct spinlock *sp)
+static __inline__ void spinunlock(struct spinlock *sp)
 {
 	if(current->lock_order!=sp->priority)
 		panic("lock release order violation %s (%d)\n", sp->name, current->lock_order);
@@ -114,7 +114,7 @@
 	}	
 }
 
-extern __inline__ void spintestlock(struct spinlock *sp)
+static __inline__ void spintestlock(struct spinlock *sp)
 {
 	/*
 	 *	We do no sanity checks, it's legal to optimistically
@@ -123,7 +123,7 @@
 	prim_spin_lock_nb(sp);
 }
 
-extern __inline__ void spintestunlock(struct spinlock *sp)
+static __inline__ void spintestunlock(struct spinlock *sp)
 {
 	/*
 	 *	A testlock doesn't update the lock chain so we
diff -rbNu linux-2.4.20-std/include/asm-cris/pgalloc.h linux-2.4.20-kfi/include/asm-cris/pgalloc.h
--- linux-2.4.20-std/include/asm-cris/pgalloc.h	2001-05-02 01:05:00.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-cris/pgalloc.h	2004-12-30 22:15:22.000000000 +0100
@@ -21,7 +21,7 @@
  * Allocate and free page tables.
  */
 
-extern __inline__ pgd_t *get_pgd_slow(void)
+static __inline__ pgd_t *get_pgd_slow(void)
 {
         pgd_t *ret = (pgd_t *)__get_free_page(GFP_KERNEL);
 
@@ -33,12 +33,12 @@
         return ret;
 }
 
-extern __inline__ void free_pgd_slow(pgd_t *pgd)
+static __inline__ void free_pgd_slow(pgd_t *pgd)
 {
         free_page((unsigned long)pgd);
 }
 
-extern __inline__ pgd_t *get_pgd_fast(void)
+static __inline__ pgd_t *get_pgd_fast(void)
 {
         unsigned long *ret;
 
@@ -51,7 +51,7 @@
         return (pgd_t *)ret;
 }
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
         *(unsigned long *)pgd = (unsigned long) pgd_quicklist;
         pgd_quicklist = (unsigned long *) pgd;
diff -rbNu linux-2.4.20-std/include/asm-cris/processor.h linux-2.4.20-kfi/include/asm-cris/processor.h
--- linux-2.4.20-std/include/asm-cris/processor.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-cris/processor.h	2004-12-30 22:15:21.000000000 +0100
@@ -130,7 +130,7 @@
 /*
  * Return saved PC of a blocked thread.
  */
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	return (unsigned long)user_regs(t)->irp;
 }
diff -rbNu linux-2.4.20-std/include/asm-cris/semaphore.h linux-2.4.20-kfi/include/asm-cris/semaphore.h
--- linux-2.4.20-std/include/asm-cris/semaphore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-cris/semaphore.h	2004-12-30 22:15:21.000000000 +0100
@@ -49,7 +49,7 @@
 #define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
 #define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
 
-extern inline void sema_init(struct semaphore *sem, int val)
+static inline void sema_init(struct semaphore *sem, int val)
 {
 	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
 }
@@ -71,7 +71,7 @@
 
 /* notice - we probably can do cli/sti here instead of saving */
 
-extern inline void down(struct semaphore * sem)
+static inline void down(struct semaphore * sem)
 {
 	unsigned long flags;
 	int failed;
@@ -96,7 +96,7 @@
  * returns negative for signalled and zero for semaphore acquired.
  */
 
-extern inline int down_interruptible(struct semaphore * sem)
+static inline int down_interruptible(struct semaphore * sem)
 {
 	unsigned long flags;
 	int failed;
@@ -115,7 +115,7 @@
 	return(failed);
 }
 
-extern inline int down_trylock(struct semaphore * sem)
+static inline int down_trylock(struct semaphore * sem)
 {
 	unsigned long flags;
 	int failed;
@@ -139,7 +139,7 @@
  * The default case (no contention) will result in NO
  * jumps for both down() and up().
  */
-extern inline void up(struct semaphore * sem)
+static inline void up(struct semaphore * sem)
 {  
 	unsigned long flags;
 	int wakeup;
diff -rbNu linux-2.4.20-std/include/asm-cris/siginfo.h linux-2.4.20-kfi/include/asm-cris/siginfo.h
--- linux-2.4.20-std/include/asm-cris/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-cris/siginfo.h	2004-12-30 22:15:21.000000000 +0100
@@ -217,7 +217,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-cris/smp_lock.h linux-2.4.20-kfi/include/asm-cris/smp_lock.h
--- linux-2.4.20-std/include/asm-cris/smp_lock.h	2001-02-09 01:32:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-cris/smp_lock.h	2004-12-30 22:15:22.000000000 +0100
@@ -11,7 +11,7 @@
  *	Locking the kernel 
  */
  
-extern __inline void lock_kernel(void)
+static __inline void lock_kernel(void)
 {
 	unsigned long flags;
 	int proc = smp_processor_id();
@@ -49,7 +49,7 @@
 	restore_flags(flags);
 }
 
-extern __inline void unlock_kernel(void)
+static __inline void unlock_kernel(void)
 {
 	unsigned long flags;
 	save_flags(flags);
diff -rbNu linux-2.4.20-std/include/asm-cris/uaccess.h linux-2.4.20-kfi/include/asm-cris/uaccess.h
--- linux-2.4.20-std/include/asm-cris/uaccess.h	2001-11-09 23:11:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-cris/uaccess.h	2004-12-30 22:15:22.000000000 +0100
@@ -91,7 +91,7 @@
 #define __access_ok(addr,size) (__kernel_ok || __user_ok((addr),(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
diff -rbNu linux-2.4.20-std/include/asm-generic/bitops.h linux-2.4.20-kfi/include/asm-generic/bitops.h
--- linux-2.4.20-std/include/asm-generic/bitops.h	2000-11-28 02:47:38.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-generic/bitops.h	2004-12-30 22:15:15.000000000 +0100
@@ -16,7 +16,7 @@
  * C language equivalents written by Theodore Ts'o, 9/26/92
  */
 
-extern __inline__ int set_bit(int nr,long * addr)
+static __inline__ int set_bit(int nr,long * addr)
 {
 	int	mask, retval;
 
@@ -29,7 +29,7 @@
 	return retval;
 }
 
-extern __inline__ int clear_bit(int nr, long * addr)
+static __inline__ int clear_bit(int nr, long * addr)
 {
 	int	mask, retval;
 
@@ -42,7 +42,7 @@
 	return retval;
 }
 
-extern __inline__ int test_bit(int nr, long * addr)
+static __inline__ int test_bit(int nr, long * addr)
 {
 	int	mask;
 
diff -rbNu linux-2.4.20-std/include/asm-generic/smplock.h linux-2.4.20-kfi/include/asm-generic/smplock.h
--- linux-2.4.20-std/include/asm-generic/smplock.h	2000-03-23 21:50:09.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-generic/smplock.h	2004-12-30 22:15:15.000000000 +0100
@@ -38,13 +38,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 	if (!++current->lock_depth)
 		spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (--current->lock_depth < 0)
 		spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-i386/apic.h linux-2.4.20-kfi/include/asm-i386/apic.h
--- linux-2.4.20-std/include/asm-i386/apic.h	2004-12-30 17:14:38.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-i386/apic.h	2004-12-31 14:48:10.000000000 +0100
@@ -77,7 +77,7 @@
 extern void smp_local_timer_interrupt (struct pt_regs * regs);
 extern void setup_APIC_clocks (void);
 extern void setup_apic_nmi_watchdog (void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs);
+extern void nmi_watchdog_tick (struct pt_regs * regs);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -rbNu linux-2.4.20-std/include/asm-i386/processor.h linux-2.4.20-kfi/include/asm-i386/processor.h
--- linux-2.4.20-std/include/asm-i386/processor.h	2004-12-30 17:14:37.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-i386/processor.h	2004-12-31 14:48:10.000000000 +0100
@@ -486,7 +486,7 @@
 #ifdef 	CONFIG_MPENTIUMIII
 
 #define ARCH_HAS_PREFETCH
-extern inline void prefetch(const void *x)
+static inline void prefetch(const void *x)
 {
 	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
 }
@@ -497,12 +497,12 @@
 #define ARCH_HAS_PREFETCHW
 #define ARCH_HAS_SPINLOCK_PREFETCH
 
-extern inline void prefetch(const void *x)
+static inline void prefetch(const void *x)
 {
 	 __asm__ __volatile__ ("prefetch (%0)" : : "r"(x));
 }
 
-extern inline void prefetchw(const void *x)
+static inline void prefetchw(const void *x)
 {
 	 __asm__ __volatile__ ("prefetchw (%0)" : : "r"(x));
 }
diff -rbNu linux-2.4.20-std/include/asm-ia64/processor.h linux-2.4.20-kfi/include/asm-ia64/processor.h
--- linux-2.4.20-std/include/asm-ia64/processor.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ia64/processor.h	2004-12-30 22:15:19.000000000 +0100
@@ -949,13 +949,13 @@
 #define ARCH_HAS_SPINLOCK_PREFETCH
 #define PREFETCH_STRIDE 256
 
-extern inline void
+static inline void
 prefetch (const void *x)
 {
          __asm__ __volatile__ ("lfetch [%0]" : : "r"(x));
 }
 
-extern inline void
+static inline void
 prefetchw (const void *x)
 {
 	__asm__ __volatile__ ("lfetch.excl [%0]" : : "r"(x));
diff -rbNu linux-2.4.20-std/include/asm-ia64/sn/bte_copy.h linux-2.4.20-kfi/include/asm-ia64/sn/bte_copy.h
--- linux-2.4.20-std/include/asm-ia64/sn/bte_copy.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ia64/sn/bte_copy.h	2004-12-30 22:15:20.000000000 +0100
@@ -86,7 +86,7 @@
  * NOTE:  This function requires src, dest, and len to
  * be cache line aligned.
  */
-extern __inline__ bte_result_t
+static __inline__ bte_result_t
 bte_copy(u64 src, u64 dest, u64 len, u64 mode, void *notification)
 {
 #ifdef CONFIG_IA64_SGI_BTE_LOCKING
diff -rbNu linux-2.4.20-std/include/asm-ia64/vga.h linux-2.4.20-kfi/include/asm-ia64/vga.h
--- linux-2.4.20-std/include/asm-ia64/vga.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ia64/vga.h	2004-12-30 22:15:19.000000000 +0100
@@ -22,14 +22,14 @@
 #define vga_readb	__raw_readb
 #define vga_writeb	__raw_writeb
 
-extern inline void
+static inline void
 scr_writew (u16 val, volatile u16 *addr)
 {
 	/* Note: ADDR may point to normal memory.  That's OK on ia64.  */
 	__raw_writew(val, (unsigned long) addr);
 }
 
-extern inline u16
+static inline u16
 scr_readw (volatile const u16 *addr)
 {
 	/* Note: ADDR may point to normal memory.  That's OK on ia64.  */
diff -rbNu linux-2.4.20-std/include/asm-m68k/atariints.h linux-2.4.20-kfi/include/asm-m68k/atariints.h
--- linux-2.4.20-std/include/asm-m68k/atariints.h	1997-04-24 04:01:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/atariints.h	2004-12-30 22:15:16.000000000 +0100
@@ -180,14 +180,14 @@
  * "stored"
  */
 
-extern inline void atari_turnon_irq( unsigned irq )
+static inline void atari_turnon_irq( unsigned irq )
 
 {
 	if (irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE) return;
 	set_mfp_bit( irq, MFP_ENABLE );
 }
 
-extern inline void atari_turnoff_irq( unsigned irq )
+static inline void atari_turnoff_irq( unsigned irq )
 
 {
 	if (irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE) return;
@@ -195,14 +195,14 @@
 	clear_mfp_bit( irq, MFP_PENDING );
 }
 
-extern inline void atari_clear_pending_irq( unsigned irq )
+static inline void atari_clear_pending_irq( unsigned irq )
 
 {
 	if (irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE) return;
 	clear_mfp_bit( irq, MFP_PENDING );
 }
 
-extern inline int atari_irq_pending( unsigned irq )
+static inline int atari_irq_pending( unsigned irq )
 
 {
 	if (irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE) return( 0 );
diff -rbNu linux-2.4.20-std/include/asm-m68k/bitops.h linux-2.4.20-kfi/include/asm-m68k/bitops.h
--- linux-2.4.20-std/include/asm-m68k/bitops.h	2001-10-25 22:53:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/bitops.h	2004-12-30 22:15:16.000000000 +0100
@@ -19,7 +19,7 @@
    __constant_test_and_set_bit(nr, vaddr) : \
    __generic_test_and_set_bit(nr, vaddr))
 
-extern __inline__ int __constant_test_and_set_bit(int nr,volatile void * vaddr)
+static __inline__ int __constant_test_and_set_bit(int nr,volatile void * vaddr)
 {
 	char retval;
 
@@ -30,7 +30,7 @@
 	return retval;
 }
 
-extern __inline__ int __generic_test_and_set_bit(int nr,volatile void * vaddr)
+static __inline__ int __generic_test_and_set_bit(int nr,volatile void * vaddr)
 {
 	char retval;
 
@@ -47,13 +47,13 @@
 
 #define __set_bit(nr,vaddr) set_bit(nr,vaddr) 
 
-extern __inline__ void __constant_set_bit(int nr, volatile void * vaddr)
+static __inline__ void __constant_set_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bset %1,%0"
 	     : "+m" (((volatile char *)vaddr)[(nr^31) >> 3]) : "di" (nr & 7));
 }
 
-extern __inline__ void __generic_set_bit(int nr, volatile void * vaddr)
+static __inline__ void __generic_set_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bfset %1@{%0:#1}"
 	     : : "d" (nr^31), "a" (vaddr) : "memory");
@@ -66,7 +66,7 @@
 
 #define __test_and_clear_bit(nr,vaddr) test_and_clear_bit(nr,vaddr)
 
-extern __inline__ int __constant_test_and_clear_bit(int nr, volatile void * vaddr)
+static __inline__ int __constant_test_and_clear_bit(int nr, volatile void * vaddr)
 {
 	char retval;
 
@@ -77,7 +77,7 @@
 	return retval;
 }
 
-extern __inline__ int __generic_test_and_clear_bit(int nr, volatile void * vaddr)
+static __inline__ int __generic_test_and_clear_bit(int nr, volatile void * vaddr)
 {
 	char retval;
 
@@ -98,13 +98,13 @@
    __constant_clear_bit(nr, vaddr) : \
    __generic_clear_bit(nr, vaddr))
 
-extern __inline__ void __constant_clear_bit(int nr, volatile void * vaddr)
+static __inline__ void __constant_clear_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bclr %1,%0"
 	     : "+m" (((volatile char *)vaddr)[(nr^31) >> 3]) : "di" (nr & 7));
 }
 
-extern __inline__ void __generic_clear_bit(int nr, volatile void * vaddr)
+static __inline__ void __generic_clear_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bfclr %1@{%0:#1}"
 	     : : "d" (nr^31), "a" (vaddr) : "memory");
@@ -118,7 +118,7 @@
 #define __test_and_change_bit(nr,vaddr) test_and_change_bit(nr,vaddr)
 #define __change_bit(nr,vaddr) change_bit(nr,vaddr)
 
-extern __inline__ int __constant_test_and_change_bit(int nr, volatile void * vaddr)
+static __inline__ int __constant_test_and_change_bit(int nr, volatile void * vaddr)
 {
 	char retval;
 
@@ -129,7 +129,7 @@
 	return retval;
 }
 
-extern __inline__ int __generic_test_and_change_bit(int nr, volatile void * vaddr)
+static __inline__ int __generic_test_and_change_bit(int nr, volatile void * vaddr)
 {
 	char retval;
 
@@ -144,24 +144,24 @@
    __constant_change_bit(nr, vaddr) : \
    __generic_change_bit(nr, vaddr))
 
-extern __inline__ void __constant_change_bit(int nr, volatile void * vaddr)
+static __inline__ void __constant_change_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bchg %1,%0"
 	     : "+m" (((volatile char *)vaddr)[(nr^31) >> 3]) : "di" (nr & 7));
 }
 
-extern __inline__ void __generic_change_bit(int nr, volatile void * vaddr)
+static __inline__ void __generic_change_bit(int nr, volatile void * vaddr)
 {
 	__asm__ __volatile__ ("bfchg %1@{%0:#1}"
 	     : : "d" (nr^31), "a" (vaddr) : "memory");
 }
 
-extern __inline__ int test_bit(int nr, const volatile void * vaddr)
+static __inline__ int test_bit(int nr, const volatile void * vaddr)
 {
 	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) vaddr)[nr >> 5])) != 0;
 }
 
-extern __inline__ int find_first_zero_bit(void * vaddr, unsigned size)
+static __inline__ int find_first_zero_bit(void * vaddr, unsigned size)
 {
 	unsigned long *p = vaddr, *addr = vaddr;
 	unsigned long allones = ~0UL;
@@ -184,7 +184,7 @@
 	return ((p - addr) << 5) + (res ^ 31);
 }
 
-extern __inline__ int find_next_zero_bit (void *vaddr, int size,
+static __inline__ int find_next_zero_bit (void *vaddr, int size,
 				      int offset)
 {
 	unsigned long *addr = vaddr;
@@ -214,7 +214,7 @@
  * ffz = Find First Zero in word. Undefined if no zero exists,
  * so code should check against ~0UL first..
  */
-extern __inline__ unsigned long ffz(unsigned long word)
+static __inline__ unsigned long ffz(unsigned long word)
 {
 	int res;
 
@@ -231,7 +231,7 @@
  * differs in spirit from the above ffz (man ffs).
  */
 
-extern __inline__ int ffs(int x)
+static __inline__ int ffs(int x)
 {
 	int cnt;
 
@@ -251,7 +251,7 @@
 
 /* Bitmap functions for the minix filesystem */
 
-extern __inline__ int
+static __inline__ int
 minix_find_first_zero_bit (const void *vaddr, unsigned size)
 {
 	const unsigned short *p = vaddr, *addr = vaddr;
@@ -274,7 +274,7 @@
 	return ((p - addr) << 4) + (res ^ 31);
 }
 
-extern __inline__ int
+static __inline__ int
 minix_test_and_set_bit (int nr, volatile void *vaddr)
 {
 	char retval;
@@ -287,7 +287,7 @@
 
 #define minix_set_bit(nr,addr)	((void)minix_test_and_set_bit(nr,addr))
 
-extern __inline__ int
+static __inline__ int
 minix_test_and_clear_bit (int nr, volatile void *vaddr)
 {
 	char retval;
@@ -298,7 +298,7 @@
 	return retval;
 }
 
-extern __inline__ int
+static __inline__ int
 minix_test_bit (int nr, const volatile void *vaddr)
 {
 	return ((1U << (nr & 15)) & (((const volatile unsigned short *) vaddr)[nr >> 4])) != 0;
@@ -306,7 +306,7 @@
 
 /* Bitmap functions for the ext2 filesystem. */
 
-extern __inline__ int
+static __inline__ int
 ext2_set_bit (int nr, volatile void *vaddr)
 {
 	char retval;
@@ -317,7 +317,7 @@
 	return retval;
 }
 
-extern __inline__ int
+static __inline__ int
 ext2_clear_bit (int nr, volatile void *vaddr)
 {
 	char retval;
@@ -328,13 +328,13 @@
 	return retval;
 }
 
-extern __inline__ int
+static __inline__ int
 ext2_test_bit (int nr, const volatile void *vaddr)
 {
 	return ((1U << (nr & 7)) & (((const volatile unsigned char *) vaddr)[nr >> 3])) != 0;
 }
 
-extern __inline__ int
+static __inline__ int
 ext2_find_first_zero_bit (const void *vaddr, unsigned size)
 {
 	const unsigned long *p = vaddr, *addr = vaddr;
@@ -357,7 +357,7 @@
 	return (p - addr) * 32 + res;
 }
 
-extern __inline__ int
+static __inline__ int
 ext2_find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset)
 {
 	const unsigned long *addr = vaddr;
diff -rbNu linux-2.4.20-std/include/asm-m68k/delay.h linux-2.4.20-kfi/include/asm-m68k/delay.h
--- linux-2.4.20-std/include/asm-m68k/delay.h	2001-01-04 22:00:55.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/delay.h	2004-12-30 22:15:16.000000000 +0100
@@ -9,7 +9,7 @@
  * Delay routines, using a pre-computed "loops_per_jiffy" value.
  */
 
-extern __inline__ void __delay(unsigned long loops)
+static __inline__ void __delay(unsigned long loops)
 {
 	__asm__ __volatile__ ("1: subql #1,%0; jcc 1b"
 		: "=d" (loops) : "0" (loops));
@@ -43,7 +43,7 @@
 	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 4295)) : \
 	__udelay(n))
 
-extern __inline__ unsigned long muldiv(unsigned long a, unsigned long b, unsigned long c)
+static __inline__ unsigned long muldiv(unsigned long a, unsigned long b, unsigned long c)
 {
 	unsigned long tmp;
 
diff -rbNu linux-2.4.20-std/include/asm-m68k/dvma.h linux-2.4.20-kfi/include/asm-m68k/dvma.h
--- linux-2.4.20-std/include/asm-m68k/dvma.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/dvma.h	2004-12-30 22:15:16.000000000 +0100
@@ -55,7 +55,7 @@
 #define dvma_vtob(x) dvma_vtop(x)
 #define dvma_btov(x) dvma_ptov(x)
 
-extern inline int dvma_map_cpu(unsigned long kaddr, unsigned long vaddr, int len)
+static inline int dvma_map_cpu(unsigned long kaddr, unsigned long vaddr, int len)
 {
 	return 0;
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/io.h linux-2.4.20-kfi/include/asm-m68k/io.h
--- linux-2.4.20-std/include/asm-m68k/io.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/io.h	2004-12-30 22:15:16.000000000 +0100
@@ -297,20 +297,20 @@
 		       int cacheflag);
 extern void __iounmap(void *addr, unsigned long size);
 
-extern inline void *ioremap(unsigned long physaddr, unsigned long size)
+static inline void *ioremap(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
-extern inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
+static inline void *ioremap_nocache(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
-extern inline void *ioremap_writethrough(unsigned long physaddr,
+static inline void *ioremap_writethrough(unsigned long physaddr,
 					 unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
 }
-extern inline void *ioremap_fullcache(unsigned long physaddr,
+static inline void *ioremap_fullcache(unsigned long physaddr,
 				      unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
diff -rbNu linux-2.4.20-std/include/asm-m68k/mac_psc.h linux-2.4.20-kfi/include/asm-m68k/mac_psc.h
--- linux-2.4.20-std/include/asm-m68k/mac_psc.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/mac_psc.h	2004-12-30 22:15:16.000000000 +0100
@@ -215,32 +215,32 @@
  *	Access functions
  */
  
-extern inline void psc_write_byte(int offset, __u8 data)
+static inline void psc_write_byte(int offset, __u8 data)
 {
 	*((volatile __u8 *)(psc + offset)) = data;
 }
 
-extern inline void psc_write_word(int offset, __u16 data)
+static inline void psc_write_word(int offset, __u16 data)
 {
 	*((volatile __u16 *)(psc + offset)) = data;
 }
 
-extern inline void psc_write_long(int offset, __u32 data)
+static inline void psc_write_long(int offset, __u32 data)
 {
 	*((volatile __u32 *)(psc + offset)) = data;
 }
 
-extern inline u8 psc_read_byte(int offset)
+static inline u8 psc_read_byte(int offset)
 {
 	return *((volatile __u8 *)(psc + offset));
 }
 
-extern inline u16 psc_read_word(int offset)
+static inline u16 psc_read_word(int offset)
 {
 	return *((volatile __u16 *)(psc + offset));
 }
 
-extern inline u32 psc_read_long(int offset)
+static inline u32 psc_read_long(int offset)
 {
 	return *((volatile __u32 *)(psc + offset));
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/mac_via.h linux-2.4.20-kfi/include/asm-m68k/mac_via.h
--- linux-2.4.20-std/include/asm-m68k/mac_via.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/mac_via.h	2004-12-30 22:15:16.000000000 +0100
@@ -255,7 +255,7 @@
 extern int rbv_present,via_alt_mapping;
 extern __u8 rbv_clear;
 
-extern __inline__ int rbv_set_video_bpp(int bpp) {
+static __inline__ int rbv_set_video_bpp(int bpp) {
 	char val = (bpp==1)?0:(bpp==2)?1:(bpp==4)?2:(bpp==8)?3:-1;
 	if (!rbv_present || val<0) return -1;
 	via2[rMonP] = (via2[rMonP] & ~RBV_DEPTH) | val;
diff -rbNu linux-2.4.20-std/include/asm-m68k/mmu_context.h linux-2.4.20-kfi/include/asm-m68k/mmu_context.h
--- linux-2.4.20-std/include/asm-m68k/mmu_context.h	2000-12-29 23:07:23.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/mmu_context.h	2004-12-30 22:15:16.000000000 +0100
@@ -13,7 +13,7 @@
 #include <asm/page.h>
 #include <asm/pgalloc.h>
 
-extern inline int
+static inline int
 init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
 	mm->context = virt_to_phys(mm->pgd);
@@ -22,7 +22,7 @@
 
 #define destroy_context(mm)		do { } while(0)
 
-extern inline void switch_mm_0230(struct mm_struct *mm)
+static inline void switch_mm_0230(struct mm_struct *mm)
 {
 	unsigned long crp[2] = {
 		0x80000000 | _PAGE_TABLE, mm->context
@@ -55,7 +55,7 @@
 	asm volatile (".chip 68k");
 }
 
-extern inline void switch_mm_0460(struct mm_struct *mm)
+static inline void switch_mm_0460(struct mm_struct *mm)
 {
 	asm volatile (".chip 68040");
 
@@ -89,7 +89,7 @@
 	}
 }
 
-extern inline void activate_mm(struct mm_struct *prev_mm,
+static inline void activate_mm(struct mm_struct *prev_mm,
 			       struct mm_struct *next_mm)
 {
 	next_mm->context = virt_to_phys(next_mm->pgd);
@@ -140,7 +140,7 @@
 	activate_context(tsk->mm);
 }
 
-extern inline void activate_mm(struct mm_struct *prev_mm,
+static inline void activate_mm(struct mm_struct *prev_mm,
 			       struct mm_struct *next_mm)
 {
 	activate_context(next_mm);
diff -rbNu linux-2.4.20-std/include/asm-m68k/motorola_pgalloc.h linux-2.4.20-kfi/include/asm-m68k/motorola_pgalloc.h
--- linux-2.4.20-std/include/asm-m68k/motorola_pgalloc.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/motorola_pgalloc.h	2004-12-30 22:15:16.000000000 +0100
@@ -22,7 +22,7 @@
 extern int free_pointer_table(pmd_t *);
 
 
-extern inline void flush_tlb_kernel_page(unsigned long addr)
+static inline void flush_tlb_kernel_page(unsigned long addr)
 {
 	if (CPU_IS_040_OR_060) {
 		mm_segment_t old_fs = get_fs();
@@ -37,7 +37,7 @@
 }
 
 
-extern inline pte_t *get_pte_fast(void)
+static inline pte_t *get_pte_fast(void)
 {
 	unsigned long *ret;
 
@@ -67,26 +67,26 @@
 }
 
 
-extern __inline__ pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
+static __inline__ pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
         return get_pointer_table();
 }
 
 
-extern inline void free_pte_fast(pte_t *pte)
+static inline void free_pte_fast(pte_t *pte)
 {
 	*(unsigned long *)pte = (unsigned long)pte_quicklist;
 	pte_quicklist = (unsigned long *)pte;
 	quicklists.pgtable_cache_sz += 8;
 }
 
-extern inline void free_pte_slow(pte_t *pte)
+static inline void free_pte_slow(pte_t *pte)
 {
 	cache_page((unsigned long)pte);
 	free_page((unsigned long) pte);
 }
 
-extern inline pmd_t *get_pmd_fast(void)
+static inline pmd_t *get_pmd_fast(void)
 {
 	unsigned long *ret;
 
@@ -100,72 +100,72 @@
 }
 #define pmd_alloc_one_fast(mm,addr) get_pmd_fast()
 
-extern inline void free_pmd_fast(pmd_t *pmd)
+static inline void free_pmd_fast(pmd_t *pmd)
 {
 	*(unsigned long *)pmd = (unsigned long)pmd_quicklist;
 	pmd_quicklist = (unsigned long *) pmd;
 	quicklists.pgtable_cache_sz++;
 }
 
-extern inline int free_pmd_slow(pmd_t *pmd)
+static inline int free_pmd_slow(pmd_t *pmd)
 {
 	return free_pointer_table(pmd);
 }
 
 /* The pgd cache is folded into the pmd cache, so these are dummy routines. */
-extern inline pgd_t *get_pgd_fast(void)
+static inline pgd_t *get_pgd_fast(void)
 {
 	return (pgd_t *)0;
 }
 
-extern inline void free_pgd_fast(pgd_t *pgd)
+static inline void free_pgd_fast(pgd_t *pgd)
 {
 }
 
-extern inline void free_pgd_slow(pgd_t *pgd)
+static inline void free_pgd_slow(pgd_t *pgd)
 {
 }
 
 extern void __bad_pte(pmd_t *pmd);
 extern void __bad_pmd(pgd_t *pgd);
 
-extern inline void pte_free(pte_t *pte)
+static inline void pte_free(pte_t *pte)
 {
 	free_pte_fast(pte);
 }
 
-extern inline void pmd_free(pmd_t *pmd)
+static inline void pmd_free(pmd_t *pmd)
 {
 	free_pmd_fast(pmd);
 }
 
 
-extern inline void pte_free_kernel(pte_t *pte)
+static inline void pte_free_kernel(pte_t *pte)
 {
 	free_pte_fast(pte);
 }
 
-extern inline pte_t *pte_alloc_kernel(pmd_t *pmd, unsigned long address)
+static inline pte_t *pte_alloc_kernel(pmd_t *pmd, unsigned long address)
 {
 	return pte_alloc(&init_mm,pmd, address);
 }
 
-extern inline void pmd_free_kernel(pmd_t *pmd)
+static inline void pmd_free_kernel(pmd_t *pmd)
 {
 	free_pmd_fast(pmd);
 }
 
-extern inline pmd_t *pmd_alloc_kernel(pgd_t *pgd, unsigned long address)
+static inline pmd_t *pmd_alloc_kernel(pgd_t *pgd, unsigned long address)
 {
 	return pmd_alloc(&init_mm,pgd, address);
 }
 
-extern inline void pgd_free(pgd_t *pgd)
+static inline void pgd_free(pgd_t *pgd)
 {
 	free_pmd_fast((pmd_t *)pgd);
 }
 
-extern inline pgd_t *pgd_alloc(struct mm_struct *mm)
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	pgd_t *pgd = (pgd_t *)get_pmd_fast();
 	if (!pgd)
@@ -180,7 +180,7 @@
 
 extern int do_check_pgt_cache(int, int);
 
-extern inline void set_pgdir(unsigned long address, pgd_t entry)
+static inline void set_pgdir(unsigned long address, pgd_t entry)
 {
 }
 
@@ -249,7 +249,7 @@
 }
 
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
 				      unsigned long start, unsigned long end)
 {
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/motorola_pgtable.h linux-2.4.20-kfi/include/asm-m68k/motorola_pgtable.h
--- linux-2.4.20-std/include/asm-m68k/motorola_pgtable.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/motorola_pgtable.h	2004-12-30 22:15:16.000000000 +0100
@@ -109,10 +109,10 @@
 	__pte;								\
 })
 
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { pte_val(pte) = (pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot); return pte; }
 
-extern inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
+static inline void pmd_set(pmd_t * pmdp, pte_t * ptep)
 {
 	unsigned long ptbl = virt_to_phys(ptep) | _PAGE_TABLE | _PAGE_ACCESSED;
 	unsigned long *ptr = pmdp->pmd;
@@ -123,7 +123,7 @@
 	}
 }
 
-extern inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
+static inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
 { pgd_val(*pgdp) = _PAGE_TABLE | _PAGE_ACCESSED | __pa(pmdp); }
 
 #define __pte_page(pte) ((unsigned long)__va(pte_val(pte) & PAGE_MASK))
@@ -165,35 +165,35 @@
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
-extern inline int pte_read(pte_t pte)		{ return 1; }
-extern inline int pte_write(pte_t pte)		{ return !(pte_val(pte) & _PAGE_RONLY); }
-extern inline int pte_exec(pte_t pte)		{ return 1; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-
-extern inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_RONLY; return pte; }
-extern inline pte_t pte_rdprotect(pte_t pte)	{ return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) &= ~_PAGE_RONLY; return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mknocache(pte_t pte)
+static inline int pte_read(pte_t pte)		{ return 1; }
+static inline int pte_write(pte_t pte)		{ return !(pte_val(pte) & _PAGE_RONLY); }
+static inline int pte_exec(pte_t pte)		{ return 1; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+
+static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) |= _PAGE_RONLY; return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) &= ~_PAGE_RONLY; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mknocache(pte_t pte)
 {
 	pte_val(pte) = (pte_val(pte) & _CACHEMASK040) | m68k_pgtable_cachemode;
 	return pte;
 }
-extern inline pte_t pte_mkcache(pte_t pte)	{ pte_val(pte) = (pte_val(pte) & _CACHEMASK040) | m68k_supervisor_cachemode; return pte; }
+static inline pte_t pte_mkcache(pte_t pte)	{ pte_val(pte) = (pte_val(pte) & _CACHEMASK040) | m68k_supervisor_cachemode; return pte; }
 
 #define PAGE_DIR_OFFSET(tsk,address) pgd_offset((tsk),(address))
 
 #define pgd_index(address)     ((address) >> PGDIR_SHIFT)
 
 /* to find an entry in a page-table-directory */
-extern inline pgd_t * pgd_offset(struct mm_struct * mm, unsigned long address)
+static inline pgd_t * pgd_offset(struct mm_struct * mm, unsigned long address)
 {
 	return mm->pgd + pgd_index(address);
 }
@@ -201,20 +201,20 @@
 #define swapper_pg_dir kernel_pg_dir
 extern pgd_t kernel_pg_dir[128];
 
-extern inline pgd_t * pgd_offset_k(unsigned long address)
+static inline pgd_t * pgd_offset_k(unsigned long address)
 {
 	return kernel_pg_dir + (address >> PGDIR_SHIFT);
 }
 
 
 /* Find an entry in the second-level page table.. */
-extern inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
+static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
 {
 	return (pmd_t *)__pgd_page(*dir) + ((address >> PMD_SHIFT) & (PTRS_PER_PMD-1));
 }
 
 /* Find an entry in the third-level page table.. */ 
-extern inline pte_t * pte_offset(pmd_t * pmdp, unsigned long address)
+static inline pte_t * pte_offset(pmd_t * pmdp, unsigned long address)
 {
 	return (pte_t *)__pmd_page(*pmdp) + ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/nubus.h linux-2.4.20-kfi/include/asm-m68k/nubus.h
--- linux-2.4.20-std/include/asm-m68k/nubus.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/nubus.h	2004-12-30 22:15:16.000000000 +0100
@@ -15,25 +15,25 @@
 #define nubus_memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
 #define nubus_memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
 
-extern inline void *nubus_remap_nocache_ser(unsigned long physaddr,
+static inline void *nubus_remap_nocache_ser(unsigned long physaddr,
 					    unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
 
-extern inline void *nubus_remap_nocache_nonser(unsigned long physaddr,
+static inline void *nubus_remap_nocache_nonser(unsigned long physaddr,
 					       unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_NONSER);
 }
 
-extern inline void *nbus_remap_writethrough(unsigned long physaddr,
+static inline void *nbus_remap_writethrough(unsigned long physaddr,
 					    unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
 }
 
-extern inline void *nubus_remap_fullcache(unsigned long physaddr,
+static inline void *nubus_remap_fullcache(unsigned long physaddr,
 					  unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
diff -rbNu linux-2.4.20-std/include/asm-m68k/page.h linux-2.4.20-kfi/include/asm-m68k/page.h
--- linux-2.4.20-std/include/asm-m68k/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/page.h	2004-12-30 22:15:16.000000000 +0100
@@ -101,7 +101,7 @@
 #define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-m68k/pci.h linux-2.4.20-kfi/include/asm-m68k/pci.h
--- linux-2.4.20-std/include/asm-m68k/pci.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/pci.h	2004-12-30 22:15:16.000000000 +0100
@@ -35,12 +35,12 @@
 
 #define pcibios_assign_all_busses()	0
 
-extern inline void pcibios_set_master(struct pci_dev *dev)
+static inline void pcibios_set_master(struct pci_dev *dev)
 {
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/pgalloc.h linux-2.4.20-kfi/include/asm-m68k/pgalloc.h
--- linux-2.4.20-std/include/asm-m68k/pgalloc.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/pgalloc.h	2004-12-30 22:15:16.000000000 +0100
@@ -83,13 +83,13 @@
 
 #define flush_cache_all() __flush_cache_all()
 
-extern inline void flush_cache_mm(struct mm_struct *mm)
+static inline void flush_cache_mm(struct mm_struct *mm)
 {
 	if (mm == current->mm)
 		__flush_cache_030();
 }
 
-extern inline void flush_cache_range(struct mm_struct *mm,
+static inline void flush_cache_range(struct mm_struct *mm,
 				     unsigned long start,
 				     unsigned long end)
 {
@@ -97,7 +97,7 @@
 	        __flush_cache_030();
 }
 
-extern inline void flush_cache_page(struct vm_area_struct *vma,
+static inline void flush_cache_page(struct vm_area_struct *vma,
 				    unsigned long vmaddr)
 {
 	if (vma->vm_mm == current->mm)
@@ -107,7 +107,7 @@
 /* Push the page at kernel virtual address and clear the icache */
 /* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
 #define flush_page_to_ram(page) __flush_page_to_ram((unsigned long) page_address(page))
-extern inline void __flush_page_to_ram(unsigned long address)
+static inline void __flush_page_to_ram(unsigned long address)
 {
 	if (CPU_IS_040_OR_060) {
 		__asm__ __volatile__("nop\n\t"
@@ -131,7 +131,7 @@
 
 /* Push n pages at kernel virtual address and clear the icache */
 /* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
-extern inline void flush_icache_range (unsigned long address,
+static inline void flush_icache_range (unsigned long address,
 				       unsigned long endaddr)
 {
 	if (CPU_IS_040_OR_060) {
diff -rbNu linux-2.4.20-std/include/asm-m68k/pgtable.h linux-2.4.20-kfi/include/asm-m68k/pgtable.h
--- linux-2.4.20-std/include/asm-m68k/pgtable.h	2001-10-25 22:53:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/pgtable.h	2004-12-30 22:15:16.000000000 +0100
@@ -123,7 +123,7 @@
  * It makes no sense to consider whether we cross a memory boundary if
  * we support just one physical chunk of memory.
  */
-extern inline int mm_end_of_chunk (unsigned long addr, int len)
+static inline int mm_end_of_chunk (unsigned long addr, int len)
 {
 	return 0;
 }
@@ -138,7 +138,7 @@
  * tables contain all the necessary information.  The Sun3 does, but
  * they are updated on demand.
  */
-extern inline void update_mmu_cache(struct vm_area_struct * vma,
+static inline void update_mmu_cache(struct vm_area_struct * vma,
 	unsigned long address, pte_t pte)
 {
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/processor.h linux-2.4.20-kfi/include/asm-m68k/processor.h
--- linux-2.4.20-std/include/asm-m68k/processor.h	2001-10-05 21:11:05.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/processor.h	2004-12-30 22:15:16.000000000 +0100
@@ -18,14 +18,14 @@
 #include <asm/fpu.h>
 #include <asm/ptrace.h>
 
-extern inline unsigned long rdusp(void) {
+static inline unsigned long rdusp(void) {
   	unsigned long usp;
 
 	__asm__ __volatile__("move %/usp,%0" : "=a" (usp));
 	return usp;
 }
 
-extern inline void wrusp(unsigned long usp) {
+static inline void wrusp(unsigned long usp) {
 	__asm__ __volatile__("move %0,%/usp" : : "a" (usp));
 }
 
@@ -120,7 +120,7 @@
 /*
  * Return saved PC of a blocked thread.
  */
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	extern void scheduling_functions_start_here(void);
 	extern void scheduling_functions_end_here(void);
diff -rbNu linux-2.4.20-std/include/asm-m68k/sbus.h linux-2.4.20-kfi/include/asm-m68k/sbus.h
--- linux-2.4.20-std/include/asm-m68k/sbus.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/sbus.h	2004-12-30 22:15:16.000000000 +0100
@@ -20,17 +20,17 @@
 /* sbus IO functions stolen from include/asm-sparc/io.h for the serial driver */
 /* No SBUS on the Sun3, kludge -- sam */
 
-extern inline void _sbus_writeb(unsigned char val, unsigned long addr)
+static inline void _sbus_writeb(unsigned char val, unsigned long addr)
 {
 	*(volatile unsigned char *)addr = val;
 }
 
-extern inline unsigned char _sbus_readb(unsigned long addr)
+static inline unsigned char _sbus_readb(unsigned long addr)
 {
 	return *(volatile unsigned char *)addr;
 }
 
-extern inline void _sbus_writel(unsigned long val, unsigned long addr)
+static inline void _sbus_writel(unsigned long val, unsigned long addr)
 {
 	*(volatile unsigned long *)addr = val;
 
diff -rbNu linux-2.4.20-std/include/asm-m68k/semaphore.h linux-2.4.20-kfi/include/asm-m68k/semaphore.h
--- linux-2.4.20-std/include/asm-m68k/semaphore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/semaphore.h	2004-12-30 22:15:16.000000000 +0100
@@ -51,7 +51,7 @@
 #define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
 #define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
 
-extern inline void sema_init (struct semaphore *sem, int val)
+static inline void sema_init (struct semaphore *sem, int val)
 {
 	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER(*sem, val);
 }
@@ -81,7 +81,7 @@
  * "down_failed" is a special asm handler that calls the C
  * routine that actually waits. See arch/m68k/lib/semaphore.S
  */
-extern inline void down(struct semaphore * sem)
+static inline void down(struct semaphore * sem)
 {
 	register struct semaphore *sem1 __asm__ ("%a1") = sem;
 
@@ -103,7 +103,7 @@
 		: "memory");
 }
 
-extern inline int down_interruptible(struct semaphore * sem)
+static inline int down_interruptible(struct semaphore * sem)
 {
 	register struct semaphore *sem1 __asm__ ("%a1") = sem;
 	register int result __asm__ ("%d0");
@@ -128,7 +128,7 @@
 	return result;
 }
 
-extern inline int down_trylock(struct semaphore * sem)
+static inline int down_trylock(struct semaphore * sem)
 {
 	register struct semaphore *sem1 __asm__ ("%a1") = sem;
 	register int result __asm__ ("%d0");
@@ -159,7 +159,7 @@
  * The default case (no contention) will result in NO
  * jumps for both down() and up().
  */
-extern inline void up(struct semaphore * sem)
+static inline void up(struct semaphore * sem)
 {
 	register struct semaphore *sem1 __asm__ ("%a1") = sem;
 
diff -rbNu linux-2.4.20-std/include/asm-m68k/siginfo.h linux-2.4.20-kfi/include/asm-m68k/siginfo.h
--- linux-2.4.20-std/include/asm-m68k/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/siginfo.h	2004-12-30 22:15:16.000000000 +0100
@@ -227,7 +227,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-m68k/signal.h linux-2.4.20-kfi/include/asm-m68k/signal.h
--- linux-2.4.20-std/include/asm-m68k/signal.h	1999-11-19 04:37:03.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/signal.h	2004-12-30 22:15:16.000000000 +0100
@@ -176,25 +176,25 @@
 
 #define __HAVE_ARCH_SIG_BITOPS
 
-extern __inline__ void sigaddset(sigset_t *set, int _sig)
+static __inline__ void sigaddset(sigset_t *set, int _sig)
 {
 	__asm__("bfset %0{%1,#1}" : "=m" (*set) : "id" ((_sig - 1) ^ 31)
 		: "cc");
 }
 
-extern __inline__ void sigdelset(sigset_t *set, int _sig)
+static __inline__ void sigdelset(sigset_t *set, int _sig)
 {
 	__asm__("bfclr %0{%1,#1}" : "=m"(*set) : "id"((_sig - 1) ^ 31)
 		: "cc");
 }
 
-extern __inline__ int __const_sigismember(sigset_t *set, int _sig)
+static __inline__ int __const_sigismember(sigset_t *set, int _sig)
 {
 	unsigned long sig = _sig - 1;
 	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
 }
 
-extern __inline__ int __gen_sigismember(sigset_t *set, int _sig)
+static __inline__ int __gen_sigismember(sigset_t *set, int _sig)
 {
 	int ret;
 	__asm__("bfextu %1{%2,#1},%0"
@@ -209,7 +209,7 @@
 
 #define sigmask(sig)	(1UL << ((sig) - 1))
 
-extern __inline__ int sigfindinword(unsigned long word)
+static __inline__ int sigfindinword(unsigned long word)
 {
 	__asm__("bfffo %1{#0,#0},%0" : "=d"(word) : "d"(word & -word) : "cc");
 	return word ^ 31;
diff -rbNu linux-2.4.20-std/include/asm-m68k/smplock.h linux-2.4.20-kfi/include/asm-m68k/smplock.h
--- linux-2.4.20-std/include/asm-m68k/smplock.h	2000-03-23 21:50:09.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/smplock.h	2004-12-30 22:15:16.000000000 +0100
@@ -38,13 +38,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 	if (!++current->lock_depth)
 		spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (--current->lock_depth < 0)
 		spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-m68k/string.h linux-2.4.20-kfi/include/asm-m68k/string.h
--- linux-2.4.20-std/include/asm-m68k/string.h	2001-10-25 22:53:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/string.h	2004-12-30 22:15:16.000000000 +0100
@@ -82,7 +82,7 @@
 
 #if 0
 #define __HAVE_ARCH_STRPBRK
-extern inline char * strpbrk(const char * cs,const char * ct)
+static inline char * strpbrk(const char * cs,const char * ct)
 {
   const char *sc1,*sc2;
   
@@ -119,7 +119,7 @@
 
 #if 0
 #define __HAVE_ARCH_STRTOK
-extern inline char * strtok(char * s,const char * ct)
+static inline char * strtok(char * s,const char * ct)
 {
   char *sbegin, *send;
   
@@ -553,7 +553,7 @@
  memcmp((cs),(ct),(n)))
 
 #define __HAVE_ARCH_MEMCHR
-extern inline void * memchr(const void * cs, int c, size_t count) {
+static inline void * memchr(const void * cs, int c, size_t count) {
 	/* Someone else can optimize this, I don't care - tonym@mac.linux-m68k.org */
 	unsigned char *ret = (unsigned char *)cs;
 	for(;count>0;count--,ret++)
diff -rbNu linux-2.4.20-std/include/asm-m68k/sun3_pgalloc.h linux-2.4.20-kfi/include/asm-m68k/sun3_pgalloc.h
--- linux-2.4.20-std/include/asm-m68k/sun3_pgalloc.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/sun3_pgalloc.h	2004-12-30 22:15:16.000000000 +0100
@@ -15,9 +15,9 @@
 #define pgtable_cache_size (0L)
 
 /* Allocation and deallocation of various flavours of pagetables. */
-extern inline int free_pmd_fast (pmd_t *pmdp) { return 0; }
-extern inline int free_pmd_slow (pmd_t *pmdp) { return 0; }
-extern inline pmd_t *get_pmd_fast (void) { return (pmd_t *) 0; }
+static inline int free_pmd_fast (pmd_t *pmdp) { return 0; }
+static inline int free_pmd_slow (pmd_t *pmdp) { return 0; }
+static inline pmd_t *get_pmd_fast (void) { return (pmd_t *) 0; }
 
 //todo: implement the following properly.
 #define get_pte_fast() ((pte_t *) 0)
@@ -29,14 +29,14 @@
 /* erm, now that it's compiling, what do we do with it? */
 #define _KERNPG_TABLE 0
 
-extern inline void pte_free_kernel(pte_t * pte)
+static inline void pte_free_kernel(pte_t * pte)
 {
         free_page((unsigned long) pte);
 }
 
 extern const char bad_pmd_string[];
 
-extern inline pte_t * pte_alloc_kernel(pmd_t * pmd, unsigned long address)
+static inline pte_t * pte_alloc_kernel(pmd_t * pmd, unsigned long address)
 {
         address = (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);
         if (pmd_none(*pmd)) {
@@ -64,12 +64,12 @@
  * allocating and freeing a pmd is trivial: the 1-entry pmd is
  * inside the pgd, so has no extra memory associated with it.
  */
-extern inline void pmd_free_kernel(pmd_t * pmd)
+static inline void pmd_free_kernel(pmd_t * pmd)
 {
 //        pmd_val(*pmd) = 0;
 }
 
-extern inline pmd_t * pmd_alloc_kernel(pgd_t * pgd, unsigned long address)
+static inline pmd_t * pmd_alloc_kernel(pgd_t * pgd, unsigned long address)
 {
         return (pmd_t *) pgd;
 }
@@ -77,7 +77,7 @@
 #define pmd_alloc_one_fast(mm, address) ({ BUG(); ((pmd_t *)1); })
 #define pmd_alloc_one(mm,address)       ({ BUG(); ((pmd_t *)2); })
 
-extern inline void pte_free(pte_t * pte)
+static inline void pte_free(pte_t * pte)
 {
         free_page((unsigned long) pte);
 }
@@ -103,17 +103,17 @@
  * allocating and freeing a pmd is trivial: the 1-entry pmd is
  * inside the pgd, so has no extra memory associated with it.
  */
-extern inline void pmd_free(pmd_t * pmd)
+static inline void pmd_free(pmd_t * pmd)
 {
         pmd_val(*pmd) = 0;
 }
 
-extern inline void pgd_free(pgd_t * pgd)
+static inline void pgd_free(pgd_t * pgd)
 {
         free_page((unsigned long) pgd);
 }
 
-extern inline pgd_t * pgd_alloc(struct mm_struct *mm)
+static inline pgd_t * pgd_alloc(struct mm_struct *mm)
 {
      pgd_t *new_pgd;
 
@@ -130,7 +130,7 @@
 
 extern int do_check_pgt_cache(int, int);
 
-extern inline void set_pgdir(unsigned long address, pgd_t entry)
+static inline void set_pgdir(unsigned long address, pgd_t entry)
 {
 }
 
@@ -247,7 +247,7 @@
 	sun3_put_segmap (addr & ~(SUN3_PMEG_SIZE - 1), SUN3_INVALID_PMEG);
 }
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
 				      unsigned long start, unsigned long end)
 {
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/sun3_pgtable.h linux-2.4.20-kfi/include/asm-m68k/sun3_pgtable.h
--- linux-2.4.20-std/include/asm-m68k/sun3_pgtable.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/sun3_pgtable.h	2004-12-30 22:15:16.000000000 +0100
@@ -104,12 +104,12 @@
 #define mk_pte(page, pgprot) __mk_pte(page_address(page), (pgprot))
 #define mk_pte_phys(physpage, pgprot) \
 ({ pte_t __pte; pte_val(__pte) = ((physpage) >> PAGE_SHIFT) | pgprot_val(pgprot); __pte; })
-extern inline pte_t pte_modify (pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify (pte_t pte, pgprot_t newprot)
 { pte_val(pte) = (pte_val(pte) & SUN3_PAGE_CHG_MASK) | pgprot_val(newprot); return pte; }
 
 #define pmd_set(pmdp,ptep) do {} while (0)
 
-extern inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
+static inline void pgd_set(pgd_t * pgdp, pmd_t * pmdp)
 { pgd_val(*pgdp) = virt_to_phys(pmdp); }
 
 #define __pte_page(pte) \
@@ -117,29 +117,29 @@
 #define __pmd_page(pmd) \
 ((unsigned long) __va (pmd_val (pmd) & PAGE_MASK))
 
-extern inline int pte_none (pte_t pte) { return !pte_val (pte); }
-extern inline int pte_present (pte_t pte) { return pte_val (pte) & SUN3_PAGE_VALID; }
-extern inline void pte_clear (pte_t *ptep) { pte_val (*ptep) = 0; }
+static inline int pte_none (pte_t pte) { return !pte_val (pte); }
+static inline int pte_present (pte_t pte) { return pte_val (pte) & SUN3_PAGE_VALID; }
+static inline void pte_clear (pte_t *ptep) { pte_val (*ptep) = 0; }
 
 /* FIXME: this is only a guess */
 #define pte_pagenr(pte)		((__pte_page(pte) - PAGE_OFFSET) >> PAGE_SHIFT)
 #define pte_page(pte)		(mem_map+pte_pagenr(pte))
 
 
-extern inline int pmd_none2 (pmd_t *pmd) { return !pmd_val (*pmd); }
+static inline int pmd_none2 (pmd_t *pmd) { return !pmd_val (*pmd); }
 #define pmd_none(pmd) pmd_none2(&(pmd))
-//extern inline int pmd_bad (pmd_t pmd) { return (pmd_val (pmd) & SUN3_PMD_MASK) != SUN3_PMD_MAGIC; }
-extern inline int pmd_bad2 (pmd_t *pmd) { return 0; }
+//static inline int pmd_bad (pmd_t pmd) { return (pmd_val (pmd) & SUN3_PMD_MASK) != SUN3_PMD_MAGIC; }
+static inline int pmd_bad2 (pmd_t *pmd) { return 0; }
 #define pmd_bad(pmd) pmd_bad2(&(pmd))
-extern inline int pmd_present2 (pmd_t *pmd) { return pmd_val (*pmd) & SUN3_PMD_VALID; }
+static inline int pmd_present2 (pmd_t *pmd) { return pmd_val (*pmd) & SUN3_PMD_VALID; }
 /* #define pmd_present(pmd) pmd_present2(&(pmd)) */
 #define pmd_present(pmd) (!pmd_none2(&(pmd)))
-extern inline void pmd_clear (pmd_t *pmdp) { pmd_val (*pmdp) = 0; }
+static inline void pmd_clear (pmd_t *pmdp) { pmd_val (*pmdp) = 0; }
 
-extern inline int pgd_none (pgd_t pgd) { return 0; }
-extern inline int pgd_bad (pgd_t pgd) { return 0; }
-extern inline int pgd_present (pgd_t pgd) { return 1; }
-extern inline void pgd_clear (pgd_t *pgdp) {}
+static inline int pgd_none (pgd_t pgd) { return 0; }
+static inline int pgd_bad (pgd_t pgd) { return 0; }
+static inline int pgd_present (pgd_t pgd) { return 1; }
+static inline void pgd_clear (pgd_t *pgdp) {}
 
 
 #define pte_ERROR(e) \
@@ -155,27 +155,27 @@
  * Undefined behaviour if not...
  * [we have the full set here even if they don't change from m68k]
  */
-extern inline int pte_read(pte_t pte)		{ return 1; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_WRITEABLE; }
-extern inline int pte_exec(pte_t pte)		{ return 1; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_MODIFIED; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_ACCESSED; }
-
-extern inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_WRITEABLE; return pte; }
-extern inline pte_t pte_rdprotect(pte_t pte)	{ return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_MODIFIED; return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_WRITEABLE; return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_MODIFIED; return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mknocache(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_NOCACHE; return pte; }
+static inline int pte_read(pte_t pte)		{ return 1; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_WRITEABLE; }
+static inline int pte_exec(pte_t pte)		{ return 1; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_MODIFIED; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & SUN3_PAGE_ACCESSED; }
+
+static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_WRITEABLE; return pte; }
+static inline pte_t pte_rdprotect(pte_t pte)	{ return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_MODIFIED; return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~SUN3_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_WRITEABLE; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_MODIFIED; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mknocache(pte_t pte)	{ pte_val(pte) |= SUN3_PAGE_NOCACHE; return pte; }
 // use this version when caches work...
-//extern inline pte_t pte_mkcache(pte_t pte)	{ pte_val(pte) &= SUN3_PAGE_NOCACHE; return pte; }
+//static inline pte_t pte_mkcache(pte_t pte)	{ pte_val(pte) &= SUN3_PAGE_NOCACHE; return pte; }
 // until then, use:
-extern inline pte_t pte_mkcache(pte_t pte)	{ return pte; }
+static inline pte_t pte_mkcache(pte_t pte)	{ return pte; }
 
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 extern pgd_t kernel_pg_dir[PTRS_PER_PGD];
@@ -190,7 +190,7 @@
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
 
 /* Find an entry in the second-level pagetable. */
-extern inline pmd_t *pmd_offset (pgd_t *pgd, unsigned long address)
+static inline pmd_t *pmd_offset (pgd_t *pgd, unsigned long address)
 {
 	return (pmd_t *) pgd;
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/sun3mmu.h linux-2.4.20-kfi/include/asm-m68k/sun3mmu.h
--- linux-2.4.20-std/include/asm-m68k/sun3mmu.h	1999-09-04 22:06:41.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/sun3mmu.h	2004-12-30 22:15:16.000000000 +0100
@@ -69,7 +69,7 @@
 #ifndef __ASSEMBLY__
 
 /* Read bus error status register (implicitly clearing it). */
-extern __inline__ unsigned char sun3_get_buserr (void)
+static __inline__ unsigned char sun3_get_buserr (void)
 {
 	unsigned char sfc, c;
 
@@ -82,7 +82,7 @@
 }
 
 /* Read segmap from hardware MMU. */
-extern __inline__ unsigned long sun3_get_segmap (unsigned long addr)
+static __inline__ unsigned long sun3_get_segmap (unsigned long addr)
 {
         register unsigned long entry;
         unsigned char c, sfc;
@@ -97,7 +97,7 @@
 }
 
 /* Write segmap to hardware MMU. */
-extern __inline__ void sun3_put_segmap (unsigned long addr, unsigned long entry)
+static __inline__ void sun3_put_segmap (unsigned long addr, unsigned long entry)
 {
         unsigned char sfc;
 
@@ -110,7 +110,7 @@
 }
 
 /* Read PTE from hardware MMU. */
-extern __inline__ unsigned long sun3_get_pte (unsigned long addr)
+static __inline__ unsigned long sun3_get_pte (unsigned long addr)
 {
         register unsigned long entry;
         unsigned char sfc;
@@ -124,7 +124,7 @@
 }
 
 /* Write PTE to hardware MMU. */
-extern __inline__ void sun3_put_pte (unsigned long addr, unsigned long entry)
+static __inline__ void sun3_put_pte (unsigned long addr, unsigned long entry)
 {
         unsigned char sfc;
 
@@ -137,7 +137,7 @@
 }
 
 /* get current context */
-extern __inline__ unsigned char sun3_get_context(void)
+static __inline__ unsigned char sun3_get_context(void)
 {
 	unsigned char sfc, c;
 
@@ -150,7 +150,7 @@
 }
 
 /* set alternate context */
-extern __inline__ void sun3_put_context(unsigned char c)
+static __inline__ void sun3_put_context(unsigned char c)
 {
 	unsigned char dfc;
 	GET_DFC(dfc);
diff -rbNu linux-2.4.20-std/include/asm-m68k/uaccess.h linux-2.4.20-kfi/include/asm-m68k/uaccess.h
--- linux-2.4.20-std/include/asm-m68k/uaccess.h	2001-10-25 22:53:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/uaccess.h	2004-12-30 22:15:16.000000000 +0100
@@ -13,7 +13,7 @@
 /* We let the MMU do all checking */
 #define access_ok(type,addr,size) 1
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size)?0:-EFAULT;
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/virtconvert.h linux-2.4.20-kfi/include/asm-m68k/virtconvert.h
--- linux-2.4.20-std/include/asm-m68k/virtconvert.h	2000-01-26 21:44:21.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-m68k/virtconvert.h	2004-12-30 22:15:16.000000000 +0100
@@ -23,19 +23,19 @@
 extern unsigned long mm_vtop_fallback (unsigned long) __attribute__ ((const));
 extern unsigned long mm_ptov(unsigned long addr) __attribute__ ((const));
 #else
-extern inline unsigned long mm_vtop(unsigned long vaddr)
+static inline unsigned long mm_vtop(unsigned long vaddr)
 {
 	return __pa(vaddr);
 }
 
-extern inline unsigned long mm_ptov(unsigned long paddr)
+static inline unsigned long mm_ptov(unsigned long paddr)
 {
 	return (unsigned long)__va(paddr);
 }
 #endif 
 
 #ifdef CONFIG_SINGLE_MEMORY_CHUNK
-extern inline unsigned long virt_to_phys(volatile void *vaddr)
+static inline unsigned long virt_to_phys(volatile void *vaddr)
 {
 	unsigned long voff = (unsigned long)vaddr - PAGE_OFFSET;
 
@@ -44,7 +44,7 @@
 	return mm_vtop_fallback((unsigned long)vaddr);
 }
 
-extern inline void * phys_to_virt(unsigned long paddr)
+static inline void * phys_to_virt(unsigned long paddr)
 {
 	unsigned long poff = paddr - m68k_memory[0].addr;
 
@@ -62,12 +62,12 @@
 	return (void *)paddr;
 }
 #else
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return mm_vtop((unsigned long)address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return (void *) mm_ptov(address);
 }
diff -rbNu linux-2.4.20-std/include/asm-m68k/zorro.h linux-2.4.20-kfi/include/asm-m68k/zorro.h
--- linux-2.4.20-std/include/asm-m68k/zorro.h	2001-10-25 22:53:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-m68k/zorro.h	2004-12-30 22:15:16.000000000 +0100
@@ -30,24 +30,24 @@
 extern void __iounmap(void *addr, unsigned long size);
 
 
-extern inline void *z_remap_nocache_ser(unsigned long physaddr, 
+static inline void *z_remap_nocache_ser(unsigned long physaddr, 
 					  unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
 
-extern inline void *z_remap_nocache_nonser(unsigned long physaddr, 
+static inline void *z_remap_nocache_nonser(unsigned long physaddr, 
 					     unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_NONSER);
 }
 
-extern inline void *z_remap_writethrough(unsigned long physaddr,
+static inline void *z_remap_writethrough(unsigned long physaddr,
 					   unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
 }
-extern inline void *z_remap_fullcache(unsigned long physaddr,
+static inline void *z_remap_fullcache(unsigned long physaddr,
 					unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
diff -rbNu linux-2.4.20-std/include/asm-mips/atomic.h linux-2.4.20-kfi/include/asm-mips/atomic.h
--- linux-2.4.20-std/include/asm-mips/atomic.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/atomic.h	2004-12-30 22:15:15.000000000 +0100
@@ -55,7 +55,7 @@
  * Atomically adds @i to @v.  Note that the guaranteed useful range
  * of an atomic_t is only 24 bits.
  */
-extern __inline__ void atomic_add(int i, atomic_t * v)
+static __inline__ void atomic_add(int i, atomic_t * v)
 {
 	unsigned long flags;
 
@@ -72,7 +72,7 @@
  * Atomically subtracts @i from @v.  Note that the guaranteed
  * useful range of an atomic_t is only 24 bits.
  */
-extern __inline__ void atomic_sub(int i, atomic_t * v)
+static __inline__ void atomic_sub(int i, atomic_t * v)
 {
 	unsigned long flags;
 
@@ -81,7 +81,7 @@
 	restore_flags(flags);
 }
 
-extern __inline__ int atomic_add_return(int i, atomic_t * v)
+static __inline__ int atomic_add_return(int i, atomic_t * v)
 {
 	unsigned long flags;
 	int temp;
@@ -95,7 +95,7 @@
 	return temp;
 }
 
-extern __inline__ int atomic_sub_return(int i, atomic_t * v)
+static __inline__ int atomic_sub_return(int i, atomic_t * v)
 {
 	unsigned long flags;
 	int temp;
@@ -124,7 +124,7 @@
  * Atomically adds @i to @v.  Note that the guaranteed useful range
  * of an atomic_t is only 24 bits.
  */
-extern __inline__ void atomic_add(int i, atomic_t * v)
+static __inline__ void atomic_add(int i, atomic_t * v)
 {
 	unsigned long temp;
 
@@ -145,7 +145,7 @@
  * Atomically subtracts @i from @v.  Note that the guaranteed
  * useful range of an atomic_t is only 24 bits.
  */
-extern __inline__ void atomic_sub(int i, atomic_t * v)
+static __inline__ void atomic_sub(int i, atomic_t * v)
 {
 	unsigned long temp;
 
@@ -161,7 +161,7 @@
 /*
  * Same as above, but return the result value
  */
-extern __inline__ int atomic_add_return(int i, atomic_t * v)
+static __inline__ int atomic_add_return(int i, atomic_t * v)
 {
 	unsigned long temp, result;
 
@@ -182,7 +182,7 @@
 	return result;
 }
 
-extern __inline__ int atomic_sub_return(int i, atomic_t * v)
+static __inline__ int atomic_sub_return(int i, atomic_t * v)
 {
 	unsigned long temp, result;
 
diff -rbNu linux-2.4.20-std/include/asm-mips/bitops.h linux-2.4.20-kfi/include/asm-mips/bitops.h
--- linux-2.4.20-std/include/asm-mips/bitops.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/bitops.h	2004-12-30 22:15:15.000000000 +0100
@@ -58,7 +58,7 @@
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  */
-extern __inline__ void
+static __inline__ void
 set_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -82,7 +82,7 @@
  * If it's called on the same region of memory simultaneously, the effect
  * may be that only one operation succeeds.
  */
-extern __inline__ void __set_bit(int nr, volatile void * addr)
+static __inline__ void __set_bit(int nr, volatile void * addr)
 {
 	unsigned long * m = ((unsigned long *) addr) + (nr >> 5);
 
@@ -99,7 +99,7 @@
  * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
  * in order to ensure changes are visible on other processors.
  */
-extern __inline__ void
+static __inline__ void
 clear_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -123,7 +123,7 @@
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  */
-extern __inline__ void
+static __inline__ void
 change_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -147,7 +147,7 @@
  * If it's called on the same region of memory simultaneously, the effect
  * may be that only one operation succeeds.
  */
-extern __inline__ void __change_bit(int nr, volatile void * addr)
+static __inline__ void __change_bit(int nr, volatile void * addr)
 {
 	unsigned long * m = ((unsigned long *) addr) + (nr >> 5);
 
@@ -162,7 +162,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int
+static __inline__ int
 test_and_set_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -195,7 +195,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_set_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_set_bit(int nr, volatile void * addr)
 {
 	int mask, retval;
 	volatile int *a = addr;
@@ -216,7 +216,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int
+static __inline__ int
 test_and_clear_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -250,7 +250,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -271,7 +271,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int
+static __inline__ int
 test_and_change_bit(int nr, volatile void *addr)
 {
 	unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
@@ -304,7 +304,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_change_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_change_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -329,7 +329,7 @@
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  */
-extern __inline__ void set_bit(int nr, volatile void * addr)
+static __inline__ void set_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile int	*a = addr;
@@ -351,7 +351,7 @@
  * If it's called on the same region of memory simultaneously, the effect
  * may be that only one operation succeeds.
  */
-extern __inline__ void __set_bit(int nr, volatile void * addr)
+static __inline__ void __set_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile int	*a = addr;
@@ -371,7 +371,7 @@
  * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
  * in order to ensure changes are visible on other processors.
  */
-extern __inline__ void clear_bit(int nr, volatile void * addr)
+static __inline__ void clear_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile int	*a = addr;
@@ -393,7 +393,7 @@
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  */
-extern __inline__ void change_bit(int nr, volatile void * addr)
+static __inline__ void change_bit(int nr, volatile void * addr)
 {
 	int	mask;
 	volatile int	*a = addr;
@@ -415,7 +415,7 @@
  * If it's called on the same region of memory simultaneously, the effect
  * may be that only one operation succeeds.
  */
-extern __inline__ void __change_bit(int nr, volatile void * addr)
+static __inline__ void __change_bit(int nr, volatile void * addr)
 {
 	unsigned long * m = ((unsigned long *) addr) + (nr >> 5);
 
@@ -430,7 +430,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int test_and_set_bit(int nr, volatile void * addr)
+static __inline__ int test_and_set_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -455,7 +455,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_set_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_set_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -476,7 +476,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int test_and_clear_bit(int nr, volatile void * addr)
+static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -501,7 +501,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -522,7 +522,7 @@
  * This operation is atomic and cannot be reordered.
  * It also implies a memory barrier.
  */
-extern __inline__ int test_and_change_bit(int nr, volatile void * addr)
+static __inline__ int test_and_change_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -547,7 +547,7 @@
  * If two examples of this operation race, one can appear to succeed
  * but actually fail.  You must protect multiple accesses with a lock.
  */
-extern __inline__ int __test_and_change_bit(int nr, volatile void * addr)
+static __inline__ int __test_and_change_bit(int nr, volatile void * addr)
 {
 	int	mask, retval;
 	volatile int	*a = addr;
@@ -572,7 +572,7 @@
  * @nr: bit number to test
  * @addr: Address to start counting from
  */
-extern __inline__ int test_bit(int nr, volatile void *addr)
+static __inline__ int test_bit(int nr, volatile void *addr)
 {
 	return ((1UL << (nr & 31)) & (((const unsigned int *) addr)[nr >> 5])) != 0;
 }
@@ -589,7 +589,7 @@
  * Returns the bit-number of the first zero bit, not the number of the byte
  * containing a bit.
  */
-extern __inline__ int find_first_zero_bit (void *addr, unsigned size)
+static __inline__ int find_first_zero_bit (void *addr, unsigned size)
 {
 	unsigned long dummy;
 	int res;
@@ -639,7 +639,7 @@
  * @offset: The bitnumber to start searching at
  * @size: The maximum size to search
  */
-extern __inline__ int find_next_zero_bit (void * addr, int size, int offset)
+static __inline__ int find_next_zero_bit (void * addr, int size, int offset)
 {
 	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
 	int set = 0, bit = offset & 31, res;
@@ -732,7 +732,7 @@
  * @offset: The bitnumber to start searching at
  * @size: The maximum size to search
  */
-extern __inline__ int find_next_zero_bit(void *addr, int size, int offset)
+static __inline__ int find_next_zero_bit(void *addr, int size, int offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
@@ -792,7 +792,7 @@
 /* Now for the ext2 filesystem bit operations and helper routines. */
 
 #ifdef __MIPSEB__
-extern __inline__ int ext2_set_bit(int nr, void * addr)
+static __inline__ int ext2_set_bit(int nr, void * addr)
 {
 	int		mask, retval, flags;
 	unsigned char	*ADDR = (unsigned char *) addr;
@@ -806,7 +806,7 @@
 	return retval;
 }
 
-extern __inline__ int ext2_clear_bit(int nr, void * addr)
+static __inline__ int ext2_clear_bit(int nr, void * addr)
 {
 	int		mask, retval, flags;
 	unsigned char	*ADDR = (unsigned char *) addr;
@@ -820,7 +820,7 @@
 	return retval;
 }
 
-extern __inline__ int ext2_test_bit(int nr, const void * addr)
+static __inline__ int ext2_test_bit(int nr, const void * addr)
 {
 	int			mask;
 	const unsigned char	*ADDR = (const unsigned char *) addr;
@@ -833,7 +833,7 @@
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+static __inline__ unsigned long ext2_find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
diff -rbNu linux-2.4.20-std/include/asm-mips/delay.h linux-2.4.20-kfi/include/asm-mips/delay.h
--- linux-2.4.20-std/include/asm-mips/delay.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/delay.h	2004-12-30 22:15:15.000000000 +0100
@@ -14,7 +14,7 @@
 
 extern unsigned long loops_per_jiffy;
 
-extern __inline__ void
+static __inline__ void
 __delay(unsigned long loops)
 {
 	__asm__ __volatile__ (
@@ -36,7 +36,7 @@
  * first constant multiplications gets optimized away if the delay is
  * a constant)
  */
-extern __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
+static __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
 {
 	unsigned long lo;
 
diff -rbNu linux-2.4.20-std/include/asm-mips/jazz.h linux-2.4.20-kfi/include/asm-mips/jazz.h
--- linux-2.4.20-std/include/asm-mips/jazz.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-mips/jazz.h	2004-12-30 22:15:16.000000000 +0100
@@ -72,7 +72,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ void pica_set_led(unsigned int bits)
+static __inline__ void pica_set_led(unsigned int bits)
 {
 	volatile unsigned int *led_register = (unsigned int *) PICA_LED;
 
diff -rbNu linux-2.4.20-std/include/asm-mips/jmr3927/jmr3927.h linux-2.4.20-kfi/include/asm-mips/jmr3927/jmr3927.h
--- linux-2.4.20-std/include/asm-mips/jmr3927/jmr3927.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-mips/jmr3927/jmr3927.h	2004-12-30 22:15:16.000000000 +0100
@@ -161,7 +161,7 @@
 #define jmr3927_isac_reg_out(d, a)	((*(volatile unsigned char *)(a)) = (d))
 #define jmr3927_isac_reg_in(a)		(*(volatile unsigned char *)(a))
 
-extern inline int jmr3927_have_isac(void)
+static inline int jmr3927_have_isac(void)
 {
 	unsigned char idt;
 	unsigned long flags;
diff -rbNu linux-2.4.20-std/include/asm-mips/page.h linux-2.4.20-kfi/include/asm-mips/page.h
--- linux-2.4.20-std/include/asm-mips/page.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/page.h	2004-12-30 22:15:15.000000000 +0100
@@ -92,7 +92,7 @@
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-mips/pgalloc.h linux-2.4.20-kfi/include/asm-mips/pgalloc.h
--- linux-2.4.20-std/include/asm-mips/pgalloc.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-mips/pgalloc.h	2004-12-30 22:15:16.000000000 +0100
@@ -67,7 +67,7 @@
  */
 extern void pgd_init(unsigned long page);
 
-extern __inline__ pgd_t *get_pgd_slow(void)
+static __inline__ pgd_t *get_pgd_slow(void)
 {
 	pgd_t *ret = (pgd_t *)__get_free_pages(GFP_KERNEL, PGD_ORDER), *init;
 
@@ -80,7 +80,7 @@
 	return ret;
 }
 
-extern __inline__ pgd_t *get_pgd_fast(void)
+static __inline__ pgd_t *get_pgd_fast(void)
 {
 	unsigned long *ret;
 
@@ -93,19 +93,19 @@
 	return (pgd_t *)ret;
 }
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
 	*(unsigned long *)pgd = (unsigned long) pgd_quicklist;
 	pgd_quicklist = (unsigned long *) pgd;
 	pgtable_cache_size++;
 }
 
-extern __inline__ void free_pgd_slow(pgd_t *pgd)
+static __inline__ void free_pgd_slow(pgd_t *pgd)
 {
 	free_pages((unsigned long)pgd, PGD_ORDER);
 }
 
-extern __inline__ pte_t *get_pte_fast(void)
+static __inline__ pte_t *get_pte_fast(void)
 {
 	unsigned long *ret;
 
@@ -117,29 +117,29 @@
 	return (pte_t *)ret;
 }
 
-extern __inline__ void free_pte_fast(pte_t *pte)
+static __inline__ void free_pte_fast(pte_t *pte)
 {
 	*(unsigned long *)pte = (unsigned long) pte_quicklist;
 	pte_quicklist = (unsigned long *) pte;
 	pgtable_cache_size++;
 }
 
-extern __inline__ void free_pte_slow(pte_t *pte)
+static __inline__ void free_pte_slow(pte_t *pte)
 {
 	free_page((unsigned long)pte);
 }
 
 /* We don't use pmd cache, so these are dummy routines */
-extern __inline__ pmd_t *get_pmd_fast(void)
+static __inline__ pmd_t *get_pmd_fast(void)
 {
 	return (pmd_t *)0;
 }
 
-extern __inline__ void free_pmd_fast(pmd_t *pmd)
+static __inline__ void free_pmd_fast(pmd_t *pmd)
 {
 }
 
-extern __inline__ void free_pmd_slow(pmd_t *pmd)
+static __inline__ void free_pmd_slow(pmd_t *pmd)
 {
 }
 
@@ -167,14 +167,14 @@
 	return (pte_t *)ret;
 }
 
-extern __inline__ void pte_free_fast(pte_t *pte)
+static __inline__ void pte_free_fast(pte_t *pte)
 {
 	*(unsigned long *)pte = (unsigned long) pte_quicklist;
 	pte_quicklist = (unsigned long *) pte;
 	pgtable_cache_size++;
 }
 
-extern __inline__ void pte_free_slow(pte_t *pte)
+static __inline__ void pte_free_slow(pte_t *pte)
 {
 	free_page((unsigned long)pte);
 }
diff -rbNu linux-2.4.20-std/include/asm-mips/sibyte/64bit.h linux-2.4.20-kfi/include/asm-mips/sibyte/64bit.h
--- linux-2.4.20-std/include/asm-mips/sibyte/64bit.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/sibyte/64bit.h	2004-12-30 22:15:16.000000000 +0100
@@ -83,12 +83,12 @@
  * These are provided so as to be able to use common
  * driver code for the 32-bit and 64-bit trees
  */
-extern inline void out64(u64 val, unsigned long addr)
+static inline void out64(u64 val, unsigned long addr)
 {
 	*(volatile unsigned long *)addr = val;
 }
 
-extern inline u64 in64(unsigned long addr)
+static inline u64 in64(unsigned long addr)
 {
 	return *(volatile unsigned long *)addr;
 }
diff -rbNu linux-2.4.20-std/include/asm-mips/smplock.h linux-2.4.20-kfi/include/asm-mips/smplock.h
--- linux-2.4.20-std/include/asm-mips/smplock.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-mips/smplock.h	2004-12-30 22:15:16.000000000 +0100
@@ -40,13 +40,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 	if (!++current->lock_depth)
 		spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (--current->lock_depth < 0)
 		spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-mips/string.h linux-2.4.20-kfi/include/asm-mips/string.h
--- linux-2.4.20-std/include/asm-mips/string.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/string.h	2004-12-30 22:15:15.000000000 +0100
@@ -12,7 +12,7 @@
 #include <linux/config.h>
 
 #define __HAVE_ARCH_STRCPY
-extern __inline__ char *strcpy(char *__dest, __const__ char *__src)
+static __inline__ char *strcpy(char *__dest, __const__ char *__src)
 {
   char *__xdest = __dest;
 
@@ -34,7 +34,7 @@
 }
 
 #define __HAVE_ARCH_STRNCPY
-extern __inline__ char *strncpy(char *__dest, __const__ char *__src, size_t __n)
+static __inline__ char *strncpy(char *__dest, __const__ char *__src, size_t __n)
 {
   char *__xdest = __dest;
 
@@ -62,7 +62,7 @@
 }
 
 #define __HAVE_ARCH_STRCMP
-extern __inline__ int strcmp(__const__ char *__cs, __const__ char *__ct)
+static __inline__ int strcmp(__const__ char *__cs, __const__ char *__ct)
 {
   int __res;
 
@@ -90,7 +90,7 @@
 }
 
 #define __HAVE_ARCH_STRNCMP
-extern __inline__ int
+static __inline__ int
 strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
 {
 	int __res;
@@ -133,7 +133,7 @@
 #define __HAVE_ARCH_BCOPY
 
 #define __HAVE_ARCH_MEMSCAN
-extern __inline__ void *memscan(void *__addr, int __c, size_t __size)
+static __inline__ void *memscan(void *__addr, int __c, size_t __size)
 {
 	char *__end = (char *)__addr + __size;
 	unsigned char __uc = (unsigned char) __c;
diff -rbNu linux-2.4.20-std/include/asm-mips/system.h linux-2.4.20-kfi/include/asm-mips/system.h
--- linux-2.4.20-std/include/asm-mips/system.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips/system.h	2004-12-30 22:15:15.000000000 +0100
@@ -36,7 +36,7 @@
 	".set\tpop\n\t"
 	".endm");
 
-extern __inline__ void
+static __inline__ void
 __sti(void)
 {
 	__asm__ __volatile__(
@@ -68,7 +68,7 @@
 	".set\tpop\n\t"
 	".endm");
 
-extern __inline__ void
+static __inline__ void
 __cli(void)
 {
 	__asm__ __volatile__(
@@ -264,7 +264,7 @@
  * For 32 and 64 bit operands we can take advantage of ll and sc.
  * FIXME: This doesn't work for R3000 machines.
  */
-extern __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
+static __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
 {
 #ifdef CONFIG_CPU_HAS_LLSC
 	unsigned long dummy;
diff -rbNu linux-2.4.20-std/include/asm-mips64/atomic.h linux-2.4.20-kfi/include/asm-mips64/atomic.h
--- linux-2.4.20-std/include/asm-mips64/atomic.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-mips64/atomic.h	2004-12-30 22:15:21.000000000 +0100
@@ -40,7 +40,7 @@
  */
 #define atomic_set(v,i)	((v)->counter = (i))
 
-extern __inline__ void atomic_add(int i, volatile atomic_t * v)
+static __inline__ void atomic_add(int i, volatile atomic_t * v)
 {
 	unsigned long temp;
 
@@ -61,7 +61,7 @@
  * Atomically subtracts @i from @v.  Note that the guaranteed
  * useful range of an atomic_t is only 24 bits.
  */
-extern __inline__ void atomic_sub(int i, volatile atomic_t * v)
+static __inline__ void atomic_sub(int i, volatile atomic_t * v)
 {
 	unsigned long temp;
 
@@ -77,7 +77,7 @@
 /*
  * Same as above, but return the result value
  */
-extern __inline__ int atomic_add_return(int i, atomic_t * v)
+static __inline__ int atomic_add_return(int i, atomic_t * v)
 {
 	unsigned long temp, result;
 
@@ -97,7 +97,7 @@
 	return result;
 }
 
-extern __inline__ int atomic_sub_return(int i, atomic_t * v)
+static __inline__ int atomic_sub_return(int i, atomic_t * v)
 {
 	unsigned long temp, result;
 
diff -rbNu linux-2.4.20-std/include/asm-mips64/delay.h linux-2.4.20-kfi/include/asm-mips64/delay.h
--- linux-2.4.20-std/include/asm-mips64/delay.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips64/delay.h	2004-12-30 22:15:20.000000000 +0100
@@ -15,7 +15,7 @@
 
 extern unsigned long loops_per_jiffy;
 
-extern __inline__ void
+static __inline__ void
 __delay(unsigned long loops)
 {
 	__asm__ __volatile__ (
@@ -37,7 +37,7 @@
  * first constant multiplications gets optimized away if the delay is
  * a constant)
  */
-extern __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
+static __inline__ void __udelay(unsigned long usecs, unsigned long lpj)
 {
 	unsigned long lo;
 
diff -rbNu linux-2.4.20-std/include/asm-mips64/page.h linux-2.4.20-kfi/include/asm-mips64/page.h
--- linux-2.4.20-std/include/asm-mips64/page.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips64/page.h	2004-12-30 22:15:20.000000000 +0100
@@ -63,7 +63,7 @@
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-mips64/sibyte/64bit.h linux-2.4.20-kfi/include/asm-mips64/sibyte/64bit.h
--- linux-2.4.20-std/include/asm-mips64/sibyte/64bit.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips64/sibyte/64bit.h	2004-12-30 22:15:20.000000000 +0100
@@ -83,12 +83,12 @@
  * These are provided so as to be able to use common
  * driver code for the 32-bit and 64-bit trees
  */
-extern inline void out64(u64 val, unsigned long addr)
+static inline void out64(u64 val, unsigned long addr)
 {
 	*(volatile unsigned long *)addr = val;
 }
 
-extern inline u64 in64(unsigned long addr)
+static inline u64 in64(unsigned long addr)
 {
 	return *(volatile unsigned long *)addr;
 }
diff -rbNu linux-2.4.20-std/include/asm-mips64/system.h linux-2.4.20-kfi/include/asm-mips64/system.h
--- linux-2.4.20-std/include/asm-mips64/system.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-mips64/system.h	2004-12-30 22:15:20.000000000 +0100
@@ -30,7 +30,7 @@
 	".set\tpop\n\t"
 	".endm");
 
-extern __inline__ void
+static __inline__ void
 __sti(void)
 {
 	__asm__ __volatile__(
@@ -63,7 +63,7 @@
 	".set\tpop\n\t"
 	".endm");
 
-extern __inline__ void
+static __inline__ void
 __cli(void)
 {
 	__asm__ __volatile__(
@@ -244,7 +244,7 @@
 	(last) = resume(prev, next); \
 } while(0)
 
-extern __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
+static __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
 {
 	unsigned long dummy;
 
@@ -266,7 +266,7 @@
 	return val;
 }
 
-extern __inline__ unsigned long xchg_u64(volatile int * m, unsigned long val)
+static __inline__ unsigned long xchg_u64(volatile int * m, unsigned long val)
 {
 	unsigned long dummy;
 
diff -rbNu linux-2.4.20-std/include/asm-parisc/bitops.h linux-2.4.20-kfi/include/asm-parisc/bitops.h
--- linux-2.4.20-std/include/asm-parisc/bitops.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/bitops.h	2004-12-30 22:15:21.000000000 +0100
@@ -193,7 +193,7 @@
 	return !!(*addr & mask);
 }
 
-extern __inline__ unsigned long ffz(unsigned long word)
+static __inline__ unsigned long ffz(unsigned long word)
 {
 	unsigned long result;
 
@@ -301,7 +301,7 @@
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-extern __inline__ unsigned long ext2_find_next_zero_bit(void *addr,
+static __inline__ unsigned long ext2_find_next_zero_bit(void *addr,
 	unsigned long size, unsigned long offset)
 {
 	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
diff -rbNu linux-2.4.20-std/include/asm-parisc/checksum.h linux-2.4.20-kfi/include/asm-parisc/checksum.h
--- linux-2.4.20-std/include/asm-parisc/checksum.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/checksum.h	2004-12-30 22:15:21.000000000 +0100
@@ -44,7 +44,7 @@
  *	If you use these functions directly please don't forget the 
  *	verify_area().
  */
-extern __inline__
+static __inline__
 unsigned int csum_partial_copy_nocheck (const char *src, char *dst,
 					int len, int sum)
 {
diff -rbNu linux-2.4.20-std/include/asm-parisc/io.h linux-2.4.20-kfi/include/asm-parisc/io.h
--- linux-2.4.20-std/include/asm-parisc/io.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/io.h	2004-12-30 22:15:21.000000000 +0100
@@ -22,7 +22,7 @@
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap(unsigned long offset, unsigned long size)
+static inline void * ioremap(unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
@@ -32,7 +32,7 @@
  * it's useful if some control registers are in such an area and write combining
  * or read caching is not desirable:
  */
-extern inline void * ioremap_nocache (unsigned long offset, unsigned long size)
+static inline void * ioremap_nocache (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, _PAGE_NO_CACHE /* _PAGE_PCD */);
 }
@@ -44,7 +44,7 @@
  * too lazy to ioremap first'.  kind of like isa_, except that there's
  * no additional base address to add on.
  */
-extern __inline__ unsigned char __raw_readb(unsigned long addr)
+static __inline__ unsigned char __raw_readb(unsigned long addr)
 {
 	long flags;
 	unsigned char ret;
@@ -58,7 +58,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned short __raw_readw(unsigned long addr)
+static __inline__ unsigned short __raw_readw(unsigned long addr)
 {
 	long flags;
 	unsigned short ret;
@@ -72,7 +72,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned int __raw_readl(unsigned long addr)
+static __inline__ unsigned int __raw_readl(unsigned long addr)
 {
 	u32 ret;
 
@@ -83,7 +83,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned long long __raw_readq(unsigned long addr)
+static __inline__ unsigned long long __raw_readq(unsigned long addr)
 {
 	unsigned long long ret;
 #ifdef __LP64__
@@ -98,7 +98,7 @@
 	return ret;
 }
 
-extern __inline__ void __raw_writeb(unsigned char val, unsigned long addr)
+static __inline__ void __raw_writeb(unsigned char val, unsigned long addr)
 {
 	long flags;
 	__asm__ __volatile__(
@@ -108,7 +108,7 @@
 	: "=&r" (flags) :  "r" (val), "r" (addr) );
 }
 
-extern __inline__ void __raw_writew(unsigned short val, unsigned long addr)
+static __inline__ void __raw_writew(unsigned short val, unsigned long addr)
 {
 	long flags;
 	__asm__ __volatile__(
@@ -118,14 +118,14 @@
 	: "=&r" (flags) :  "r" (val), "r" (addr) );
 }
 
-extern __inline__ void __raw_writel(unsigned int val, unsigned long addr)
+static __inline__ void __raw_writel(unsigned int val, unsigned long addr)
 {
 	__asm__ __volatile__(
 	"	stwas	%0,0(%1)\n"
 	: :  "r" (val), "r" (addr) );
 }
 
-extern __inline__ void __raw_writeq(unsigned long long val, unsigned long addr)
+static __inline__ void __raw_writeq(unsigned long long val, unsigned long addr)
 {
 #ifdef __LP64__
 	__asm__ __volatile__(
diff -rbNu linux-2.4.20-std/include/asm-parisc/page.h linux-2.4.20-kfi/include/asm-parisc/page.h
--- linux-2.4.20-std/include/asm-parisc/page.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/page.h	2004-12-30 22:15:21.000000000 +0100
@@ -51,7 +51,7 @@
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-parisc/parport_gsc.h linux-2.4.20-kfi/include/asm-parisc/parport_gsc.h
--- linux-2.4.20-std/include/asm-parisc/parport_gsc.h	2000-12-05 21:29:39.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/parport_gsc.h	2004-12-30 22:15:21.000000000 +0100
@@ -52,7 +52,7 @@
 	struct pci_dev *dev;
 };
 
-extern __inline__ void parport_gsc_write_data(struct parport *p, unsigned char d)
+static __inline__ void parport_gsc_write_data(struct parport *p, unsigned char d)
 {
 #ifdef DEBUG_PARPORT
 	printk (KERN_DEBUG "parport_gsc_write_data(%p,0x%02x)\n", p, d);
@@ -60,7 +60,7 @@
 	parport_writeb(d, DATA(p));
 }
 
-extern __inline__ unsigned char parport_gsc_read_data(struct parport *p)
+static __inline__ unsigned char parport_gsc_read_data(struct parport *p)
 {
 	unsigned char val = parport_readb (DATA (p));
 #ifdef DEBUG_PARPORT
@@ -90,17 +90,17 @@
 	return ctr;
 }
 
-extern __inline__ void parport_gsc_data_reverse (struct parport *p)
+static __inline__ void parport_gsc_data_reverse (struct parport *p)
 {
 	__parport_gsc_frob_control (p, 0x20, 0x20);
 }
 
-extern __inline__ void parport_gsc_data_forward (struct parport *p)
+static __inline__ void parport_gsc_data_forward (struct parport *p)
 {
 	__parport_gsc_frob_control (p, 0x20, 0x00);
 }
 
-extern __inline__ void parport_gsc_write_control (struct parport *p,
+static __inline__ void parport_gsc_write_control (struct parport *p,
 						 unsigned char d)
 {
 	const unsigned char wm = (PARPORT_CONTROL_STROBE |
@@ -118,7 +118,7 @@
 	__parport_gsc_frob_control (p, wm, d & wm);
 }
 
-extern __inline__ unsigned char parport_gsc_read_control(struct parport *p)
+static __inline__ unsigned char parport_gsc_read_control(struct parport *p)
 {
 	const unsigned char rm = (PARPORT_CONTROL_STROBE |
 				  PARPORT_CONTROL_AUTOFD |
@@ -128,7 +128,7 @@
 	return priv->ctr & rm; /* Use soft copy */
 }
 
-extern __inline__ unsigned char parport_gsc_frob_control (struct parport *p,
+static __inline__ unsigned char parport_gsc_frob_control (struct parport *p,
 							 unsigned char mask,
 							 unsigned char val)
 {
@@ -155,18 +155,18 @@
 	return __parport_gsc_frob_control (p, mask, val);
 }
 
-extern __inline__ unsigned char parport_gsc_read_status(struct parport *p)
+static __inline__ unsigned char parport_gsc_read_status(struct parport *p)
 {
 	return parport_readb (STATUS(p));
 }
 
 
-extern __inline__ void parport_gsc_disable_irq(struct parport *p)
+static __inline__ void parport_gsc_disable_irq(struct parport *p)
 {
 	__parport_gsc_frob_control (p, 0x10, 0x00);
 }
 
-extern __inline__ void parport_gsc_enable_irq(struct parport *p)
+static __inline__ void parport_gsc_enable_irq(struct parport *p)
 {
 	__parport_gsc_frob_control (p, 0x10, 0x10);
 }
diff -rbNu linux-2.4.20-std/include/asm-parisc/pci.h linux-2.4.20-kfi/include/asm-parisc/pci.h
--- linux-2.4.20-std/include/asm-parisc/pci.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/pci.h	2004-12-30 22:15:21.000000000 +0100
@@ -239,7 +239,7 @@
 extern void pcibios_set_master(struct pci_dev *);
 extern void pcibios_assign_unassigned_resources(struct pci_bus *);
 #else
-extern inline void pcibios_register_hba(struct pci_hba_data *x)
+static inline void pcibios_register_hba(struct pci_hba_data *x)
 {
 }
 #endif
diff -rbNu linux-2.4.20-std/include/asm-parisc/pgalloc.h linux-2.4.20-kfi/include/asm-parisc/pgalloc.h
--- linux-2.4.20-std/include/asm-parisc/pgalloc.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/pgalloc.h	2004-12-30 22:15:21.000000000 +0100
@@ -172,7 +172,7 @@
 #endif
 }
 
-extern __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start, unsigned long end)
+static __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start, unsigned long end)
 {
 }
  
diff -rbNu linux-2.4.20-std/include/asm-parisc/pgtable.h linux-2.4.20-kfi/include/asm-parisc/pgtable.h
--- linux-2.4.20-std/include/asm-parisc/pgtable.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/pgtable.h	2004-12-30 22:15:21.000000000 +0100
@@ -244,29 +244,29 @@
  * setup: the pgd is never bad, and a pmd always exists (as it's folded
  * into the pgd entry)
  */
-extern inline int pgd_none(pgd_t pgd)		{ return 0; }
-extern inline int pgd_bad(pgd_t pgd)		{ return 0; }
-extern inline int pgd_present(pgd_t pgd)	{ return 1; }
-extern inline void pgd_clear(pgd_t * pgdp)	{ }
+static inline int pgd_none(pgd_t pgd)		{ return 0; }
+static inline int pgd_bad(pgd_t pgd)		{ return 0; }
+static inline int pgd_present(pgd_t pgd)	{ return 1; }
+static inline void pgd_clear(pgd_t * pgdp)	{ }
 #endif
 
 /*
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_READ; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_WRITE; }
-
-extern inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_READ; return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_WRITE; return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) |= _PAGE_READ; return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= _PAGE_WRITE; return pte; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_READ; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_WRITE; }
+
+static inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_READ; return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_WRITE; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) |= _PAGE_READ; return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= _PAGE_WRITE; return pte; }
 
 /*
  * Conversion functions: convert a page and protection to a page entry,
@@ -303,7 +303,7 @@
 #define mk_pte_phys(physpage, pgprot) \
 ({ pte_t __pte; pte_val(__pte) = physpage + pgprot_val(pgprot); __pte; })
 
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { pte_val(pte) = (pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot); return pte; }
 
 /* Permanent address of a page.  On parisc we don't have highmem. */
diff -rbNu linux-2.4.20-std/include/asm-parisc/processor.h linux-2.4.20-kfi/include/asm-parisc/processor.h
--- linux-2.4.20-std/include/asm-parisc/processor.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/processor.h	2004-12-30 22:15:21.000000000 +0100
@@ -311,13 +311,13 @@
 
 #ifdef  CONFIG_PA20
 #define ARCH_HAS_PREFETCH
-extern inline void prefetch(const void *addr)
+static inline void prefetch(const void *addr)
 {
 	__asm__("ldw 0(%0), %%r0" : : "r" (addr));
 }
 
 #define ARCH_HAS_PREFETCHW
-extern inline void prefetchw(const void *addr)
+static inline void prefetchw(const void *addr)
 {
 	__asm__("ldd 0(%0), %%r0" : : "r" (addr));
 }
diff -rbNu linux-2.4.20-std/include/asm-parisc/semaphore.h linux-2.4.20-kfi/include/asm-parisc/semaphore.h
--- linux-2.4.20-std/include/asm-parisc/semaphore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/semaphore.h	2004-12-30 22:15:21.000000000 +0100
@@ -51,7 +51,7 @@
 #define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
 #define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
 
-extern inline void sema_init (struct semaphore *sem, int val)
+static inline void sema_init (struct semaphore *sem, int val)
 {
 	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
 }
@@ -79,7 +79,7 @@
  * interrupts while we're messing with the semaphore.  Sorry.
  */
 
-extern __inline__ void down(struct semaphore * sem)
+static __inline__ void down(struct semaphore * sem)
 {
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
@@ -94,7 +94,7 @@
 	spin_unlock_irq(&sem->sentry);
 }
 
-extern __inline__ int down_interruptible(struct semaphore * sem)
+static __inline__ int down_interruptible(struct semaphore * sem)
 {
 	int ret = 0;
 #if WAITQUEUE_DEBUG
@@ -115,7 +115,7 @@
  * down_trylock returns 0 on success, 1 if we failed to get the lock.
  * May not sleep, but must preserve irq state
  */
-extern __inline__ int down_trylock(struct semaphore * sem)
+static __inline__ int down_trylock(struct semaphore * sem)
 {
 	int flags, count;
 #if WAITQUEUE_DEBUG
@@ -134,7 +134,7 @@
  * Note! This is subtle. We jump to wake people up only if
  * the semaphore was negative (== somebody was waiting on it).
  */
-extern __inline__ void up(struct semaphore * sem)
+static __inline__ void up(struct semaphore * sem)
 {
 	int flags;
 #if WAITQUEUE_DEBUG
diff -rbNu linux-2.4.20-std/include/asm-parisc/siginfo.h linux-2.4.20-kfi/include/asm-parisc/siginfo.h
--- linux-2.4.20-std/include/asm-parisc/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-parisc/siginfo.h	2004-12-30 22:15:21.000000000 +0100
@@ -219,7 +219,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-parisc/smplock.h linux-2.4.20-kfi/include/asm-parisc/smplock.h
--- linux-2.4.20-std/include/asm-parisc/smplock.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-parisc/smplock.h	2004-12-30 22:15:21.000000000 +0100
@@ -38,13 +38,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 	if (!++current->lock_depth)
 		spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (--current->lock_depth < 0)
 		spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-ppc/byteorder.h linux-2.4.20-kfi/include/asm-ppc/byteorder.h
--- linux-2.4.20-std/include/asm-ppc/byteorder.h	2001-11-03 02:43:54.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/byteorder.h	2004-12-30 22:15:17.000000000 +0100
@@ -9,7 +9,7 @@
 #ifdef __GNUC__
 #ifdef __KERNEL__
 
-extern __inline__ unsigned ld_le16(const volatile unsigned short *addr)
+static __inline__ unsigned ld_le16(const volatile unsigned short *addr)
 {
 	unsigned val;
 
@@ -17,12 +17,12 @@
 	return val;
 }
 
-extern __inline__ void st_le16(volatile unsigned short *addr, const unsigned val)
+static __inline__ void st_le16(volatile unsigned short *addr, const unsigned val)
 {
 	__asm__ __volatile__ ("sthbrx %1,0,%2" : "=m" (*addr) : "r" (val), "r" (addr));
 }
 
-extern __inline__ unsigned ld_le32(const volatile unsigned *addr)
+static __inline__ unsigned ld_le32(const volatile unsigned *addr)
 {
 	unsigned val;
 
@@ -30,7 +30,7 @@
 	return val;
 }
 
-extern __inline__ void st_le32(volatile unsigned *addr, const unsigned val)
+static __inline__ void st_le32(volatile unsigned *addr, const unsigned val)
 {
 	__asm__ __volatile__ ("stwbrx %1,0,%2" : "=m" (*addr) : "r" (val), "r" (addr));
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/delay.h linux-2.4.20-kfi/include/asm-ppc/delay.h
--- linux-2.4.20-std/include/asm-ppc/delay.h	2001-05-22 00:02:06.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/delay.h	2004-12-30 22:15:17.000000000 +0100
@@ -25,7 +25,7 @@
 
 /* N.B. the `secs' parameter here is a fixed-point number with
    the binary point to the left of the most-significant bit. */
-extern __inline__ void __const_udelay(unsigned int secs)
+static __inline__ void __const_udelay(unsigned int secs)
 {
 	unsigned int loops;
 
@@ -38,7 +38,7 @@
  * note that 4294 == 2^32 / 10^6, multiplying by 4294 converts from
  * microseconds to a 32-bit fixed-point number of seconds.
  */
-extern __inline__ void __udelay(unsigned int usecs)
+static __inline__ void __udelay(unsigned int usecs)
 {
 	__const_udelay(usecs * 4294);
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/io.h linux-2.4.20-kfi/include/asm-ppc/io.h
--- linux-2.4.20-std/include/asm-ppc/io.h	2001-11-03 02:43:54.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/io.h	2004-12-30 22:15:17.000000000 +0100
@@ -84,7 +84,7 @@
  * and potentially some CHRPs -- paulus.
  */
 #define __do_in_asm(name, op)				\
-extern __inline__ unsigned int name(unsigned int port)	\
+static __inline__ unsigned int name(unsigned int port)	\
 {							\
 	unsigned int x;					\
 	__asm__ __volatile__(				\
@@ -109,7 +109,7 @@
 }
 
 #define __do_out_asm(name, op)				\
-extern __inline__ void name(unsigned int val, unsigned int port) \
+static __inline__ void name(unsigned int val, unsigned int port) \
 {							\
 	__asm__ __volatile__(				\
 		op " %0,0,%1\n"				\
@@ -203,7 +203,7 @@
  * address from the PCI point of view, thus buffer addresses also
  * have to be modified [mapped] appropriately.
  */
-extern inline unsigned long virt_to_bus(volatile void * address)
+static inline unsigned long virt_to_bus(volatile void * address)
 {
 #ifndef CONFIG_APUS
         if (address == (void *)0)
@@ -214,7 +214,7 @@
 #endif
 }
 
-extern inline void * bus_to_virt(unsigned long address)
+static inline void * bus_to_virt(unsigned long address)
 {
 #ifndef CONFIG_APUS
         if (address == 0)
@@ -229,7 +229,7 @@
  * Change virtual addresses to physical addresses and vv, for
  * addresses in the area where the kernel has the RAM mapped.
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 #ifndef CONFIG_APUS
 	return (unsigned long) address - KERNELBASE;
@@ -238,7 +238,7 @@
 #endif
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 #ifndef CONFIG_APUS
 	return (void *) (address + KERNELBASE);
@@ -260,7 +260,7 @@
  * Acts as a barrier to ensure all previous I/O accesses have
  * completed before any further ones are issued.
  */
-extern inline void eieio(void)
+static inline void eieio(void)
 {
 	__asm__ __volatile__ ("eieio" : : : "memory");
 }
@@ -275,7 +275,7 @@
 /*
  * 8, 16 and 32 bit, big and little endian I/O operations, with barrier.
  */
-extern inline int in_8(volatile unsigned char *addr)
+static inline int in_8(volatile unsigned char *addr)
 {
 	int ret;
 
@@ -283,12 +283,12 @@
 	return ret;
 }
 
-extern inline void out_8(volatile unsigned char *addr, int val)
+static inline void out_8(volatile unsigned char *addr, int val)
 {
 	__asm__ __volatile__("stb%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
 
-extern inline int in_le16(volatile unsigned short *addr)
+static inline int in_le16(volatile unsigned short *addr)
 {
 	int ret;
 
@@ -297,7 +297,7 @@
 	return ret;
 }
 
-extern inline int in_be16(volatile unsigned short *addr)
+static inline int in_be16(volatile unsigned short *addr)
 {
 	int ret;
 
@@ -305,18 +305,18 @@
 	return ret;
 }
 
-extern inline void out_le16(volatile unsigned short *addr, int val)
+static inline void out_le16(volatile unsigned short *addr, int val)
 {
 	__asm__ __volatile__("sthbrx %1,0,%2; eieio" : "=m" (*addr) :
 			      "r" (val), "r" (addr));
 }
 
-extern inline void out_be16(volatile unsigned short *addr, int val)
+static inline void out_be16(volatile unsigned short *addr, int val)
 {
 	__asm__ __volatile__("sth%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
 
-extern inline unsigned in_le32(volatile unsigned *addr)
+static inline unsigned in_le32(volatile unsigned *addr)
 {
 	unsigned ret;
 
@@ -325,7 +325,7 @@
 	return ret;
 }
 
-extern inline unsigned in_be32(volatile unsigned *addr)
+static inline unsigned in_be32(volatile unsigned *addr)
 {
 	unsigned ret;
 
@@ -333,13 +333,13 @@
 	return ret;
 }
 
-extern inline void out_le32(volatile unsigned *addr, int val)
+static inline void out_le32(volatile unsigned *addr, int val)
 {
 	__asm__ __volatile__("stwbrx %1,0,%2; eieio" : "=m" (*addr) :
 			     "r" (val), "r" (addr));
 }
 
-extern inline void out_be32(volatile unsigned *addr, int val)
+static inline void out_be32(volatile unsigned *addr, int val)
 {
 	__asm__ __volatile__("stw%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/open_pic.h linux-2.4.20-kfi/include/asm-ppc/open_pic.h
--- linux-2.4.20-std/include/asm-ppc/open_pic.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/open_pic.h	2004-12-30 22:15:17.000000000 +0100
@@ -54,7 +54,7 @@
 extern void smp_openpic_message_pass(int target, int msg, unsigned long data,
 				     int wait);
 
-extern inline int openpic_to_irq(int irq)
+static inline int openpic_to_irq(int irq)
 {
 	/* IRQ 0 usually means 'disabled'.. don't mess with it 
 	 * exceptions to this (sandpoint maybe?) 
diff -rbNu linux-2.4.20-std/include/asm-ppc/page.h linux-2.4.20-kfi/include/asm-ppc/page.h
--- linux-2.4.20-std/include/asm-ppc/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/page.h	2004-12-30 22:15:17.000000000 +0100
@@ -123,7 +123,7 @@
 extern unsigned long get_zero_page_fast(void);
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-ppc/pci.h linux-2.4.20-kfi/include/asm-ppc/pci.h
--- linux-2.4.20-std/include/asm-ppc/pci.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/pci.h	2004-12-30 22:15:17.000000000 +0100
@@ -23,12 +23,12 @@
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		0x10000000
 
-extern inline void pcibios_set_master(struct pci_dev *dev)
+static inline void pcibios_set_master(struct pci_dev *dev)
 {
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/pgalloc.h linux-2.4.20-kfi/include/asm-ppc/pgalloc.h
--- linux-2.4.20-std/include/asm-ppc/pgalloc.h	2001-05-22 00:02:06.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/pgalloc.h	2004-12-30 22:15:17.000000000 +0100
@@ -55,7 +55,7 @@
 
 extern void __bad_pte(pmd_t *pmd);
 
-extern __inline__ pgd_t *get_pgd_slow(void)
+static __inline__ pgd_t *get_pgd_slow(void)
 {
 	pgd_t *ret;
 
@@ -64,7 +64,7 @@
 	return ret;
 }
 
-extern __inline__ pgd_t *get_pgd_fast(void)
+static __inline__ pgd_t *get_pgd_fast(void)
 {
         unsigned long *ret;
 
@@ -77,14 +77,14 @@
         return (pgd_t *)ret;
 }
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
         *(unsigned long **)pgd = pgd_quicklist;
         pgd_quicklist = (unsigned long *) pgd;
         pgtable_cache_size++;
 }
 
-extern __inline__ void free_pgd_slow(pgd_t *pgd)
+static __inline__ void free_pgd_slow(pgd_t *pgd)
 {
 	free_page((unsigned long)pgd);
 }
@@ -128,14 +128,14 @@
         return (pte_t *)ret;
 }
 
-extern __inline__ void pte_free_fast(pte_t *pte)
+static __inline__ void pte_free_fast(pte_t *pte)
 {
         *(unsigned long **)pte = pte_quicklist;
         pte_quicklist = (unsigned long *) pte;
         pgtable_cache_size++;
 }
 
-extern __inline__ void pte_free_slow(pte_t *pte)
+static __inline__ void pte_free_slow(pte_t *pte)
 {
 	free_page((unsigned long)pte);
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/processor.h linux-2.4.20-kfi/include/asm-ppc/processor.h
--- linux-2.4.20-std/include/asm-ppc/processor.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/processor.h	2004-12-30 22:15:17.000000000 +0100
@@ -730,12 +730,12 @@
 #define ARCH_HAS_PREFETCHW
 #define ARCH_HAS_SPINLOCK_PREFETCH
 
-extern inline void prefetch(const void *x)
+static inline void prefetch(const void *x)
 {
 	 __asm__ __volatile__ ("dcbt 0,%0" : : "r" (x));
 }
 
-extern inline void prefetchw(const void *x)
+static inline void prefetchw(const void *x)
 {
 	 __asm__ __volatile__ ("dcbtst 0,%0" : : "r" (x));
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/semaphore.h linux-2.4.20-kfi/include/asm-ppc/semaphore.h
--- linux-2.4.20-std/include/asm-ppc/semaphore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/semaphore.h	2004-12-30 22:15:17.000000000 +0100
@@ -81,7 +81,7 @@
 extern int  __down_interruptible(struct semaphore * sem);
 extern void __up(struct semaphore * sem);
 
-extern inline void down(struct semaphore * sem)
+static inline void down(struct semaphore * sem)
 {
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
@@ -95,7 +95,7 @@
 	smp_wmb();
 }
 
-extern inline int down_interruptible(struct semaphore * sem)
+static inline int down_interruptible(struct semaphore * sem)
 {
 	int ret = 0;
 
@@ -109,7 +109,7 @@
 	return ret;
 }
 
-extern inline int down_trylock(struct semaphore * sem)
+static inline int down_trylock(struct semaphore * sem)
 {
 	int ret;
 
@@ -122,7 +122,7 @@
 	return ret;
 }
 
-extern inline void up(struct semaphore * sem)
+static inline void up(struct semaphore * sem)
 {
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
diff -rbNu linux-2.4.20-std/include/asm-ppc/siginfo.h linux-2.4.20-kfi/include/asm-ppc/siginfo.h
--- linux-2.4.20-std/include/asm-ppc/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/siginfo.h	2004-12-30 22:15:17.000000000 +0100
@@ -218,7 +218,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-ppc/system.h linux-2.4.20-kfi/include/asm-ppc/system.h
--- linux-2.4.20-std/include/asm-ppc/system.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/system.h	2004-12-30 22:15:17.000000000 +0100
@@ -165,7 +165,7 @@
 
 }
 
-extern inline void * xchg_ptr(void * m, void * val)
+static inline void * xchg_ptr(void * m, void * val)
 {
 	return (void *) xchg_u32(m, (unsigned long) val);
 }
diff -rbNu linux-2.4.20-std/include/asm-ppc/time.h linux-2.4.20-kfi/include/asm-ppc/time.h
--- linux-2.4.20-std/include/asm-ppc/time.h	2001-11-03 02:43:54.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-ppc/time.h	2004-12-30 22:15:17.000000000 +0100
@@ -60,39 +60,39 @@
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
 #ifdef CONFIG_6xx
-extern __inline__ int const __USE_RTC(void) {
+static __inline__ int const __USE_RTC(void) {
 	return (mfspr(SPRN_PVR)>>16) == 1;
 }
 #else
 #define __USE_RTC() 0
 #endif
 
-extern __inline__ unsigned long get_tbl(void) {
+static __inline__ unsigned long get_tbl(void) {
 	unsigned long tbl;
 	asm volatile("mftb %0" : "=r" (tbl));
 	return tbl;
 }
 
-extern __inline__ unsigned long get_tbu(void) {
+static __inline__ unsigned long get_tbu(void) {
 	unsigned long tbl;
 	asm volatile("mftbu %0" : "=r" (tbl));
 	return tbl;
 }
 
-extern __inline__ void set_tb(unsigned int upper, unsigned int lower)
+static __inline__ void set_tb(unsigned int upper, unsigned int lower)
 {
 	mtspr(SPRN_TBWL, 0);
 	mtspr(SPRN_TBWU, upper);
 	mtspr(SPRN_TBWL, lower);
 }
 
-extern __inline__ unsigned long get_rtcl(void) {
+static __inline__ unsigned long get_rtcl(void) {
 	unsigned long rtcl;
 	asm volatile("mfrtcl %0" : "=r" (rtcl));
 	return rtcl;
 }
 
-extern __inline__ unsigned get_native_tbl(void) {
+static __inline__ unsigned get_native_tbl(void) {
 	if (__USE_RTC())
 		return get_rtcl();
 	else
@@ -103,7 +103,7 @@
  * after the timestamp and for 1 second. It is only used by gettimeofday
  * however so it should not matter.
  */
-extern __inline__ unsigned tb_ticks_since(unsigned tstamp) {
+static __inline__ unsigned tb_ticks_since(unsigned tstamp) {
 	if (__USE_RTC()) {
 		int delta = get_rtcl() - tstamp;
 		return delta<0 ? delta + 1000000000 : delta;
@@ -113,7 +113,7 @@
 }
 
 #if 0
-extern __inline__ unsigned long get_bin_rtcl(void) {
+static __inline__ unsigned long get_bin_rtcl(void) {
       unsigned long rtcl, rtcu1, rtcu2;
       asm volatile("\
 1:    mfrtcu  %0\n\
@@ -126,7 +126,7 @@
       return rtcu2*1000000000+rtcl;
 }
 
-extern __inline__ unsigned binary_tbl(void) {
+static __inline__ unsigned binary_tbl(void) {
       if (__USE_RTC())
               return get_bin_rtcl();
       else
diff -rbNu linux-2.4.20-std/include/asm-ppc/uaccess.h linux-2.4.20-kfi/include/asm-ppc/uaccess.h
--- linux-2.4.20-std/include/asm-ppc/uaccess.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/uaccess.h	2004-12-30 22:15:17.000000000 +0100
@@ -35,7 +35,7 @@
 #define __access_ok(addr,size) (__kernel_ok || __user_ok((addr),(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
@@ -232,7 +232,7 @@
 
 extern int __copy_tofrom_user(void *to, const void *from, unsigned long size);
 
-extern inline unsigned long
+static inline unsigned long
 copy_from_user(void *to, const void *from, unsigned long n)
 {
 	unsigned long over;
@@ -246,7 +246,7 @@
 	return n;
 }
 
-extern inline unsigned long
+static inline unsigned long
 copy_to_user(void *to, const void *from, unsigned long n)
 {
 	unsigned long over;
@@ -267,7 +267,7 @@
 
 extern unsigned long __clear_user(void *addr, unsigned long size);
 
-extern inline unsigned long
+static inline unsigned long
 clear_user(void *addr, unsigned long size)
 {
 	if (access_ok(VERIFY_WRITE, addr, size))
@@ -281,7 +281,7 @@
 
 extern int __strncpy_from_user(char *dst, const char *src, long count);
 
-extern inline long
+static inline long
 strncpy_from_user(char *dst, const char *src, long count)
 {
 	if (access_ok(VERIFY_READ, src, 1))
@@ -305,7 +305,7 @@
  * The `top' parameter to __strnlen_user is to make sure that
  * we can never overflow from the user area into kernel space.
  */
-extern __inline__ int strnlen_user(const char *str, long len)
+static __inline__ int strnlen_user(const char *str, long len)
 {
 	unsigned long top = __kernel_ok? ~0UL: TASK_SIZE - 1;
 
diff -rbNu linux-2.4.20-std/include/asm-ppc/vga.h linux-2.4.20-kfi/include/asm-ppc/vga.h
--- linux-2.4.20-std/include/asm-ppc/vga.h	2001-05-22 00:02:06.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-ppc/vga.h	2004-12-30 22:15:17.000000000 +0100
@@ -25,12 +25,12 @@
  *  <linux/vt_buffer.h> has already done the right job for us.
  */
 
-extern inline void scr_writew(u16 val, volatile u16 *addr)
+static inline void scr_writew(u16 val, volatile u16 *addr)
 {
     st_le16(addr, val);
 }
 
-extern inline u16 scr_readw(volatile const u16 *addr)
+static inline u16 scr_readw(volatile const u16 *addr)
 {
     return ld_le16(addr);
 }
diff -rbNu linux-2.4.20-std/include/asm-s390/bitops.h linux-2.4.20-kfi/include/asm-s390/bitops.h
--- linux-2.4.20-std/include/asm-s390/bitops.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/bitops.h	2004-12-30 22:15:21.000000000 +0100
@@ -713,7 +713,7 @@
  * differs in spirit from the above ffz (man ffs).
  */
 
-extern int __inline__ ffs (int x)
+static int __inline__ ffs (int x)
 {
         int r;
 
diff -rbNu linux-2.4.20-std/include/asm-s390/checksum.h linux-2.4.20-kfi/include/asm-s390/checksum.h
--- linux-2.4.20-std/include/asm-s390/checksum.h	2001-07-25 23:12:02.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/checksum.h	2004-12-30 22:15:21.000000000 +0100
@@ -33,7 +33,7 @@
 /*
  * csum_partial as an inline function
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_inline(const unsigned char * buff, int len, unsigned int sum)
 {
 	register_pair rp;
@@ -55,7 +55,7 @@
  * better 64-bit) boundary
  */
 
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_copy(const char *src, char *dst, int len,unsigned int sum)
 {
 	memcpy(dst,src,len);
@@ -71,7 +71,7 @@
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_copy_from_user (const char *src, char *dst,
                                           int len, unsigned int sum,
                                           int *err_ptr)
@@ -88,7 +88,7 @@
 }
 
 
-extern inline unsigned int
+static inline unsigned int
 csum_partial_copy_nocheck (const char *src, char *dst, int len, unsigned int sum)
 {
         memcpy(dst,src,len);
@@ -101,7 +101,7 @@
 #if 1
 unsigned short csum_fold(unsigned int sum);
 #else
-extern inline unsigned short
+static inline unsigned short
 csum_fold(unsigned int sum)
 {
 	register_pair rp;
@@ -123,7 +123,7 @@
  *	which always checksum on 4 octet boundaries.
  *
  */
-extern inline unsigned short
+static inline unsigned short
 ip_fast_csum(unsigned char *iph, unsigned int ihl)
 {
 	register_pair rp;
@@ -143,7 +143,7 @@
  * computes the checksum of the TCP/UDP pseudo-header
  * returns a 32-bit checksum
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_tcpudp_nofold(unsigned long saddr, unsigned long daddr,
                    unsigned short len, unsigned short proto,
                    unsigned int sum)
@@ -176,7 +176,7 @@
  * returns a 16-bit checksum, already complemented
  */
 
-extern inline unsigned short int
+static inline unsigned short int
 csum_tcpudp_magic(unsigned long saddr, unsigned long daddr,
                   unsigned short len, unsigned short proto,
                   unsigned int sum)
@@ -189,7 +189,7 @@
  * in icmp.c
  */
 
-extern inline unsigned short
+static inline unsigned short
 ip_compute_csum(unsigned char * buff, int len)
 {
 	return csum_fold(csum_partial(buff, len, 0));
diff -rbNu linux-2.4.20-std/include/asm-s390/debug.h linux-2.4.20-kfi/include/asm-s390/debug.h
--- linux-2.4.20-std/include/asm-s390/debug.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/debug.h	2004-12-30 22:15:21.000000000 +0100
@@ -129,14 +129,14 @@
 
 void debug_set_level(debug_info_t* id, int new_level);
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_event(debug_info_t* id, int level, void* data, int length)
 {
 	if ((!id) || (level > id->level)) return NULL;
         return debug_event_common(id,level,data,length);
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_int_event(debug_info_t* id, int level, unsigned int tag)
 {
         unsigned int t=tag;
@@ -144,7 +144,7 @@
         return debug_event_common(id,level,&t,sizeof(unsigned int));
 }
 
-extern inline debug_entry_t *
+static inline debug_entry_t *
 debug_long_event (debug_info_t* id, int level, unsigned long tag)
 {
         unsigned long t=tag;
@@ -152,7 +152,7 @@
         return debug_event_common(id,level,&t,sizeof(unsigned long));
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_text_event(debug_info_t* id, int level, const char* txt)
 {
 	if ((!id) || (level > id->level)) return NULL;
@@ -163,14 +163,14 @@
 debug_sprintf_event(debug_info_t* id,int level,char *string,...);
 
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_exception(debug_info_t* id, int level, void* data, int length)
 {
 	if ((!id) || (level > id->level)) return NULL;
         return debug_exception_common(id,level,data,length);
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_int_exception(debug_info_t* id, int level, unsigned int tag)
 {
         unsigned int t=tag;
@@ -178,7 +178,7 @@
         return debug_exception_common(id,level,&t,sizeof(unsigned int));
 }
 
-extern inline debug_entry_t * 
+static inline debug_entry_t * 
 debug_long_exception (debug_info_t* id, int level, unsigned long tag)
 {
         unsigned long t=tag;
@@ -186,7 +186,7 @@
         return debug_exception_common(id,level,&t,sizeof(unsigned long));
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_text_exception(debug_info_t* id, int level, const char* txt)
 {
 	if ((!id) || (level > id->level)) return NULL;
diff -rbNu linux-2.4.20-std/include/asm-s390/ebcdic.h linux-2.4.20-kfi/include/asm-s390/ebcdic.h
--- linux-2.4.20-std/include/asm-s390/ebcdic.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/ebcdic.h	2004-12-30 22:15:21.000000000 +0100
@@ -21,7 +21,7 @@
 extern __u8 _ebc_tolower[]; /* EBCDIC -> lowercase */
 extern __u8 _ebc_toupper[]; /* EBCDIC -> uppercase */
 
-extern __inline__ 
+static __inline__ 
 void codepage_convert(const __u8 *codepage, volatile __u8 * addr, int nr)
 {
 	if (nr-- <= 0)
diff -rbNu linux-2.4.20-std/include/asm-s390/io.h linux-2.4.20-kfi/include/asm-s390/io.h
--- linux-2.4.20-std/include/asm-s390/io.h	2001-07-25 23:12:02.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/io.h	2004-12-30 22:15:21.000000000 +0100
@@ -24,7 +24,7 @@
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	unsigned long real_address;
 	__asm__ ("   lra    %0,0(%1)\n"
@@ -35,14 +35,14 @@
         return real_address;
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
         return __io_virt(address);
 }
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, 0);
 }
@@ -52,7 +52,7 @@
  * it's useful if some control registers are in such an area and write combining
  * or read caching is not desirable:
  */
-extern inline void * ioremap_nocache (unsigned long offset, unsigned long size)
+static inline void * ioremap_nocache (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, 0);
 }
diff -rbNu linux-2.4.20-std/include/asm-s390/irq.h linux-2.4.20-kfi/include/asm-s390/irq.h
--- linux-2.4.20-std/include/asm-s390/irq.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/irq.h	2004-12-30 22:15:21.000000000 +0100
@@ -673,7 +673,7 @@
  * Some S390 specific IO instructions as inline
  */
 
-extern __inline__ int stsch(int irq, volatile schib_t *addr)
+static __inline__ int stsch(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -688,7 +688,7 @@
         return ccode;
 }
 
-extern __inline__ int msch(int irq, volatile schib_t *addr)
+static __inline__ int msch(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -703,7 +703,7 @@
         return ccode;
 }
 
-extern __inline__ int msch_err(int irq, volatile schib_t *addr)
+static __inline__ int msch_err(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -741,7 +741,7 @@
         return ccode;
 }
 
-extern __inline__ int tsch(int irq, volatile irb_t *addr)
+static __inline__ int tsch(int irq, volatile irb_t *addr)
 {
         int ccode;
 
@@ -756,7 +756,7 @@
         return ccode;
 }
 
-extern __inline__ int tpi( volatile tpi_info_t *addr)
+static __inline__ int tpi( volatile tpi_info_t *addr)
 {
         int ccode;
 
@@ -770,7 +770,7 @@
         return ccode;
 }
 
-extern __inline__ int ssch(int irq, volatile orb_t *addr)
+static __inline__ int ssch(int irq, volatile orb_t *addr)
 {
         int ccode;
 
@@ -785,7 +785,7 @@
         return ccode;
 }
 
-extern __inline__ int rsch(int irq)
+static __inline__ int rsch(int irq)
 {
         int ccode;
 
@@ -800,7 +800,7 @@
         return ccode;
 }
 
-extern __inline__ int csch(int irq)
+static __inline__ int csch(int irq)
 {
         int ccode;
 
@@ -815,7 +815,7 @@
         return ccode;
 }
 
-extern __inline__ int hsch(int irq)
+static __inline__ int hsch(int irq)
 {
         int ccode;
 
@@ -830,7 +830,7 @@
         return ccode;
 }
 
-extern __inline__ int xsch(int irq)
+static __inline__ int xsch(int irq)
 {
 	int ccode;
 	
@@ -845,7 +845,7 @@
 	return ccode;
 }
 
-extern __inline__ int iac( void)
+static __inline__ int iac( void)
 {
         int ccode;
 
@@ -857,7 +857,7 @@
         return ccode;
 }
 
-extern __inline__ int rchp(int chpid)
+static __inline__ int rchp(int chpid)
 {
         int ccode;
 
@@ -888,7 +888,7 @@
 void VM_virtual_device_info( __u16      devno,   /* device number */
                              senseid_t *ps );    /* ptr to senseID data */
 
-extern __inline__ int diag210( diag210_t * addr)
+static __inline__ int diag210( diag210_t * addr)
 {
         int ccode;
 
@@ -907,7 +907,7 @@
                 : "cc" );
         return ccode;
 }
-extern __inline__ int chsc( chsc_area_t * chsc_area)
+static __inline__ int chsc( chsc_area_t * chsc_area)
 {
 	int cc;
 	
diff -rbNu linux-2.4.20-std/include/asm-s390/lowcore.h linux-2.4.20-kfi/include/asm-s390/lowcore.h
--- linux-2.4.20-std/include/asm-s390/lowcore.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/lowcore.h	2004-12-30 22:15:21.000000000 +0100
@@ -176,7 +176,7 @@
 	__u8         pad12[0x1000-0xe04];      /* 0xe04 */
 } __attribute__((packed)); /* End structure*/
 
-extern __inline__ void set_prefix(__u32 address)
+static __inline__ void set_prefix(__u32 address)
 {
         __asm__ __volatile__ ("spx %0" : : "m" (address) : "memory" );
 }
diff -rbNu linux-2.4.20-std/include/asm-s390/mmu_context.h linux-2.4.20-kfi/include/asm-s390/mmu_context.h
--- linux-2.4.20-std/include/asm-s390/mmu_context.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/mmu_context.h	2004-12-30 22:15:21.000000000 +0100
@@ -37,7 +37,7 @@
 	set_bit(cpu, &next->cpu_vm_mask);
 }
 
-extern inline void activate_mm(struct mm_struct *prev,
+static inline void activate_mm(struct mm_struct *prev,
                                struct mm_struct *next)
 {
         switch_mm(prev, next, current, smp_processor_id());
diff -rbNu linux-2.4.20-std/include/asm-s390/page.h linux-2.4.20-kfi/include/asm-s390/page.h
--- linux-2.4.20-std/include/asm-s390/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/page.h	2004-12-30 22:15:21.000000000 +0100
@@ -72,7 +72,7 @@
 } while (0)                      
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
         int order;
 
diff -rbNu linux-2.4.20-std/include/asm-s390/pgalloc.h linux-2.4.20-kfi/include/asm-s390/pgalloc.h
--- linux-2.4.20-std/include/asm-s390/pgalloc.h	2001-10-11 18:43:38.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/pgalloc.h	2004-12-30 22:15:21.000000000 +0100
@@ -28,7 +28,7 @@
  * if any.
  */
 
-extern __inline__ pgd_t* get_pgd_slow(void)
+static __inline__ pgd_t* get_pgd_slow(void)
 {
 	pgd_t *ret;
         int i;
@@ -40,7 +40,7 @@
 	return ret;
 }
 
-extern __inline__ pgd_t* get_pgd_fast(void)
+static __inline__ pgd_t* get_pgd_fast(void)
 {
         unsigned long *ret = pgd_quicklist;
 	
@@ -52,7 +52,7 @@
         return (pgd_t *)ret;
 }
 
-extern __inline__ pgd_t *pgd_alloc(struct mm_struct *mm)
+static __inline__ pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	pgd_t *pgd;
 
@@ -62,14 +62,14 @@
 	return pgd;
 }
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
         *(unsigned long *)pgd = (unsigned long) pgd_quicklist;
         pgd_quicklist = (unsigned long *) pgd;
         pgtable_cache_size += 2;
 }
 
-extern __inline__ void free_pgd_slow(pgd_t *pgd)
+static __inline__ void free_pgd_slow(pgd_t *pgd)
 {
         free_pages((unsigned long) pgd, 1);
 }
@@ -88,7 +88,7 @@
 #define pmd_free_fast(x)                do { } while (0)
 #define pgd_populate(mm, pmd, pte)      BUG()
 
-extern inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
+static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
 {
 	pmd_val(pmd[0]) = _PAGE_TABLE + __pa(pte);
 	pmd_val(pmd[1]) = _PAGE_TABLE + __pa(pte+256);
@@ -99,7 +99,7 @@
 /*
  * page table entry allocation/free routines.
  */
-extern inline pte_t * pte_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
+static inline pte_t * pte_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
 {
 	pte_t *pte;
         int i;
@@ -112,7 +112,7 @@
 	return pte;
 }
 
-extern __inline__ pte_t *
+static __inline__ pte_t *
 pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
         unsigned long *ret = (unsigned long *) pte_quicklist;
@@ -125,14 +125,14 @@
         return (pte_t *)ret;
 }
 
-extern __inline__ void pte_free_fast(pte_t *pte)
+static __inline__ void pte_free_fast(pte_t *pte)
 {
         *(unsigned long *)pte = (unsigned long) pte_quicklist;
         pte_quicklist = (unsigned long *) pte;
         pgtable_cache_size++;
 }
 
-extern __inline__ void pte_free_slow(pte_t *pte)
+static __inline__ void pte_free_slow(pte_t *pte)
 {
         free_page((unsigned long) pte);
 }
@@ -272,7 +272,7 @@
 
 #endif
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
                                       unsigned long start, unsigned long end)
 {
         /* S/390 does not keep any page table caches in TLB */
diff -rbNu linux-2.4.20-std/include/asm-s390/pgtable.h linux-2.4.20-kfi/include/asm-s390/pgtable.h
--- linux-2.4.20-std/include/asm-s390/pgtable.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/pgtable.h	2004-12-30 22:15:21.000000000 +0100
@@ -228,7 +228,7 @@
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
  */
-extern inline void set_pte(pte_t *pteptr, pte_t pteval)
+static inline void set_pte(pte_t *pteptr, pte_t pteval)
 {
 	if ((pte_val(pteval) & (_PAGE_MKCLEAN|_PAGE_INVALID))
 	    == _PAGE_MKCLEAN) 
@@ -247,19 +247,19 @@
 /*
  * pgd/pmd/pte query functions
  */
-extern inline int pgd_present(pgd_t pgd) { return 1; }
-extern inline int pgd_none(pgd_t pgd)    { return 0; }
-extern inline int pgd_bad(pgd_t pgd)     { return 0; }
-
-extern inline int pmd_present(pmd_t pmd) { return pmd_val(pmd) & _SEG_PRESENT; }
-extern inline int pmd_none(pmd_t pmd)    { return pmd_val(pmd) & _PAGE_TABLE_INV; }
-extern inline int pmd_bad(pmd_t pmd)
+static inline int pgd_present(pgd_t pgd) { return 1; }
+static inline int pgd_none(pgd_t pgd)    { return 0; }
+static inline int pgd_bad(pgd_t pgd)     { return 0; }
+
+static inline int pmd_present(pmd_t pmd) { return pmd_val(pmd) & _SEG_PRESENT; }
+static inline int pmd_none(pmd_t pmd)    { return pmd_val(pmd) & _PAGE_TABLE_INV; }
+static inline int pmd_bad(pmd_t pmd)
 {
 	return (pmd_val(pmd) & (~PAGE_MASK & ~_PAGE_TABLE_INV)) != _PAGE_TABLE;
 }
 
-extern inline int pte_present(pte_t pte) { return pte_val(pte) & _PAGE_PRESENT; }
-extern inline int pte_none(pte_t pte)
+static inline int pte_present(pte_t pte) { return pte_val(pte) & _PAGE_PRESENT; }
+static inline int pte_none(pte_t pte)
 {
 	return ((pte_val(pte) & 
                 (_PAGE_INVALID | _PAGE_RO | _PAGE_PRESENT)) == _PAGE_INVALID);
@@ -271,12 +271,12 @@
  * query functions pte_write/pte_dirty/pte_young only work if
  * pte_present() is true. Undefined behaviour if not..
  */
-extern inline int pte_write(pte_t pte)
+static inline int pte_write(pte_t pte)
 {
 	return (pte_val(pte) & _PAGE_RO) == 0;
 }
 
-extern inline int pte_dirty(pte_t pte)
+static inline int pte_dirty(pte_t pte)
 {
 	int skey;
 
@@ -286,7 +286,7 @@
 	return skey & _PAGE_CHANGED;
 }
 
-extern inline int pte_young(pte_t pte)
+static inline int pte_young(pte_t pte)
 {
 	int skey;
 
@@ -297,9 +297,9 @@
 /*
  * pgd/pmd/pte modification functions
  */
-extern inline void pgd_clear(pgd_t * pgdp)      { }
+static inline void pgd_clear(pgd_t * pgdp)      { }
 
-extern inline void pmd_clear(pmd_t * pmdp)
+static inline void pmd_clear(pmd_t * pmdp)
 {
 	pmd_val(pmdp[0]) = _PAGE_TABLE_INV;
 	pmd_val(pmdp[1]) = _PAGE_TABLE_INV;
@@ -307,7 +307,7 @@
 	pmd_val(pmdp[3]) = _PAGE_TABLE_INV;
 }
 
-extern inline void pte_clear(pte_t *ptep)
+static inline void pte_clear(pte_t *ptep)
 {
 	pte_val(*ptep) = _PAGE_INVALID; 
 }
@@ -318,26 +318,26 @@
  * The following pte modification functions only work if
  * pte_present() is true. Undefined behaviour if not..
  */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte_val(pte) &= PAGE_MASK | _PAGE_ISCLEAN;
 	pte_val(pte) |= pgprot_val(newprot) & ~_PAGE_ISCLEAN;
 	return pte;
 }
 
-extern inline pte_t pte_wrprotect(pte_t pte)
+static inline pte_t pte_wrprotect(pte_t pte)
 {
 	pte_val(pte) |= _PAGE_RO;
 	return pte;
 }
 
-extern inline pte_t pte_mkwrite(pte_t pte) 
+static inline pte_t pte_mkwrite(pte_t pte) 
 {
 	pte_val(pte) &= ~_PAGE_RO;
 	return pte;
 }
 
-extern inline pte_t pte_mkclean(pte_t pte)
+static inline pte_t pte_mkclean(pte_t pte)
 {
 	/* The only user of pte_mkclean is the fork() code.
 	   We must *not* clear the *physical* page dirty bit
@@ -346,7 +346,7 @@
 	return pte;
 }
 
-extern inline pte_t pte_mkdirty(pte_t pte)
+static inline pte_t pte_mkdirty(pte_t pte)
 {
 	/* We do not explicitly set the dirty bit because the
 	 * sske instruction is slow. It is faster to let the
@@ -356,13 +356,13 @@
 	return pte;
 }
 
-extern inline pte_t pte_mkold(pte_t pte)
+static inline pte_t pte_mkold(pte_t pte)
 {
 	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)) : "cc" );
 	return pte;
 }
 
-extern inline pte_t pte_mkyoung(pte_t pte)
+static inline pte_t pte_mkyoung(pte_t pte)
 {
 	/* To set the referenced bit we read the first word from the real
 	 * page with a special instruction: load using real address (lura).
@@ -455,7 +455,7 @@
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
 
 /* Find an entry in the second-level page table.. */
-extern inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
+static inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
 {
         return (pmd_t *) dir;
 }
@@ -481,7 +481,7 @@
  * 00000000001111111111222222222233
  * 01234567890123456789012345678901
  */
-extern inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
+static inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
 {
 	pte_t pte;
 	pte_val(pte) = (type << 1) | (offset << 12) | _PAGE_INVALID | _PAGE_RO;
diff -rbNu linux-2.4.20-std/include/asm-s390/processor.h linux-2.4.20-kfi/include/asm-s390/processor.h
--- linux-2.4.20-std/include/asm-s390/processor.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/processor.h	2004-12-30 22:15:21.000000000 +0100
@@ -127,7 +127,7 @@
  * schedule, so we have to walk the backchain one time to
  * find the frame schedule() store its return address.
  */
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	unsigned long bc;
 	bc = *((unsigned long *) t->ksp);
diff -rbNu linux-2.4.20-std/include/asm-s390/s390mach.h linux-2.4.20-kfi/include/asm-s390/s390mach.h
--- linux-2.4.20-std/include/asm-s390/s390mach.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/s390mach.h	2004-12-30 22:15:21.000000000 +0100
@@ -103,7 +103,7 @@
 void s390_do_machine_check  ( void );
 void s390_do_crw_pending    ( crwe_t *pcrwe );
 
-extern __inline__ int stcrw( __u32 *pcrw )
+static __inline__ int stcrw( __u32 *pcrw )
 {
         int ccode;
 
diff -rbNu linux-2.4.20-std/include/asm-s390/sigp.h linux-2.4.20-kfi/include/asm-s390/sigp.h
--- linux-2.4.20-std/include/asm-s390/sigp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/sigp.h	2004-12-30 22:15:21.000000000 +0100
@@ -66,7 +66,7 @@
 /*
  * Signal processor
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor(__u16 cpu_addr, sigp_order_code order_code)
 {
 	sigp_ccode ccode;
@@ -85,7 +85,7 @@
 /*
  * Signal processor with parameter
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor_p(__u32 parameter,__u16 cpu_addr,sigp_order_code order_code)
 {
 	sigp_ccode ccode;
@@ -105,7 +105,7 @@
 /*
  * Signal processor with parameter and return status
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor_ps(__u32 *statusptr, __u32 parameter,
 		    __u16 cpu_addr, sigp_order_code order_code)
 {
diff -rbNu linux-2.4.20-std/include/asm-s390/smp.h linux-2.4.20-kfi/include/asm-s390/smp.h
--- linux-2.4.20-std/include/asm-s390/smp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/smp.h	2004-12-30 22:15:21.000000000 +0100
@@ -44,17 +44,17 @@
 
 #define smp_processor_id() (current->processor)
 
-extern __inline__ int cpu_logical_map(int cpu)
+static __inline__ int cpu_logical_map(int cpu)
 {
         return cpu;
 }
 
-extern __inline__ int cpu_number_map(int cpu)
+static __inline__ int cpu_number_map(int cpu)
 {
         return cpu;
 }
 
-extern __inline__ __u16 hard_smp_processor_id(void)
+static __inline__ __u16 hard_smp_processor_id(void)
 {
         __u16 cpu_address;
  
diff -rbNu linux-2.4.20-std/include/asm-s390/smplock.h linux-2.4.20-kfi/include/asm-s390/smplock.h
--- linux-2.4.20-std/include/asm-s390/smplock.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390/smplock.h	2004-12-30 22:15:21.000000000 +0100
@@ -48,13 +48,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
         if (!++current->lock_depth)
                 spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
         if (--current->lock_depth < 0)
                 spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-s390/spinlock.h linux-2.4.20-kfi/include/asm-s390/spinlock.h
--- linux-2.4.20-std/include/asm-s390/spinlock.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/spinlock.h	2004-12-30 22:15:21.000000000 +0100
@@ -27,7 +27,7 @@
 #define spin_unlock_wait(lp)	do { barrier(); } while(((volatile spinlock_t *)(lp))->lock)
 #define spin_is_locked(x) ((x)->lock != 0)
 
-extern inline void spin_lock(spinlock_t *lp)
+static inline void spin_lock(spinlock_t *lp)
 {
 	unsigned int reg1, reg2;
         __asm__ __volatile("    bras  %0,1f\n"
@@ -39,7 +39,7 @@
 			   : "a" (&lp->lock) : "cc", "memory" );
 }
 
-extern inline int spin_trylock(spinlock_t *lp)
+static inline int spin_trylock(spinlock_t *lp)
 {
 	unsigned long result, reg;
 	__asm__ __volatile("    slr   %0,%0\n"
@@ -50,7 +50,7 @@
 	return !result;
 }
 
-extern inline void spin_unlock(spinlock_t *lp)
+static inline void spin_unlock(spinlock_t *lp)
 {
 	__asm__ __volatile("    xc 0(4,%0),0(%0)\n"
                            "    bcr 15,0"
diff -rbNu linux-2.4.20-std/include/asm-s390/uaccess.h linux-2.4.20-kfi/include/asm-s390/uaccess.h
--- linux-2.4.20-std/include/asm-s390/uaccess.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390/uaccess.h	2004-12-30 22:15:21.000000000 +0100
@@ -46,7 +46,7 @@
 
 #define access_ok(type,addr,size) __access_ok(addr,size)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
         return access_ok(type,addr,size)?0:-EFAULT;
 }
@@ -78,7 +78,7 @@
  * use the right size if we just have the right pointer type.
  */
 
-extern inline int __put_user_asm_8(__u64 x, void *ptr)
+static inline int __put_user_asm_8(__u64 x, void *ptr)
 {
         int err;
 
@@ -107,7 +107,7 @@
         return err;
 }
 
-extern inline int __put_user_asm_4(__u32 x, void *ptr)
+static inline int __put_user_asm_4(__u32 x, void *ptr)
 {
         int err;
 
@@ -135,7 +135,7 @@
         return err;
 }
 
-extern inline int __put_user_asm_2(__u16 x, void *ptr)
+static inline int __put_user_asm_2(__u16 x, void *ptr)
 {
         int err;
 
@@ -163,7 +163,7 @@
         return err;
 }
 
-extern inline int __put_user_asm_1(__u8 x, void *ptr)
+static inline int __put_user_asm_1(__u8 x, void *ptr)
 {
         int err;
 
diff -rbNu linux-2.4.20-std/include/asm-s390x/bitops.h linux-2.4.20-kfi/include/asm-s390x/bitops.h
--- linux-2.4.20-std/include/asm-s390x/bitops.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/bitops.h	2004-12-30 22:15:22.000000000 +0100
@@ -735,7 +735,7 @@
  * differs in spirit from the above ffz (man ffs).
  */
 
-extern int __inline__ ffs (int x)
+static int __inline__ ffs (int x)
 {
         int r;
 
diff -rbNu linux-2.4.20-std/include/asm-s390x/checksum.h linux-2.4.20-kfi/include/asm-s390x/checksum.h
--- linux-2.4.20-std/include/asm-s390x/checksum.h	2001-07-25 23:12:02.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/checksum.h	2004-12-30 22:15:22.000000000 +0100
@@ -33,7 +33,7 @@
 /*
  * csum_partial as an inline function
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_inline(const unsigned char * buff, int len, unsigned int sum)
 {
 	__asm__ __volatile__ (
@@ -55,7 +55,7 @@
  * better 64-bit) boundary
  */
 
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_copy(const char *src, char *dst, int len,unsigned int sum)
 {
 	memcpy(dst,src,len);
@@ -71,7 +71,7 @@
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_partial_copy_from_user (const char *src, char *dst,
                                           int len, unsigned int sum,
                                           int *err_ptr)
@@ -87,7 +87,7 @@
 	return csum_partial(dst, len, sum);
 }
 
-extern inline unsigned int
+static inline unsigned int
 csum_partial_copy_nocheck (const char *src, char *dst, int len, unsigned int sum)
 {
         memcpy(dst,src,len);
@@ -97,7 +97,7 @@
 /*
  *      Fold a partial checksum without adding pseudo headers
  */
-extern inline unsigned short
+static inline unsigned short
 csum_fold(unsigned int sum)
 {
 	__asm__ __volatile__ (
@@ -116,7 +116,7 @@
  *	which always checksum on 4 octet boundaries.
  *
  */
-extern inline unsigned short
+static inline unsigned short
 ip_fast_csum(unsigned char *iph, unsigned int ihl)
 {
 	unsigned long sum;
@@ -137,7 +137,7 @@
  * computes the checksum of the TCP/UDP pseudo-header
  * returns a 32-bit checksum
  */
-extern inline unsigned int 
+static inline unsigned int 
 csum_tcpudp_nofold(unsigned long saddr, unsigned long daddr,
                    unsigned short len, unsigned short proto,
                    unsigned int sum)
@@ -170,7 +170,7 @@
  * returns a 16-bit checksum, already complemented
  */
 
-extern inline unsigned short int
+static inline unsigned short int
 csum_tcpudp_magic(unsigned long saddr, unsigned long daddr,
                   unsigned short len, unsigned short proto,
                   unsigned int sum)
@@ -183,7 +183,7 @@
  * in icmp.c
  */
 
-extern inline unsigned short
+static inline unsigned short
 ip_compute_csum(unsigned char * buff, int len)
 {
 	return csum_fold(csum_partial_inline(buff, len, 0));
diff -rbNu linux-2.4.20-std/include/asm-s390x/debug.h linux-2.4.20-kfi/include/asm-s390x/debug.h
--- linux-2.4.20-std/include/asm-s390x/debug.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/debug.h	2004-12-30 22:15:22.000000000 +0100
@@ -129,14 +129,14 @@
 
 void debug_set_level(debug_info_t* id, int new_level);
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_event(debug_info_t* id, int level, void* data, int length)
 {
 	if ((!id) || (level > id->level)) return NULL;
         return debug_event_common(id,level,data,length);
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_int_event(debug_info_t* id, int level, unsigned int tag)
 {
         unsigned int t=tag;
@@ -144,7 +144,7 @@
         return debug_event_common(id,level,&t,sizeof(unsigned int));
 }
 
-extern inline debug_entry_t *
+static inline debug_entry_t *
 debug_long_event (debug_info_t* id, int level, unsigned long tag)
 {
         unsigned long t=tag;
@@ -152,7 +152,7 @@
         return debug_event_common(id,level,&t,sizeof(unsigned long));
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_text_event(debug_info_t* id, int level, const char* txt)
 {
 	if ((!id) || (level > id->level)) return NULL;
@@ -163,14 +163,14 @@
 debug_sprintf_event(debug_info_t* id,int level,char *string,...);
 
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_exception(debug_info_t* id, int level, void* data, int length)
 {
 	if ((!id) || (level > id->level)) return NULL;
         return debug_exception_common(id,level,data,length);
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_int_exception(debug_info_t* id, int level, unsigned int tag)
 {
         unsigned int t=tag;
@@ -178,7 +178,7 @@
         return debug_exception_common(id,level,&t,sizeof(unsigned int));
 }
 
-extern inline debug_entry_t * 
+static inline debug_entry_t * 
 debug_long_exception (debug_info_t* id, int level, unsigned long tag)
 {
         unsigned long t=tag;
@@ -186,7 +186,7 @@
         return debug_exception_common(id,level,&t,sizeof(unsigned long));
 }
 
-extern inline debug_entry_t* 
+static inline debug_entry_t* 
 debug_text_exception(debug_info_t* id, int level, const char* txt)
 {
 	if ((!id) || (level > id->level)) return NULL;
diff -rbNu linux-2.4.20-std/include/asm-s390x/ebcdic.h linux-2.4.20-kfi/include/asm-s390x/ebcdic.h
--- linux-2.4.20-std/include/asm-s390x/ebcdic.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/ebcdic.h	2004-12-30 22:15:22.000000000 +0100
@@ -21,7 +21,7 @@
 extern __u8 _ebc_tolower[]; /* EBCDIC -> lowercase */
 extern __u8 _ebc_toupper[]; /* EBCDIC -> uppercase */
 
-extern __inline__ void
+static __inline__ void
 codepage_convert(const __u8 *codepage, volatile __u8 * addr, unsigned long nr)
 {
 	if (nr-- <= 0)
diff -rbNu linux-2.4.20-std/include/asm-s390x/io.h linux-2.4.20-kfi/include/asm-s390x/io.h
--- linux-2.4.20-std/include/asm-s390x/io.h	2001-07-25 23:12:02.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/io.h	2004-12-30 22:15:22.000000000 +0100
@@ -24,7 +24,7 @@
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	unsigned long real_address;
 	__asm__ ("   lrag   %0,0(%1)\n"
@@ -35,14 +35,14 @@
         return real_address;
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
         return __io_virt(address);
 }
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, 0);
 }
@@ -52,7 +52,7 @@
  * it's useful if some control registers are in such an area and write combining
  * or read caching is not desirable:
  */
-extern inline void * ioremap_nocache (unsigned long offset, unsigned long size)
+static inline void * ioremap_nocache (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, 0);
 }
diff -rbNu linux-2.4.20-std/include/asm-s390x/irq.h linux-2.4.20-kfi/include/asm-s390x/irq.h
--- linux-2.4.20-std/include/asm-s390x/irq.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/irq.h	2004-12-30 22:15:22.000000000 +0100
@@ -674,7 +674,7 @@
  * Some S390 specific IO instructions as inline
  */
 
-extern __inline__ int stsch(int irq, volatile schib_t *addr)
+static __inline__ int stsch(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -689,7 +689,7 @@
         return ccode;
 }
 
-extern __inline__ int msch(int irq, volatile schib_t *addr)
+static __inline__ int msch(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -704,7 +704,7 @@
         return ccode;
 }
 
-extern __inline__ int msch_err(int irq, volatile schib_t *addr)
+static __inline__ int msch_err(int irq, volatile schib_t *addr)
 {
         int ccode;
 
@@ -742,7 +742,7 @@
         return ccode;
 }
 
-extern __inline__ int tsch(int irq, volatile irb_t *addr)
+static __inline__ int tsch(int irq, volatile irb_t *addr)
 {
         int ccode;
 
@@ -757,7 +757,7 @@
         return ccode;
 }
 
-extern __inline__ int tpi( volatile tpi_info_t *addr)
+static __inline__ int tpi( volatile tpi_info_t *addr)
 {
         int ccode;
 
@@ -771,7 +771,7 @@
         return ccode;
 }
 
-extern __inline__ int ssch(int irq, volatile orb_t *addr)
+static __inline__ int ssch(int irq, volatile orb_t *addr)
 {
         int ccode;
 
@@ -786,7 +786,7 @@
         return ccode;
 }
 
-extern __inline__ int rsch(int irq)
+static __inline__ int rsch(int irq)
 {
         int ccode;
 
@@ -801,7 +801,7 @@
         return ccode;
 }
 
-extern __inline__ int csch(int irq)
+static __inline__ int csch(int irq)
 {
         int ccode;
 
@@ -816,7 +816,7 @@
         return ccode;
 }
 
-extern __inline__ int hsch(int irq)
+static __inline__ int hsch(int irq)
 {
         int ccode;
 
@@ -831,7 +831,7 @@
         return ccode;
 }
 
-extern __inline__ int xsch(int irq)
+static __inline__ int xsch(int irq)
 {
 	int ccode;
 	
@@ -846,7 +846,7 @@
 	return ccode;
 }
 
-extern __inline__ int iac( void)
+static __inline__ int iac( void)
 {
         int ccode;
 
@@ -858,7 +858,7 @@
         return ccode;
 }
 
-extern __inline__ int rchp(int chpid)
+static __inline__ int rchp(int chpid)
 {
         int ccode;
 
@@ -889,7 +889,7 @@
 void VM_virtual_device_info( __u16      devno,   /* device number */
                              senseid_t *ps );    /* ptr to senseID data */
 
-extern __inline__ int diag210( diag210_t * addr)
+static __inline__ int diag210( diag210_t * addr)
 {
         int ccode;
 
@@ -909,7 +909,7 @@
         return ccode;
 }
 
-extern __inline__ int chsc( chsc_area_t * chsc_area)
+static __inline__ int chsc( chsc_area_t * chsc_area)
 {
 	int cc;
 	
diff -rbNu linux-2.4.20-std/include/asm-s390x/lowcore.h linux-2.4.20-kfi/include/asm-s390x/lowcore.h
--- linux-2.4.20-std/include/asm-s390x/lowcore.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/lowcore.h	2004-12-30 22:15:22.000000000 +0100
@@ -194,7 +194,7 @@
 	__u8         pad17[0x2000-0x1400];      /* 0x1400 */
 } __attribute__((packed)); /* End structure*/
 
-extern __inline__ void set_prefix(__u32 address)
+static __inline__ void set_prefix(__u32 address)
 {
         __asm__ __volatile__ ("spx %0" : : "m" (address) : "memory" );
 }
diff -rbNu linux-2.4.20-std/include/asm-s390x/mmu_context.h linux-2.4.20-kfi/include/asm-s390x/mmu_context.h
--- linux-2.4.20-std/include/asm-s390x/mmu_context.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/mmu_context.h	2004-12-30 22:15:22.000000000 +0100
@@ -36,7 +36,7 @@
 	set_bit(cpu, &next->cpu_vm_mask);
 }
 
-extern inline void activate_mm(struct mm_struct *prev,
+static inline void activate_mm(struct mm_struct *prev,
                                struct mm_struct *next)
 {
         switch_mm(prev, next, current, smp_processor_id());
diff -rbNu linux-2.4.20-std/include/asm-s390x/page.h linux-2.4.20-kfi/include/asm-s390x/page.h
--- linux-2.4.20-std/include/asm-s390x/page.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/page.h	2004-12-30 22:15:22.000000000 +0100
@@ -70,7 +70,7 @@
 } while (0)                      
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
         int order;
 
diff -rbNu linux-2.4.20-std/include/asm-s390x/pgalloc.h linux-2.4.20-kfi/include/asm-s390x/pgalloc.h
--- linux-2.4.20-std/include/asm-s390x/pgalloc.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/pgalloc.h	2004-12-30 22:15:22.000000000 +0100
@@ -32,7 +32,7 @@
 /*
  * page directory allocation/free routines.
  */
-extern __inline__ pgd_t *get_pgd_slow (void)
+static __inline__ pgd_t *get_pgd_slow (void)
 {
 	pgd_t *ret;
         int i;
@@ -44,7 +44,7 @@
 	return ret;
 }
 
-extern __inline__ pgd_t *get_pgd_fast (void)
+static __inline__ pgd_t *get_pgd_fast (void)
 {
 	unsigned long *ret = pgd_quicklist;
 
@@ -56,7 +56,7 @@
 	return (pgd_t *) ret;
 }
 
-extern __inline__ pgd_t *pgd_alloc (struct mm_struct *mm)
+static __inline__ pgd_t *pgd_alloc (struct mm_struct *mm)
 {
 	pgd_t *pgd;
 
@@ -66,14 +66,14 @@
 	return pgd;
 }
 
-extern __inline__ void free_pgd_fast (pgd_t *pgd)
+static __inline__ void free_pgd_fast (pgd_t *pgd)
 {
 	*(unsigned long *) pgd = (unsigned long) pgd_quicklist;
 	pgd_quicklist = (unsigned long *) pgd;
 	pgtable_cache_size += 2;
 }
 
-extern __inline__ void free_pgd_slow (pgd_t *pgd)
+static __inline__ void free_pgd_slow (pgd_t *pgd)
 {
 	free_pages((unsigned long) pgd, 1);
 }
@@ -85,7 +85,7 @@
 /*
  * page middle directory allocation/free routines.
  */
-extern inline pmd_t * pmd_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
+static inline pmd_t * pmd_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
 {
 	pmd_t *pmd;
         int i;
@@ -98,7 +98,7 @@
 	return pmd;
 }
 
-extern __inline__ pmd_t *
+static __inline__ pmd_t *
 pmd_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
 	unsigned long *ret = (unsigned long *) pmd_quicklist;
@@ -112,7 +112,7 @@
 }
 
 extern void pmd_free_order2(pmd_t *);
-extern __inline__ void pmd_free_fast (pmd_t *pmd)
+static __inline__ void pmd_free_fast (pmd_t *pmd)
 {
 	if (test_bit(PG_arch_1, &virt_to_page(pmd)->flags) == 0) {
 		*(unsigned long *) pmd = (unsigned long) pmd_quicklist;
@@ -122,14 +122,14 @@
 		pmd_free_order2(pmd);
 }
 
-extern __inline__ void pmd_free_slow (pmd_t *pmd)
+static __inline__ void pmd_free_slow (pmd_t *pmd)
 {
 	free_pages((unsigned long) pmd, 1);
 }
 
 #define pmd_free(pmd)		pmd_free_fast(pmd)
 
-extern inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
+static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
 {
 	pmd_val(*pmd) = _PMD_ENTRY | __pa(pte);
 	pmd_val1(*pmd) = _PMD_ENTRY | __pa(pte+256);
@@ -138,7 +138,7 @@
 /*
  * page table entry allocation/free routines.
  */
-extern inline pte_t * pte_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
+static inline pte_t * pte_alloc_one(struct mm_struct *mm, unsigned long vmaddr)
 {
 	pte_t *pte;
         int i;
@@ -151,7 +151,7 @@
 	return pte;
 }
 
-extern __inline__ pte_t* pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
+static __inline__ pte_t* pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
         unsigned long *ret = (unsigned long *) pte_quicklist;
 
@@ -163,14 +163,14 @@
         return (pte_t *)ret;
 }
 
-extern __inline__ void pte_free_fast (pte_t *pte)
+static __inline__ void pte_free_fast (pte_t *pte)
 {
 	*(unsigned long *) pte = (unsigned long) pte_quicklist;
 	pte_quicklist = (unsigned long *) pte;
 	pgtable_cache_size++;
 }
 
-extern __inline__ void pte_free_slow (pte_t *pte)
+static __inline__ void pte_free_slow (pte_t *pte)
 {
         free_page((unsigned long) pte);
 }
@@ -301,7 +301,7 @@
 
 #endif
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
                                       unsigned long start, unsigned long end)
 {
         /* S/390 does not keep any page table caches in TLB */
diff -rbNu linux-2.4.20-std/include/asm-s390x/pgtable.h linux-2.4.20-kfi/include/asm-s390x/pgtable.h
--- linux-2.4.20-std/include/asm-s390x/pgtable.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/pgtable.h	2004-12-30 22:15:22.000000000 +0100
@@ -225,7 +225,7 @@
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
  */
-extern inline void set_pte(pte_t *pteptr, pte_t pteval)
+static inline void set_pte(pte_t *pteptr, pte_t pteval)
 {
 	if ((pte_val(pteval) & (_PAGE_MKCLEAN|_PAGE_INVALID))
 	    == _PAGE_MKCLEAN) 
@@ -244,7 +244,7 @@
 /*
  * pgd/pmd/pte query functions
  */
-extern inline int __pgd_present(pgd_t *pgd)
+static inline int __pgd_present(pgd_t *pgd)
 {
 	unsigned long addr = (unsigned long) pgd;
 	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
@@ -260,13 +260,13 @@
 }
 #define pgd_present(pgd) __pgd_present(&(pgd))
 
-extern inline int __pgd_none(pgd_t *pgd)
+static inline int __pgd_none(pgd_t *pgd)
 {
 	return !__pgd_present(pgd);
 }
 #define pgd_none(pgd) __pgd_none(&(pgd))
 
-extern inline int __pgd_bad(pgd_t *pgd)
+static inline int __pgd_bad(pgd_t *pgd)
 {
 	unsigned long addr = (unsigned long) pgd;
 	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
@@ -276,27 +276,27 @@
 }
 #define pgd_bad(pgd) __pgd_bad(&(pgd))
 
-extern inline int pmd_present(pmd_t pmd)
+static inline int pmd_present(pmd_t pmd)
 {
 	return (pmd_val(pmd) & ~PAGE_MASK) == _PMD_ENTRY;
 }
 
-extern inline int pmd_none(pmd_t pmd)
+static inline int pmd_none(pmd_t pmd)
 {
 	return pmd_val(pmd) & _PMD_ENTRY_INV;
 }
 
-extern inline int pmd_bad(pmd_t pmd)
+static inline int pmd_bad(pmd_t pmd)
 {
 	return (pmd_val(pmd) & (~PAGE_MASK & ~_PMD_ENTRY_INV)) != _PMD_ENTRY;
 }
 
-extern inline int pte_present(pte_t pte)
+static inline int pte_present(pte_t pte)
 {
 	return pte_val(pte) & _PAGE_PRESENT;
 }
 
-extern inline int pte_none(pte_t pte)
+static inline int pte_none(pte_t pte)
 {
 	return ((pte_val(pte) & 
 		 (_PAGE_INVALID | _PAGE_RO | _PAGE_PRESENT)) == _PAGE_INVALID);
@@ -308,12 +308,12 @@
  * query functions pte_write/pte_dirty/pte_young only work if
  * pte_present() is true. Undefined behaviour if not..
  */
-extern inline int pte_write(pte_t pte)
+static inline int pte_write(pte_t pte)
 {
 	return (pte_val(pte) & _PAGE_RO) == 0;
 }
 
-extern inline int pte_dirty(pte_t pte)
+static inline int pte_dirty(pte_t pte)
 {
 	int skey;
 
@@ -323,7 +323,7 @@
 	return skey & _PAGE_CHANGED;
 }
 
-extern inline int pte_young(pte_t pte)
+static inline int pte_young(pte_t pte)
 {
 	int skey;
 
@@ -334,7 +334,7 @@
 /*
  * pgd/pmd/pte modification functions
  */
-extern inline void pgd_clear(pgd_t * pgdp)
+static inline void pgd_clear(pgd_t * pgdp)
 {
 	unsigned long addr = (unsigned long) pgdp;
 	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
@@ -359,13 +359,13 @@
 	*pgd_slot = _PGD_ENTRY_INV;
 }
 
-extern inline void pmd_clear(pmd_t * pmdp)
+static inline void pmd_clear(pmd_t * pmdp)
 {
 	pmd_val(*pmdp) = _PMD_ENTRY_INV | _PMD_ENTRY;
 	pmd_val1(*pmdp) = _PMD_ENTRY_INV | _PMD_ENTRY;
 }
 
-extern inline void pte_clear(pte_t *ptep)
+static inline void pte_clear(pte_t *ptep)
 {
 	pte_val(*ptep) = _PAGE_INVALID;
 }
@@ -376,26 +376,26 @@
  * The following pte_modification functions only work if 
  * pte_present() is true. Undefined behaviour if not..
  */
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte_val(pte) &= PAGE_MASK | _PAGE_ISCLEAN;
 	pte_val(pte) |= pgprot_val(newprot) & ~_PAGE_ISCLEAN;
 	return pte; 
 }
 
-extern inline pte_t pte_wrprotect(pte_t pte)
+static inline pte_t pte_wrprotect(pte_t pte)
 {
 	pte_val(pte) |= _PAGE_RO;
 	return pte;
 }
 
-extern inline pte_t pte_mkwrite(pte_t pte)
+static inline pte_t pte_mkwrite(pte_t pte)
 {
 	pte_val(pte) &= ~_PAGE_RO;
 	return pte;
 }
 
-extern inline pte_t pte_mkclean(pte_t pte)
+static inline pte_t pte_mkclean(pte_t pte)
 {
 	/* The only user of pte_mkclean is the fork() code.
 	   We must *not* clear the *physical* page dirty bit
@@ -404,7 +404,7 @@
 	return pte;
 }
 
-extern inline pte_t pte_mkdirty(pte_t pte)
+static inline pte_t pte_mkdirty(pte_t pte)
 { 
 	/* We do not explicitly set the dirty bit because the
 	 * sske instruction is slow. It is faster to let the
@@ -414,13 +414,13 @@
 	return pte;
 }
 
-extern inline pte_t pte_mkold(pte_t pte)
+static inline pte_t pte_mkold(pte_t pte)
 {
 	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)) : "cc" );
 	return pte;
 }
 
-extern inline pte_t pte_mkyoung(pte_t pte)
+static inline pte_t pte_mkyoung(pte_t pte)
 {
 	/* To set the referenced bit we read the first word from the real
 	 * page with a special instruction: load using real address (lura).
@@ -478,7 +478,7 @@
  * Conversion functions: convert a page and protection to a page entry,
  * and a page entry and page directory to the page they refer to.
  */
-extern inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
+static inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
 {
 	pte_t __pte;
 	pte_val(__pte) = physpage + pgprot_val(pgprot);
@@ -540,7 +540,7 @@
  * 0000000000111111111122222222223333333333444444444455555555556666
  * 0123456789012345678901234567890123456789012345678901234567890123
  */
-extern inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
+static inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
 {
 	pte_t pte;
 	pte_val(pte) = (type << 1) | (offset << 12) | _PAGE_INVALID | _PAGE_RO;
diff -rbNu linux-2.4.20-std/include/asm-s390x/processor.h linux-2.4.20-kfi/include/asm-s390x/processor.h
--- linux-2.4.20-std/include/asm-s390x/processor.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/processor.h	2004-12-30 22:15:22.000000000 +0100
@@ -142,7 +142,7 @@
  * schedule, so we have to walk the backchain one time to
  * find the frame schedule() store its return address.
  */
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	unsigned long bc;
 	bc = *((unsigned long *) t->ksp);
diff -rbNu linux-2.4.20-std/include/asm-s390x/s390mach.h linux-2.4.20-kfi/include/asm-s390x/s390mach.h
--- linux-2.4.20-std/include/asm-s390x/s390mach.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/s390mach.h	2004-12-30 22:15:22.000000000 +0100
@@ -103,7 +103,7 @@
 void s390_do_machine_check  ( void );
 void s390_do_crw_pending    ( crwe_t *pcrwe );
 
-extern __inline__ int stcrw( __u32 *pcrw )
+static __inline__ int stcrw( __u32 *pcrw )
 {
         int ccode;
 
diff -rbNu linux-2.4.20-std/include/asm-s390x/sigp.h linux-2.4.20-kfi/include/asm-s390x/sigp.h
--- linux-2.4.20-std/include/asm-s390x/sigp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/sigp.h	2004-12-30 22:15:22.000000000 +0100
@@ -67,7 +67,7 @@
 /*
  * Signal processor
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor(__u16 cpu_addr, sigp_order_code order_code)
 {
 	sigp_ccode ccode;
@@ -86,7 +86,7 @@
 /*
  * Signal processor with parameter
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor_p(__u64 parameter,__u16 cpu_addr,sigp_order_code order_code)
 {
 	sigp_ccode ccode;
@@ -106,7 +106,7 @@
 /*
  * Signal processor with parameter and return status
  */
-extern __inline__ sigp_ccode
+static __inline__ sigp_ccode
 signal_processor_ps(__u32 *statusptr, __u64 parameter,
 		    __u16 cpu_addr, sigp_order_code order_code)
 {
diff -rbNu linux-2.4.20-std/include/asm-s390x/smp.h linux-2.4.20-kfi/include/asm-s390x/smp.h
--- linux-2.4.20-std/include/asm-s390x/smp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/smp.h	2004-12-30 22:15:22.000000000 +0100
@@ -44,17 +44,17 @@
 
 #define smp_processor_id() (current->processor)
 
-extern __inline__ int cpu_logical_map(int cpu)
+static __inline__ int cpu_logical_map(int cpu)
 {
         return cpu;
 }
 
-extern __inline__ int cpu_number_map(int cpu)
+static __inline__ int cpu_number_map(int cpu)
 {
         return cpu;
 }
 
-extern __inline__ __u16 hard_smp_processor_id(void)
+static __inline__ __u16 hard_smp_processor_id(void)
 {
         __u16 cpu_address;
  
diff -rbNu linux-2.4.20-std/include/asm-s390x/smplock.h linux-2.4.20-kfi/include/asm-s390x/smplock.h
--- linux-2.4.20-std/include/asm-s390x/smplock.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/smplock.h	2004-12-30 22:15:22.000000000 +0100
@@ -48,13 +48,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
         if (!++current->lock_depth)
                 spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
         if (--current->lock_depth < 0)
                 spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-s390x/spinlock.h linux-2.4.20-kfi/include/asm-s390x/spinlock.h
--- linux-2.4.20-std/include/asm-s390x/spinlock.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-s390x/spinlock.h	2004-12-30 22:15:22.000000000 +0100
@@ -41,7 +41,7 @@
 #define spin_unlock_wait(lp)	do { barrier(); } while(((volatile spinlock_t *)(lp))->lock)
 #define spin_is_locked(x) ((x)->lock != 0)
 
-extern inline void spin_lock(spinlock_t *lp)
+static inline void spin_lock(spinlock_t *lp)
 {
 	unsigned long reg1, reg2;
         __asm__ __volatile("    bras  %1,1f\n"
@@ -54,7 +54,7 @@
 			   : "cc", "memory" );
 }
 
-extern inline int spin_trylock(spinlock_t *lp)
+static inline int spin_trylock(spinlock_t *lp)
 {
 	unsigned int result, reg;
 	__asm__ __volatile("    slr   %0,%0\n"
@@ -65,7 +65,7 @@
 	return !result;
 }
 
-extern inline void spin_unlock(spinlock_t *lp)
+static inline void spin_unlock(spinlock_t *lp)
 {
 	__asm__ __volatile("    xc 0(4,%0),0(%0)\n"
                            "    bcr 15,0"
diff -rbNu linux-2.4.20-std/include/asm-s390x/uaccess.h linux-2.4.20-kfi/include/asm-s390x/uaccess.h
--- linux-2.4.20-std/include/asm-s390x/uaccess.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-s390x/uaccess.h	2004-12-30 22:15:22.000000000 +0100
@@ -46,7 +46,7 @@
 
 #define access_ok(type,addr,size) __access_ok(addr,size)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
         return access_ok(type,addr,size)?0:-EFAULT;
 }
@@ -78,7 +78,7 @@
  * use the right size if we just have the right pointer type.
  */
 
-extern inline int __put_user_asm_8(__u64 x, void *ptr)
+static inline int __put_user_asm_8(__u64 x, void *ptr)
 {
         int err;
 
@@ -100,7 +100,7 @@
                                 : "cc", "4" );
         return err;
 }
-extern inline int __put_user_asm_4(__u32 x, void *ptr)
+static inline int __put_user_asm_4(__u32 x, void *ptr)
 {
         int err;
 
@@ -123,7 +123,7 @@
         return err;
 }
 
-extern inline int __put_user_asm_2(__u16 x, void *ptr)
+static inline int __put_user_asm_2(__u16 x, void *ptr)
 {
         int err;
 
@@ -146,7 +146,7 @@
         return err;
 }
 
-extern inline int __put_user_asm_1(__u8 x, void *ptr)
+static inline int __put_user_asm_1(__u8 x, void *ptr)
 {
         int err;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/btfixup.h linux-2.4.20-kfi/include/asm-sparc/btfixup.h
--- linux-2.4.20-std/include/asm-sparc/btfixup.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/btfixup.h	2004-12-30 22:15:16.000000000 +0100
@@ -51,7 +51,7 @@
 #define BTFIXUPDEF_SIMM13(__name)							\
 	extern unsigned int ___sf_##__name(void) __attribute__((const));		\
 	extern unsigned ___ss_##__name[2];						\
-	extern __inline__ unsigned int ___sf_##__name(void) {				\
+	static __inline__ unsigned int ___sf_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("or %%g0, ___s_" #__name ", %0" : "=r"(ret));			\
 		return ret;								\
@@ -59,7 +59,7 @@
 #define BTFIXUPDEF_SIMM13_INIT(__name,__val)						\
 	extern unsigned int ___sf_##__name(void) __attribute__((const));		\
 	extern unsigned ___ss_##__name[2];						\
-	extern __inline__ unsigned int ___sf_##__name(void) {				\
+	static __inline__ unsigned int ___sf_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("or %%g0, ___s_" #__name "__btset_" #__val ", %0" : "=r"(ret));\
 		return ret;								\
@@ -73,7 +73,7 @@
 #define BTFIXUPDEF_HALF(__name)								\
 	extern unsigned int ___af_##__name(void) __attribute__((const));		\
 	extern unsigned ___as_##__name[2];						\
-	extern __inline__ unsigned int ___af_##__name(void) {				\
+	static __inline__ unsigned int ___af_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("or %%g0, ___a_" #__name ", %0" : "=r"(ret));			\
 		return ret;								\
@@ -81,7 +81,7 @@
 #define BTFIXUPDEF_HALF_INIT(__name,__val)						\
 	extern unsigned int ___af_##__name(void) __attribute__((const));		\
 	extern unsigned ___as_##__name[2];						\
-	extern __inline__ unsigned int ___af_##__name(void) {				\
+	static __inline__ unsigned int ___af_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("or %%g0, ___a_" #__name "__btset_" #__val ", %0" : "=r"(ret));\
 		return ret;								\
@@ -92,7 +92,7 @@
 #define BTFIXUPDEF_SETHI(__name)							\
 	extern unsigned int ___hf_##__name(void) __attribute__((const));		\
 	extern unsigned ___hs_##__name[2];						\
-	extern __inline__ unsigned int ___hf_##__name(void) {				\
+	static __inline__ unsigned int ___hf_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("sethi %%hi(___h_" #__name "), %0" : "=r"(ret));		\
 		return ret;								\
@@ -100,7 +100,7 @@
 #define BTFIXUPDEF_SETHI_INIT(__name,__val)						\
 	extern unsigned int ___hf_##__name(void) __attribute__((const));		\
 	extern unsigned ___hs_##__name[2];						\
-	extern __inline__ unsigned int ___hf_##__name(void) {				\
+	static __inline__ unsigned int ___hf_##__name(void) {				\
 		unsigned int ret;							\
 		__asm__ ("sethi %%hi(___h_" #__name "__btset_" #__val "), %0" : 	\
 			 "=r"(ret));							\
diff -rbNu linux-2.4.20-std/include/asm-sparc/cache.h linux-2.4.20-kfi/include/asm-sparc/cache.h
--- linux-2.4.20-std/include/asm-sparc/cache.h	1999-08-31 20:23:30.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/cache.h	2004-12-30 22:15:17.000000000 +0100
@@ -33,7 +33,7 @@
  */
 
 /* First, cache-tag access. */
-extern __inline__ unsigned int get_icache_tag(int setnum, int tagnum)
+static __inline__ unsigned int get_icache_tag(int setnum, int tagnum)
 {
 	unsigned int vaddr, retval;
 
@@ -44,7 +44,7 @@
 	return retval;
 }
 
-extern __inline__ void put_icache_tag(int setnum, int tagnum, unsigned int entry)
+static __inline__ void put_icache_tag(int setnum, int tagnum, unsigned int entry)
 {
 	unsigned int vaddr;
 
@@ -57,7 +57,7 @@
 /* Second cache-data access.  The data is returned two-32bit quantities
  * at a time.
  */
-extern __inline__ void get_icache_data(int setnum, int tagnum, int subblock,
+static __inline__ void get_icache_data(int setnum, int tagnum, int subblock,
 				       unsigned int *data)
 {
 	unsigned int value1, value2, vaddr;
@@ -73,7 +73,7 @@
 	data[0] = value1; data[1] = value2;
 }
 
-extern __inline__ void put_icache_data(int setnum, int tagnum, int subblock,
+static __inline__ void put_icache_data(int setnum, int tagnum, int subblock,
 				       unsigned int *data)
 {
 	unsigned int value1, value2, vaddr;
@@ -98,35 +98,35 @@
  */
 
 /* Flushes which clear out both the on-chip and external caches */
-extern __inline__ void flush_ei_page(unsigned int addr)
+static __inline__ void flush_ei_page(unsigned int addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_PAGE) :
 			     "memory");
 }
 
-extern __inline__ void flush_ei_seg(unsigned int addr)
+static __inline__ void flush_ei_seg(unsigned int addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_SEG) :
 			     "memory");
 }
 
-extern __inline__ void flush_ei_region(unsigned int addr)
+static __inline__ void flush_ei_region(unsigned int addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_REGION) :
 			     "memory");
 }
 
-extern __inline__ void flush_ei_ctx(unsigned int addr)
+static __inline__ void flush_ei_ctx(unsigned int addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_CTX) :
 			     "memory");
 }
 
-extern __inline__ void flush_ei_user(unsigned int addr)
+static __inline__ void flush_ei_user(unsigned int addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_USER) :
diff -rbNu linux-2.4.20-std/include/asm-sparc/checksum.h linux-2.4.20-kfi/include/asm-sparc/checksum.h
--- linux-2.4.20-std/include/asm-sparc/checksum.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/checksum.h	2004-12-30 22:15:16.000000000 +0100
@@ -48,7 +48,7 @@
   
 extern unsigned int __csum_partial_copy_sparc_generic (const char *, char *);
 
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_partial_copy_nocheck (const char *src, char *dst, int len, 
 			   unsigned int sum)
 {
@@ -64,7 +64,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_partial_copy_from_user(const char *src, char *dst, int len, 
 			    unsigned int sum, int *err)
   {
@@ -92,7 +92,7 @@
 	}
   }
   
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_partial_copy_to_user(const char *src, char *dst, int len, 
 			  unsigned int sum, int *err)
 {
@@ -125,7 +125,7 @@
 /* ihl is always 5 or greater, almost always is 5, and iph is word aligned
  * the majority of the time.
  */
-extern __inline__ unsigned short ip_fast_csum(__const__ unsigned char *iph,
+static __inline__ unsigned short ip_fast_csum(__const__ unsigned char *iph,
 					      unsigned int ihl)
 {
 	unsigned short sum;
@@ -163,7 +163,7 @@
 }
 
 /* Fold a partial checksum without adding pseudo headers. */
-extern __inline__ unsigned int csum_fold(unsigned int sum)
+static __inline__ unsigned int csum_fold(unsigned int sum)
 {
 	unsigned int tmp;
 
@@ -177,7 +177,7 @@
 	return sum;
 }
 
-extern __inline__ unsigned long csum_tcpudp_nofold(unsigned long saddr,
+static __inline__ unsigned long csum_tcpudp_nofold(unsigned long saddr,
 						   unsigned long daddr,
 						   unsigned int len,
 						   unsigned short proto,
@@ -244,7 +244,7 @@
 }
 
 /* this routine is used for miscellaneous IP-like checksums, mainly in icmp.c */
-extern __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len)
+static __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len)
 {
 	return csum_fold(csum_partial(buff, len, 0));
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/cypress.h linux-2.4.20-kfi/include/asm-sparc/cypress.h
--- linux-2.4.20-std/include/asm-sparc/cypress.h	1996-11-09 09:29:16.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/cypress.h	2004-12-30 22:15:17.000000000 +0100
@@ -48,25 +48,25 @@
 #define CYPRESS_NFAULT    0x00000002
 #define CYPRESS_MENABLE   0x00000001
 
-extern __inline__ void cypress_flush_page(unsigned long page)
+static __inline__ void cypress_flush_page(unsigned long page)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (page), "i" (ASI_M_FLUSH_PAGE));
 }
 
-extern __inline__ void cypress_flush_segment(unsigned long addr)
+static __inline__ void cypress_flush_segment(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_SEG));
 }
 
-extern __inline__ void cypress_flush_region(unsigned long addr)
+static __inline__ void cypress_flush_region(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_REGION));
 }
 
-extern __inline__ void cypress_flush_context(void)
+static __inline__ void cypress_flush_context(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_FLUSH_CTX));
diff -rbNu linux-2.4.20-std/include/asm-sparc/delay.h linux-2.4.20-kfi/include/asm-sparc/delay.h
--- linux-2.4.20-std/include/asm-sparc/delay.h	2001-01-01 19:37:41.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/delay.h	2004-12-30 22:15:17.000000000 +0100
@@ -9,7 +9,7 @@
 
 extern unsigned long loops_per_jiffy;
 
-extern __inline__ void __delay(unsigned long loops)
+static __inline__ void __delay(unsigned long loops)
 {
 	__asm__ __volatile__("cmp %0, 0\n\t"
 			     "1: bne 1b\n\t"
diff -rbNu linux-2.4.20-std/include/asm-sparc/dma.h linux-2.4.20-kfi/include/asm-sparc/dma.h
--- linux-2.4.20-std/include/asm-sparc/dma.h	2000-01-03 21:01:31.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/dma.h	2004-12-30 22:15:17.000000000 +0100
@@ -197,7 +197,7 @@
 /* Pause until counter runs out or BIT isn't set in the DMA condition
  * register.
  */
-extern __inline__ void sparc_dma_pause(struct sparc_dma_registers *regs,
+static __inline__ void sparc_dma_pause(struct sparc_dma_registers *regs,
 				       unsigned long bit)
 {
 	int ctr = 50000;   /* Let's find some bugs ;) */
diff -rbNu linux-2.4.20-std/include/asm-sparc/iommu.h linux-2.4.20-kfi/include/asm-sparc/iommu.h
--- linux-2.4.20-std/include/asm-sparc/iommu.h	1996-11-09 20:40:09.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/iommu.h	2004-12-30 22:15:17.000000000 +0100
@@ -107,12 +107,12 @@
 	unsigned long end;   /* Last managed virtual address */
 };
 
-extern __inline__ void iommu_invalidate(struct iommu_regs *regs)
+static __inline__ void iommu_invalidate(struct iommu_regs *regs)
 {
 	regs->tlbflush = 0;
 }
 
-extern __inline__ void iommu_invalidate_page(struct iommu_regs *regs, unsigned long page)
+static __inline__ void iommu_invalidate_page(struct iommu_regs *regs, unsigned long page)
 {
 	regs->pageflush = (page & PAGE_MASK);
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/kdebug.h linux-2.4.20-kfi/include/asm-sparc/kdebug.h
--- linux-2.4.20-std/include/asm-sparc/kdebug.h	2000-06-20 02:59:39.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/kdebug.h	2004-12-30 22:15:17.000000000 +0100
@@ -46,7 +46,7 @@
 extern struct kernel_debug *linux_dbvec;
 
 /* Use this macro in C-code to enter the debugger. */
-extern __inline__ void sp_enter_debugger(void)
+static __inline__ void sp_enter_debugger(void)
 {
 	__asm__ __volatile__("jmpl %0, %%o7\n\t"
 			     "nop\n\t" : :
diff -rbNu linux-2.4.20-std/include/asm-sparc/mbus.h linux-2.4.20-kfi/include/asm-sparc/mbus.h
--- linux-2.4.20-std/include/asm-sparc/mbus.h	1997-07-07 17:18:55.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/mbus.h	2004-12-30 22:15:17.000000000 +0100
@@ -83,7 +83,7 @@
  */
 #define TBR_ID_SHIFT            20
 
-extern __inline__ int get_cpuid(void)
+static __inline__ int get_cpuid(void)
 {
 	register int retval;
 	__asm__ __volatile__("rd %%tbr, %0\n\t"
@@ -93,7 +93,7 @@
 	return (retval & 3);
 }
 
-extern __inline__ int get_modid(void)
+static __inline__ int get_modid(void)
 {
 	return (get_cpuid() | 0x8);
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/msi.h linux-2.4.20-kfi/include/asm-sparc/msi.h
--- linux-2.4.20-std/include/asm-sparc/msi.h	1996-11-09 09:29:46.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/msi.h	2004-12-30 22:15:17.000000000 +0100
@@ -19,7 +19,7 @@
 #define MSI_ASYNC_MODE  0x80000000	/* Operate the MSI asynchronously */
 
 
-extern __inline__ void msi_set_sync(void)
+static __inline__ void msi_set_sync(void)
 {
 	__asm__ __volatile__ ("lda [%0] %1, %%g3\n\t"
 			      "andn %%g3, %2, %%g3\n\t"
diff -rbNu linux-2.4.20-std/include/asm-sparc/mxcc.h linux-2.4.20-kfi/include/asm-sparc/mxcc.h
--- linux-2.4.20-std/include/asm-sparc/mxcc.h	1997-04-24 04:01:28.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/mxcc.h	2004-12-30 22:15:17.000000000 +0100
@@ -85,7 +85,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ void mxcc_set_stream_src(unsigned long *paddr)
+static __inline__ void mxcc_set_stream_src(unsigned long *paddr)
 {
 	unsigned long data0 = paddr[0];
 	unsigned long data1 = paddr[1];
@@ -98,7 +98,7 @@
 			      "i" (ASI_M_MXCC) : "g2", "g3");
 }
 
-extern __inline__ void mxcc_set_stream_dst(unsigned long *paddr)
+static __inline__ void mxcc_set_stream_dst(unsigned long *paddr)
 {
 	unsigned long data0 = paddr[0];
 	unsigned long data1 = paddr[1];
@@ -111,7 +111,7 @@
 			      "i" (ASI_M_MXCC) : "g2", "g3");
 }
 
-extern __inline__ unsigned long mxcc_get_creg(void)
+static __inline__ unsigned long mxcc_get_creg(void)
 {
 	unsigned long mxcc_control;
 
@@ -125,7 +125,7 @@
 	return mxcc_control;
 }
 
-extern __inline__ void mxcc_set_creg(unsigned long mxcc_control)
+static __inline__ void mxcc_set_creg(unsigned long mxcc_control)
 {
 	__asm__ __volatile__("sta %0, [%1] %2\n\t" : :
 			     "r" (mxcc_control), "r" (MXCC_CREG),
diff -rbNu linux-2.4.20-std/include/asm-sparc/obio.h linux-2.4.20-kfi/include/asm-sparc/obio.h
--- linux-2.4.20-std/include/asm-sparc/obio.h	1998-04-15 02:44:23.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/obio.h	2004-12-30 22:15:17.000000000 +0100
@@ -98,7 +98,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ int bw_get_intr_mask(int sbus_level)
+static __inline__ int bw_get_intr_mask(int sbus_level)
 {
 	int mask;
 	
@@ -109,7 +109,7 @@
 	return mask;
 }
 
-extern __inline__ void bw_clear_intr_mask(int sbus_level, int mask)
+static __inline__ void bw_clear_intr_mask(int sbus_level, int mask)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (mask),
@@ -117,7 +117,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ unsigned bw_get_prof_limit(int cpu)
+static __inline__ unsigned bw_get_prof_limit(int cpu)
 {
 	unsigned limit;
 	
@@ -128,7 +128,7 @@
 	return limit;
 }
 
-extern __inline__ void bw_set_prof_limit(int cpu, unsigned limit)
+static __inline__ void bw_set_prof_limit(int cpu, unsigned limit)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (limit),
@@ -136,7 +136,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ unsigned bw_get_ctrl(int cpu)
+static __inline__ unsigned bw_get_ctrl(int cpu)
 {
 	unsigned ctrl;
 	
@@ -147,7 +147,7 @@
 	return ctrl;
 }
 
-extern __inline__ void bw_set_ctrl(int cpu, unsigned ctrl)
+static __inline__ void bw_set_ctrl(int cpu, unsigned ctrl)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (ctrl),
@@ -157,7 +157,7 @@
 
 extern unsigned char cpu_leds[32];
 
-extern __inline__ void show_leds(int cpuid)
+static __inline__ void show_leds(int cpuid)
 {
 	cpuid &= 0x1e;
 	__asm__ __volatile__ ("stba %0, [%1] %2" : :
@@ -166,7 +166,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ unsigned cc_get_ipen(void)
+static __inline__ unsigned cc_get_ipen(void)
 {
 	unsigned pending;
 	
@@ -177,7 +177,7 @@
 	return pending;
 }
 
-extern __inline__ void cc_set_iclr(unsigned clear)
+static __inline__ void cc_set_iclr(unsigned clear)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (clear),
@@ -185,7 +185,7 @@
 			      "i" (ASI_M_MXCC));
 }
 
-extern __inline__ unsigned cc_get_imsk(void)
+static __inline__ unsigned cc_get_imsk(void)
 {
 	unsigned mask;
 	
@@ -196,7 +196,7 @@
 	return mask;
 }
 
-extern __inline__ void cc_set_imsk(unsigned mask)
+static __inline__ void cc_set_imsk(unsigned mask)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (mask),
@@ -204,7 +204,7 @@
 			      "i" (ASI_M_MXCC));
 }
 
-extern __inline__ unsigned cc_get_imsk_other(int cpuid)
+static __inline__ unsigned cc_get_imsk_other(int cpuid)
 {
 	unsigned mask;
 	
@@ -215,7 +215,7 @@
 	return mask;
 }
 
-extern __inline__ void cc_set_imsk_other(int cpuid, unsigned mask)
+static __inline__ void cc_set_imsk_other(int cpuid, unsigned mask)
 {
 	__asm__ __volatile__ ("stha %0, [%1] %2" : :
 			      "r" (mask),
@@ -223,7 +223,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ void cc_set_igen(unsigned gen)
+static __inline__ void cc_set_igen(unsigned gen)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (gen),
@@ -239,7 +239,7 @@
 #define IGEN_MESSAGE(bcast, devid, sid, levels) \
 	(((bcast) << 31) | ((devid) << 23) | ((sid) << 15) | (levels))
             
-extern __inline__ void sun4d_send_ipi(int cpu, int level)
+static __inline__ void sun4d_send_ipi(int cpu, int level)
 {
 	cc_set_igen(IGEN_MESSAGE(0, cpu << 3, 6 + ((level >> 1) & 7), 1 << (level - 1)));
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/page.h linux-2.4.20-kfi/include/asm-sparc/page.h
--- linux-2.4.20-std/include/asm-sparc/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/page.h	2004-12-30 22:15:16.000000000 +0100
@@ -151,7 +151,7 @@
 #define TASK_UNMAPPED_BASE	BTFIXUP_SETHI(sparc_unmapped_base)
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/pci.h linux-2.4.20-kfi/include/asm-sparc/pci.h
--- linux-2.4.20-std/include/asm-sparc/pci.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/pci.h	2004-12-30 22:15:16.000000000 +0100
@@ -14,12 +14,12 @@
 
 #define PCI_IRQ_NONE		0xffffffff
 
-extern inline void pcibios_set_master(struct pci_dev *dev)
+static inline void pcibios_set_master(struct pci_dev *dev)
 {
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
@@ -130,7 +130,7 @@
  * only drive the low 24-bits during PCI bus mastering, then
  * you would pass 0x00ffffff as the mask to this function.
  */
-extern inline int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
+static inline int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
 {
 	return 1;
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/pgalloc.h linux-2.4.20-kfi/include/asm-sparc/pgalloc.h
--- linux-2.4.20-std/include/asm-sparc/pgalloc.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/pgalloc.h	2004-12-30 22:15:16.000000000 +0100
@@ -70,7 +70,7 @@
 BTFIXUPDEF_CALL(void, flush_tlb_range, struct mm_struct *, unsigned long, unsigned long)
 BTFIXUPDEF_CALL(void, flush_tlb_page, struct vm_area_struct *, unsigned long)
 
-extern __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start, unsigned long end)
+static __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start, unsigned long end)
 {
 }
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/pgtable.h linux-2.4.20-kfi/include/asm-sparc/pgtable.h
--- linux-2.4.20-std/include/asm-sparc/pgtable.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/pgtable.h	2004-12-30 22:15:16.000000000 +0100
@@ -67,7 +67,7 @@
 BTFIXUPDEF_SETHI(pmd_mask)
 
 extern unsigned int pmd_align(unsigned int addr) __attribute__((const));
-extern __inline__ unsigned int pmd_align(unsigned int addr)
+static __inline__ unsigned int pmd_align(unsigned int addr)
 {
 	return ((addr + ~BTFIXUP_SETHI(pmd_mask)) & BTFIXUP_SETHI(pmd_mask));
 }
@@ -77,7 +77,7 @@
 BTFIXUPDEF_SETHI(pgdir_mask)
 
 extern unsigned int pgdir_align(unsigned int addr) __attribute__((const));
-extern __inline__ unsigned int pgdir_align(unsigned int addr)
+static __inline__ unsigned int pgdir_align(unsigned int addr)
 {
 	return ((addr + ~BTFIXUP_SETHI(pgdir_mask)) & BTFIXUP_SETHI(pgdir_mask));
 }
@@ -203,7 +203,7 @@
 BTFIXUPDEF_CALL_CONST(int, pte_present, pte_t)
 BTFIXUPDEF_CALL(void, pte_clear, pte_t *)
 
-extern __inline__ int pte_none(pte_t pte)
+static __inline__ int pte_none(pte_t pte)
 {
 	return !(pte_val(pte) & ~BTFIXUP_SETHI(none_mask));
 }
@@ -215,7 +215,7 @@
 BTFIXUPDEF_CALL_CONST(int, pmd_present, pmd_t)
 BTFIXUPDEF_CALL(void, pmd_clear, pmd_t *)
 
-extern __inline__ int pmd_none(pmd_t pmd)
+static __inline__ int pmd_none(pmd_t pmd)
 {
 	return !(pmd_val(pmd) & ~BTFIXUP_SETHI(none_mask));
 }
@@ -243,19 +243,19 @@
 BTFIXUPDEF_HALF(pte_youngi)
 
 extern int pte_write(pte_t pte) __attribute__((const));
-extern __inline__ int pte_write(pte_t pte)
+static __inline__ int pte_write(pte_t pte)
 {
 	return pte_val(pte) & BTFIXUP_HALF(pte_writei);
 }
 
 extern int pte_dirty(pte_t pte) __attribute__((const));
-extern __inline__ int pte_dirty(pte_t pte)
+static __inline__ int pte_dirty(pte_t pte)
 {
 	return pte_val(pte) & BTFIXUP_HALF(pte_dirtyi);
 }
 
 extern int pte_young(pte_t pte) __attribute__((const));
-extern __inline__ int pte_young(pte_t pte)
+static __inline__ int pte_young(pte_t pte)
 {
 	return pte_val(pte) & BTFIXUP_HALF(pte_youngi);
 }
@@ -265,19 +265,19 @@
 BTFIXUPDEF_HALF(pte_mkoldi)
 
 extern pte_t pte_wrprotect(pte_t pte) __attribute__((const));
-extern __inline__ pte_t pte_wrprotect(pte_t pte)
+static __inline__ pte_t pte_wrprotect(pte_t pte)
 {
 	return __pte(pte_val(pte) & ~BTFIXUP_HALF(pte_wrprotecti));
 }
 
 extern pte_t pte_mkclean(pte_t pte) __attribute__((const));
-extern __inline__ pte_t pte_mkclean(pte_t pte)
+static __inline__ pte_t pte_mkclean(pte_t pte)
 {
 	return __pte(pte_val(pte) & ~BTFIXUP_HALF(pte_mkcleani));
 }
 
 extern pte_t pte_mkold(pte_t pte) __attribute__((const));
-extern __inline__ pte_t pte_mkold(pte_t pte)
+static __inline__ pte_t pte_mkold(pte_t pte)
 {
 	return __pte(pte_val(pte) & ~BTFIXUP_HALF(pte_mkoldi));
 }
@@ -318,7 +318,7 @@
 BTFIXUPDEF_INT(pte_modify_mask)
 
 extern pte_t pte_modify(pte_t pte, pgprot_t newprot) __attribute__((const));
-extern __inline__ pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static __inline__ pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	return __pte((pte_val(pte) & BTFIXUP_INT(pte_modify_mask)) |
 		pgprot_val(newprot));
@@ -392,13 +392,13 @@
 
 #define NO_CONTEXT     -1
 
-extern __inline__ void remove_from_ctx_list(struct ctx_list *entry)
+static __inline__ void remove_from_ctx_list(struct ctx_list *entry)
 {
 	entry->next->prev = entry->prev;
 	entry->prev->next = entry->next;
 }
 
-extern __inline__ void add_to_ctx_list(struct ctx_list *head, struct ctx_list *entry)
+static __inline__ void add_to_ctx_list(struct ctx_list *head, struct ctx_list *entry)
 {
 	entry->next = head;
 	(entry->prev = head->prev)->next = entry;
@@ -407,7 +407,7 @@
 #define add_to_free_ctxlist(entry) add_to_ctx_list(&ctx_free, entry)
 #define add_to_used_ctxlist(entry) add_to_ctx_list(&ctx_used, entry)
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __get_phys (unsigned long addr)
 {
 	switch (sparc_cpu_model){
@@ -422,7 +422,7 @@
 	}
 }
 
-extern __inline__ int
+static __inline__ int
 __get_iospace (unsigned long addr)
 {
 	switch (sparc_cpu_model){
diff -rbNu linux-2.4.20-std/include/asm-sparc/pgtsrmmu.h linux-2.4.20-kfi/include/asm-sparc/pgtsrmmu.h
--- linux-2.4.20-std/include/asm-sparc/pgtsrmmu.h	2000-07-18 21:29:47.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/pgtsrmmu.h	2004-12-30 22:15:17.000000000 +0100
@@ -99,7 +99,7 @@
 #ifndef __ASSEMBLY__
 
 /* Accessing the MMU control register. */
-extern __inline__ unsigned int srmmu_get_mmureg(void)
+static __inline__ unsigned int srmmu_get_mmureg(void)
 {
         unsigned int retval;
 	__asm__ __volatile__("lda [%%g0] %1, %0\n\t" :
@@ -108,14 +108,14 @@
 	return retval;
 }
 
-extern __inline__ void srmmu_set_mmureg(unsigned long regval)
+static __inline__ void srmmu_set_mmureg(unsigned long regval)
 {
 	__asm__ __volatile__("sta %0, [%%g0] %1\n\t" : :
 			     "r" (regval), "i" (ASI_M_MMUREGS) : "memory");
 
 }
 
-extern __inline__ void srmmu_set_ctable_ptr(unsigned long paddr)
+static __inline__ void srmmu_set_ctable_ptr(unsigned long paddr)
 {
 	paddr = ((paddr >> 4) & SRMMU_CTX_PMASK);
 	__asm__ __volatile__("sta %0, [%1] %2\n\t" : :
@@ -124,7 +124,7 @@
 			     "memory");
 }
 
-extern __inline__ unsigned long srmmu_get_ctable_ptr(void)
+static __inline__ unsigned long srmmu_get_ctable_ptr(void)
 {
 	unsigned int retval;
 
@@ -135,14 +135,14 @@
 	return (retval & SRMMU_CTX_PMASK) << 4;
 }
 
-extern __inline__ void srmmu_set_context(int context)
+static __inline__ void srmmu_set_context(int context)
 {
 	__asm__ __volatile__("sta %0, [%1] %2\n\t" : :
 			     "r" (context), "r" (SRMMU_CTX_REG),
 			     "i" (ASI_M_MMUREGS) : "memory");
 }
 
-extern __inline__ int srmmu_get_context(void)
+static __inline__ int srmmu_get_context(void)
 {
 	register int retval;
 	__asm__ __volatile__("lda [%1] %2, %0\n\t" :
@@ -152,7 +152,7 @@
 	return retval;
 }
 
-extern __inline__ unsigned int srmmu_get_fstatus(void)
+static __inline__ unsigned int srmmu_get_fstatus(void)
 {
 	unsigned int retval;
 
@@ -162,7 +162,7 @@
 	return retval;
 }
 
-extern __inline__ unsigned int srmmu_get_faddr(void)
+static __inline__ unsigned int srmmu_get_faddr(void)
 {
 	unsigned int retval;
 
@@ -173,7 +173,7 @@
 }
 
 /* This is guaranteed on all SRMMU's. */
-extern __inline__ void srmmu_flush_whole_tlb(void)
+static __inline__ void srmmu_flush_whole_tlb(void)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t": :
 			     "r" (0x400),        /* Flush entire TLB!! */
@@ -182,7 +182,7 @@
 }
 
 /* These flush types are not available on all chips... */
-extern __inline__ void srmmu_flush_tlb_ctx(void)
+static __inline__ void srmmu_flush_tlb_ctx(void)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t": :
 			     "r" (0x300),        /* Flush TLB ctx.. */
@@ -190,7 +190,7 @@
 
 }
 
-extern __inline__ void srmmu_flush_tlb_region(unsigned long addr)
+static __inline__ void srmmu_flush_tlb_region(unsigned long addr)
 {
 	addr &= SRMMU_PGDIR_MASK;
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t": :
@@ -200,7 +200,7 @@
 }
 
 
-extern __inline__ void srmmu_flush_tlb_segment(unsigned long addr)
+static __inline__ void srmmu_flush_tlb_segment(unsigned long addr)
 {
 	addr &= SRMMU_PMD_MASK;
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t": :
@@ -209,7 +209,7 @@
 
 }
 
-extern __inline__ void srmmu_flush_tlb_page(unsigned long page)
+static __inline__ void srmmu_flush_tlb_page(unsigned long page)
 {
 	page &= PAGE_MASK;
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t": :
@@ -218,7 +218,7 @@
 
 }
 
-extern __inline__ unsigned long srmmu_hwprobe(unsigned long vaddr)
+static __inline__ unsigned long srmmu_hwprobe(unsigned long vaddr)
 {
 	unsigned long retval;
 
@@ -230,7 +230,7 @@
 	return retval;
 }
 
-extern __inline__ int
+static __inline__ int
 srmmu_get_pte (unsigned long addr)
 {
 	register unsigned long entry;
diff -rbNu linux-2.4.20-std/include/asm-sparc/pgtsun4.h linux-2.4.20-kfi/include/asm-sparc/pgtsun4.h
--- linux-2.4.20-std/include/asm-sparc/pgtsun4.h	2000-06-20 02:59:39.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/pgtsun4.h	2004-12-30 22:15:17.000000000 +0100
@@ -76,7 +76,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ unsigned long sun4c_get_synchronous_error(void)
+static __inline__ unsigned long sun4c_get_synchronous_error(void)
 {
 	unsigned long sync_err;
 
@@ -86,7 +86,7 @@
 	return sync_err;
 }
 
-extern __inline__ unsigned long sun4c_get_synchronous_address(void)
+static __inline__ unsigned long sun4c_get_synchronous_address(void)
 {
 	unsigned long sync_addr;
 
@@ -97,7 +97,7 @@
 }
 
 /* SUN4 pte, segmap, and context manipulation */
-extern __inline__ unsigned long sun4c_get_segmap(unsigned long addr)
+static __inline__ unsigned long sun4c_get_segmap(unsigned long addr)
 {
   register unsigned long entry;
 
@@ -107,14 +107,14 @@
   return entry;
 }
 
-extern __inline__ void sun4c_put_segmap(unsigned long addr, unsigned long entry)
+static __inline__ void sun4c_put_segmap(unsigned long addr, unsigned long entry)
 {
   __asm__ __volatile__("\n\tstha %1, [%0] %2; nop; nop; nop;\n\t" : :
 		       "r" (addr), "r" (entry),
 		       "i" (ASI_SEGMAP));
 }
 
-extern __inline__ unsigned long sun4c_get_pte(unsigned long addr)
+static __inline__ unsigned long sun4c_get_pte(unsigned long addr)
 {
   register unsigned long entry;
 
@@ -124,14 +124,14 @@
   return entry;
 }
 
-extern __inline__ void sun4c_put_pte(unsigned long addr, unsigned long entry)
+static __inline__ void sun4c_put_pte(unsigned long addr, unsigned long entry)
 {
   __asm__ __volatile__("\n\tsta %1, [%0] %2; nop; nop; nop;\n\t" : :
 		       "r" (addr), 
 		       "r" ((entry & ~(_SUN4C_PAGE_PRESENT))), "i" (ASI_PTE));
 }
 
-extern __inline__ int sun4c_get_context(void)
+static __inline__ int sun4c_get_context(void)
 {
   register int ctx;
 
@@ -142,7 +142,7 @@
   return ctx;
 }
 
-extern __inline__ int sun4c_set_context(int ctx)
+static __inline__ int sun4c_set_context(int ctx)
 {
   __asm__ __volatile__("\n\tstba %0, [%1] %2; nop; nop; nop;\n\t" : :
 		       "r" (ctx), "r" (AC_CONTEXT), "i" (ASI_CONTROL));
diff -rbNu linux-2.4.20-std/include/asm-sparc/pgtsun4c.h linux-2.4.20-kfi/include/asm-sparc/pgtsun4c.h
--- linux-2.4.20-std/include/asm-sparc/pgtsun4c.h	2000-06-20 02:59:39.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/pgtsun4c.h	2004-12-30 22:15:17.000000000 +0100
@@ -75,7 +75,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ unsigned long sun4c_get_synchronous_error(void)
+static __inline__ unsigned long sun4c_get_synchronous_error(void)
 {
 	unsigned long sync_err;
 
@@ -85,7 +85,7 @@
 	return sync_err;
 }
 
-extern __inline__ unsigned long sun4c_get_synchronous_address(void)
+static __inline__ unsigned long sun4c_get_synchronous_address(void)
 {
 	unsigned long sync_addr;
 
@@ -96,7 +96,7 @@
 }
 
 /* SUN4C pte, segmap, and context manipulation */
-extern __inline__ unsigned long sun4c_get_segmap(unsigned long addr)
+static __inline__ unsigned long sun4c_get_segmap(unsigned long addr)
 {
   register unsigned long entry;
 
@@ -107,7 +107,7 @@
   return entry;
 }
 
-extern __inline__ void sun4c_put_segmap(unsigned long addr, unsigned long entry)
+static __inline__ void sun4c_put_segmap(unsigned long addr, unsigned long entry)
 {
 
   __asm__ __volatile__("\n\tstba %1, [%0] %2; nop; nop; nop;\n\t" : :
@@ -115,7 +115,7 @@
 		       "i" (ASI_SEGMAP));
 }
 
-extern __inline__ unsigned long sun4c_get_pte(unsigned long addr)
+static __inline__ unsigned long sun4c_get_pte(unsigned long addr)
 {
   register unsigned long entry;
 
@@ -125,14 +125,14 @@
   return entry;
 }
 
-extern __inline__ void sun4c_put_pte(unsigned long addr, unsigned long entry)
+static __inline__ void sun4c_put_pte(unsigned long addr, unsigned long entry)
 {
   __asm__ __volatile__("\n\tsta %1, [%0] %2; nop; nop; nop;\n\t" : :
 		       "r" (addr), 
 		       "r" ((entry & ~(_SUN4C_PAGE_PRESENT))), "i" (ASI_PTE));
 }
 
-extern __inline__ int sun4c_get_context(void)
+static __inline__ int sun4c_get_context(void)
 {
   register int ctx;
 
@@ -143,7 +143,7 @@
   return ctx;
 }
 
-extern __inline__ int sun4c_set_context(int ctx)
+static __inline__ int sun4c_set_context(int ctx)
 {
   __asm__ __volatile__("\n\tstba %0, [%1] %2; nop; nop; nop;\n\t" : :
 		       "r" (ctx), "r" (AC_CONTEXT), "i" (ASI_CONTROL));
diff -rbNu linux-2.4.20-std/include/asm-sparc/processor.h linux-2.4.20-kfi/include/asm-sparc/processor.h
--- linux-2.4.20-std/include/asm-sparc/processor.h	2001-10-11 08:42:47.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/processor.h	2004-12-30 22:15:17.000000000 +0100
@@ -115,13 +115,13 @@
 }
 
 /* Return saved PC of a blocked thread. */
-extern __inline__ unsigned long thread_saved_pc(struct thread_struct *t)
+static __inline__ unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	return t->kpc;
 }
 
 /* Do necessary setup to start up a newly executed thread. */
-extern __inline__ void start_thread(struct pt_regs * regs, unsigned long pc,
+static __inline__ void start_thread(struct pt_regs * regs, unsigned long pc,
 				    unsigned long sp)
 {
 	register unsigned long zero asm("g1");
diff -rbNu linux-2.4.20-std/include/asm-sparc/psr.h linux-2.4.20-kfi/include/asm-sparc/psr.h
--- linux-2.4.20-std/include/asm-sparc/psr.h	1998-01-13 00:15:54.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/psr.h	2004-12-30 22:15:17.000000000 +0100
@@ -38,7 +38,7 @@
 
 #ifndef __ASSEMBLY__
 /* Get the %psr register. */
-extern __inline__ unsigned int get_psr(void)
+static __inline__ unsigned int get_psr(void)
 {
 	unsigned int psr;
 	__asm__ __volatile__(
@@ -53,7 +53,7 @@
 	return psr;
 }
 
-extern __inline__ void put_psr(unsigned int new_psr)
+static __inline__ void put_psr(unsigned int new_psr)
 {
 	__asm__ __volatile__(
 		"wr	%0, 0x0, %%psr\n\t"
@@ -72,7 +72,7 @@
 
 extern unsigned int fsr_storage;
 
-extern __inline__ unsigned int get_fsr(void)
+static __inline__ unsigned int get_fsr(void)
 {
 	unsigned int fsr = 0;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/ross.h linux-2.4.20-kfi/include/asm-sparc/ross.h
--- linux-2.4.20-std/include/asm-sparc/ross.h	1998-01-13 00:15:54.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/ross.h	2004-12-30 22:15:17.000000000 +0100
@@ -96,7 +96,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ unsigned int get_ross_icr(void)
+static __inline__ unsigned int get_ross_icr(void)
 {
 	unsigned int icreg;
 
@@ -108,7 +108,7 @@
 	return icreg;
 }
 
-extern __inline__ void put_ross_icr(unsigned int icreg)
+static __inline__ void put_ross_icr(unsigned int icreg)
 {
 	__asm__ __volatile__("or %%g0, %0, %%g1\n\t"
 			     ".word 0xbf806000\n\t" /* wr %g1, 0x0, %iccr */
@@ -124,7 +124,7 @@
 /* HyperSparc specific cache flushing. */
 
 /* This is for the on-chip instruction cache. */
-extern __inline__ void hyper_flush_whole_icache(void)
+static __inline__ void hyper_flush_whole_icache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_FLUSH_IWHOLE));
@@ -134,7 +134,7 @@
 extern int vac_cache_size;
 extern int vac_line_size;
 
-extern __inline__ void hyper_clear_all_tags(void)
+static __inline__ void hyper_clear_all_tags(void)
 {
 	unsigned long addr;
 
@@ -143,7 +143,7 @@
 				     "r" (addr), "i" (ASI_M_DATAC_TAG));
 }
 
-extern __inline__ void hyper_flush_unconditional_combined(void)
+static __inline__ void hyper_flush_unconditional_combined(void)
 {
 	unsigned long addr;
 
@@ -152,7 +152,7 @@
 				     "r" (addr), "i" (ASI_M_FLUSH_CTX));
 }
 
-extern __inline__ void hyper_flush_cache_user(void)
+static __inline__ void hyper_flush_cache_user(void)
 {
 	unsigned long addr;
 
@@ -161,7 +161,7 @@
 				     "r" (addr), "i" (ASI_M_FLUSH_USER));
 }
 
-extern __inline__ void hyper_flush_cache_page(unsigned long page)
+static __inline__ void hyper_flush_cache_page(unsigned long page)
 {
 	unsigned long end;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/sbi.h linux-2.4.20-kfi/include/asm-sparc/sbi.h
--- linux-2.4.20-std/include/asm-sparc/sbi.h	1998-04-15 02:44:23.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/sbi.h	2004-12-30 22:15:17.000000000 +0100
@@ -65,7 +65,7 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ int acquire_sbi(int devid, int mask)
+static __inline__ int acquire_sbi(int devid, int mask)
 {
 	__asm__ __volatile__ ("swapa [%2] %3, %0" :
 			      "=r" (mask) :
@@ -75,7 +75,7 @@
 	return mask;
 }
 
-extern __inline__ void release_sbi(int devid, int mask)
+static __inline__ void release_sbi(int devid, int mask)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (mask),
@@ -83,7 +83,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ void set_sbi_tid(int devid, int targetid)
+static __inline__ void set_sbi_tid(int devid, int targetid)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (targetid),
@@ -91,7 +91,7 @@
 			      "i" (ASI_M_CTL));
 }
 
-extern __inline__ int get_sbi_ctl(int devid, int cfgno)
+static __inline__ int get_sbi_ctl(int devid, int cfgno)
 {
 	int cfg;
 	
@@ -102,7 +102,7 @@
 	return cfg;
 }
 
-extern __inline__ void set_sbi_ctl(int devid, int cfgno, int cfg)
+static __inline__ void set_sbi_ctl(int devid, int cfgno, int cfg)
 {
 	__asm__ __volatile__ ("sta %0, [%1] %2" : :
 			      "r" (cfg),
diff -rbNu linux-2.4.20-std/include/asm-sparc/sbus.h linux-2.4.20-kfi/include/asm-sparc/sbus.h
--- linux-2.4.20-std/include/asm-sparc/sbus.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/sbus.h	2004-12-30 22:15:16.000000000 +0100
@@ -27,12 +27,12 @@
  * numbers + offsets, and vice versa.
  */
 
-extern __inline__ unsigned long sbus_devaddr(int slotnum, unsigned long offset)
+static __inline__ unsigned long sbus_devaddr(int slotnum, unsigned long offset)
 {
   return (unsigned long) (SUN_SBUS_BVADDR+((slotnum)<<25)+(offset));
 }
 
-extern __inline__ int sbus_dev_slot(unsigned long dev_addr)
+static __inline__ int sbus_dev_slot(unsigned long dev_addr)
 {
   return (int) (((dev_addr)-SUN_SBUS_BVADDR)>>25);
 }
@@ -79,7 +79,7 @@
 
 extern struct sbus_bus *sbus_root;
 
-extern __inline__ int
+static __inline__ int
 sbus_is_slave(struct sbus_dev *dev)
 {
 	/* XXX Have to write this for sun4c's */
diff -rbNu linux-2.4.20-std/include/asm-sparc/siginfo.h linux-2.4.20-kfi/include/asm-sparc/siginfo.h
--- linux-2.4.20-std/include/asm-sparc/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/siginfo.h	2004-12-30 22:15:16.000000000 +0100
@@ -226,7 +226,7 @@
 
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		*to = *from;
diff -rbNu linux-2.4.20-std/include/asm-sparc/smp.h linux-2.4.20-kfi/include/asm-sparc/smp.h
--- linux-2.4.20-std/include/asm-sparc/smp.h	2001-11-13 18:16:05.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/smp.h	2004-12-30 22:15:17.000000000 +0100
@@ -80,22 +80,22 @@
 #define smp_cross_call(func,arg1,arg2,arg3,arg4,arg5) BTFIXUP_CALL(smp_cross_call)(func,arg1,arg2,arg3,arg4,arg5)
 #define smp_message_pass(target,msg,data,wait) BTFIXUP_CALL(smp_message_pass)(target,msg,data,wait)
 
-extern __inline__ void xc0(smpfunc_t func) { smp_cross_call(func, 0, 0, 0, 0, 0); }
-extern __inline__ void xc1(smpfunc_t func, unsigned long arg1)
+static __inline__ void xc0(smpfunc_t func) { smp_cross_call(func, 0, 0, 0, 0, 0); }
+static __inline__ void xc1(smpfunc_t func, unsigned long arg1)
 { smp_cross_call(func, arg1, 0, 0, 0, 0); }
-extern __inline__ void xc2(smpfunc_t func, unsigned long arg1, unsigned long arg2)
+static __inline__ void xc2(smpfunc_t func, unsigned long arg1, unsigned long arg2)
 { smp_cross_call(func, arg1, arg2, 0, 0, 0); }
-extern __inline__ void xc3(smpfunc_t func, unsigned long arg1, unsigned long arg2,
+static __inline__ void xc3(smpfunc_t func, unsigned long arg1, unsigned long arg2,
 			   unsigned long arg3)
 { smp_cross_call(func, arg1, arg2, arg3, 0, 0); }
-extern __inline__ void xc4(smpfunc_t func, unsigned long arg1, unsigned long arg2,
+static __inline__ void xc4(smpfunc_t func, unsigned long arg1, unsigned long arg2,
 			   unsigned long arg3, unsigned long arg4)
 { smp_cross_call(func, arg1, arg2, arg3, arg4, 0); }
-extern __inline__ void xc5(smpfunc_t func, unsigned long arg1, unsigned long arg2,
+static __inline__ void xc5(smpfunc_t func, unsigned long arg1, unsigned long arg2,
 			   unsigned long arg3, unsigned long arg4, unsigned long arg5)
 { smp_cross_call(func, arg1, arg2, arg3, arg4, arg5); }
 
-extern __inline__ int smp_call_function(void (*func)(void *info), void *info, int nonatomic, int wait)
+static __inline__ int smp_call_function(void (*func)(void *info), void *info, int nonatomic, int wait)
 {
 	xc1((smpfunc_t)func, (unsigned long)info);
 	return 0;
@@ -105,16 +105,16 @@
 extern __volatile__ int __cpu_logical_map[NR_CPUS];
 extern unsigned long smp_proc_in_lock[NR_CPUS];
 
-extern __inline__ int cpu_logical_map(int cpu)
+static __inline__ int cpu_logical_map(int cpu)
 {
 	return __cpu_logical_map[cpu];
 }
-extern __inline__ int cpu_number_map(int cpu)
+static __inline__ int cpu_number_map(int cpu)
 {
 	return __cpu_number_map[cpu];
 }
 
-extern __inline__ int hard_smp4m_processor_id(void)
+static __inline__ int hard_smp4m_processor_id(void)
 {
 	int cpuid;
 
@@ -125,7 +125,7 @@
 	return cpuid;
 }
 
-extern __inline__ int hard_smp4d_processor_id(void)
+static __inline__ int hard_smp4d_processor_id(void)
 {
 	int cpuid;
 
@@ -135,7 +135,7 @@
 }
 
 #ifndef MODULE
-extern __inline__ int hard_smp_processor_id(void)
+static __inline__ int hard_smp_processor_id(void)
 {
 	int cpuid;
 
@@ -157,7 +157,7 @@
 	return cpuid;
 }
 #else
-extern __inline__ int hard_smp_processor_id(void)
+static __inline__ int hard_smp_processor_id(void)
 {
 	int cpuid;
 	
@@ -171,8 +171,8 @@
 
 #define smp_processor_id() hard_smp_processor_id()
 /* XXX We really need to implement this now.  -DaveM */
-extern __inline__ void smp_send_reschedule(int cpu) { }
-extern __inline__ void smp_send_stop(void) { }
+static __inline__ void smp_send_reschedule(int cpu) { }
+static __inline__ void smp_send_stop(void) { }
 
 #endif /* !(__ASSEMBLY__) */
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/smplock.h linux-2.4.20-kfi/include/asm-sparc/smplock.h
--- linux-2.4.20-std/include/asm-sparc/smplock.h	2000-03-23 21:50:09.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/smplock.h	2004-12-30 22:15:17.000000000 +0100
@@ -38,13 +38,13 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 	if (!++current->lock_depth)
 		spin_lock(&kernel_flag);
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (--current->lock_depth < 0)
 		spin_unlock(&kernel_flag);
diff -rbNu linux-2.4.20-std/include/asm-sparc/smpprim.h linux-2.4.20-kfi/include/asm-sparc/smpprim.h
--- linux-2.4.20-std/include/asm-sparc/smpprim.h	1996-11-09 09:30:07.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/smpprim.h	2004-12-30 22:15:17.000000000 +0100
@@ -15,7 +15,7 @@
  * atomic.
  */
 
-extern __inline__ __volatile__ char test_and_set(void *addr)
+static __inline__ __volatile__ char test_and_set(void *addr)
 {
 	char state = 0;
 
@@ -27,7 +27,7 @@
 }
 
 /* Initialize a spin-lock. */
-extern __inline__ __volatile__ smp_initlock(void *spinlock)
+static __inline__ __volatile__ smp_initlock(void *spinlock)
 {
 	/* Unset the lock. */
 	*((unsigned char *) spinlock) = 0;
@@ -36,7 +36,7 @@
 }
 
 /* This routine spins until it acquires the lock at ADDR. */
-extern __inline__ __volatile__ smp_lock(void *addr)
+static __inline__ __volatile__ smp_lock(void *addr)
 {
 	while(test_and_set(addr) == 0xff)
 		;
@@ -46,7 +46,7 @@
 }
 
 /* This routine releases the lock at ADDR. */
-extern __inline__ __volatile__ smp_unlock(void *addr)
+static __inline__ __volatile__ smp_unlock(void *addr)
 {
 	*((unsigned char *) addr) = 0;
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc/spinlock.h linux-2.4.20-kfi/include/asm-sparc/spinlock.h
--- linux-2.4.20-std/include/asm-sparc/spinlock.h	2001-10-31 00:08:11.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/spinlock.h	2004-12-30 22:15:17.000000000 +0100
@@ -97,7 +97,7 @@
 	barrier(); \
 } while(*((volatile unsigned char *)lock))
 
-extern __inline__ void spin_lock(spinlock_t *lock)
+static __inline__ void spin_lock(spinlock_t *lock)
 {
 	__asm__ __volatile__(
 	"\n1:\n\t"
@@ -117,7 +117,7 @@
 	: "g2", "memory", "cc");
 }
 
-extern __inline__ int spin_trylock(spinlock_t *lock)
+static __inline__ int spin_trylock(spinlock_t *lock)
 {
 	unsigned int result;
 	__asm__ __volatile__("ldstub [%1], %0"
@@ -127,7 +127,7 @@
 	return (result == 0);
 }
 
-extern __inline__ void spin_unlock(spinlock_t *lock)
+static __inline__ void spin_unlock(spinlock_t *lock)
 {
 	__asm__ __volatile__("stb %%g0, [%0]" : : "r" (lock) : "memory");
 }
@@ -165,7 +165,7 @@
  *
  * Unfortunately this scheme limits us to ~16,000,000 cpus.
  */
-extern __inline__ void _read_lock(rwlock_t *rw)
+static __inline__ void _read_lock(rwlock_t *rw)
 {
 	register rwlock_t *lp asm("g1");
 	lp = rw;
@@ -185,7 +185,7 @@
 	__restore_flags(flags); \
 } while(0)
 
-extern __inline__ void _read_unlock(rwlock_t *rw)
+static __inline__ void _read_unlock(rwlock_t *rw)
 {
 	register rwlock_t *lp asm("g1");
 	lp = rw;
@@ -205,7 +205,7 @@
 	__restore_flags(flags); \
 } while(0)
 
-extern __inline__ void write_lock(rwlock_t *rw)
+static __inline__ void write_lock(rwlock_t *rw)
 {
 	register rwlock_t *lp asm("g1");
 	lp = rw;
diff -rbNu linux-2.4.20-std/include/asm-sparc/swift.h linux-2.4.20-kfi/include/asm-sparc/swift.h
--- linux-2.4.20-std/include/asm-sparc/swift.h	1996-11-09 09:30:13.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/swift.h	2004-12-30 22:15:17.000000000 +0100
@@ -27,20 +27,20 @@
 #define SWIFT_EN       0x00000001   /* MMU enable */
 
 /* Bits [13:5] select one of 512 instruction cache tags */
-extern __inline__ void swift_inv_insn_tag(unsigned long addr)
+static __inline__ void swift_inv_insn_tag(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_TXTC_TAG));
 }
 
 /* Bits [12:4] select one of 512 data cache tags */
-extern __inline__ void swift_inv_data_tag(unsigned long addr)
+static __inline__ void swift_inv_data_tag(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_DATAC_TAG));
 }
 
-extern __inline__ void swift_flush_dcache(void)
+static __inline__ void swift_flush_dcache(void)
 {
 	unsigned long addr;
 
@@ -48,7 +48,7 @@
 		swift_inv_data_tag(addr);
 }
 
-extern __inline__ void swift_flush_icache(void)
+static __inline__ void swift_flush_icache(void)
 {
 	unsigned long addr;
 
@@ -56,7 +56,7 @@
 		swift_inv_insn_tag(addr);
 }
 
-extern __inline__ void swift_idflash_clear(void)
+static __inline__ void swift_idflash_clear(void)
 {
 	unsigned long addr;
 
@@ -67,25 +67,25 @@
 }
 
 /* Swift is so broken, it isn't even safe to use the following. */
-extern __inline__ void swift_flush_page(unsigned long page)
+static __inline__ void swift_flush_page(unsigned long page)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (page), "i" (ASI_M_FLUSH_PAGE));
 }
 
-extern __inline__ void swift_flush_segment(unsigned long addr)
+static __inline__ void swift_flush_segment(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_SEG));
 }
 
-extern __inline__ void swift_flush_region(unsigned long addr)
+static __inline__ void swift_flush_region(unsigned long addr)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (addr), "i" (ASI_M_FLUSH_REGION));
 }
 
-extern __inline__ void swift_flush_context(void)
+static __inline__ void swift_flush_context(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_FLUSH_CTX));
diff -rbNu linux-2.4.20-std/include/asm-sparc/system.h linux-2.4.20-kfi/include/asm-sparc/system.h
--- linux-2.4.20-std/include/asm-sparc/system.h	2001-10-31 00:08:11.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/system.h	2004-12-30 22:15:17.000000000 +0100
@@ -154,7 +154,7 @@
 /*
  * Changing the IRQ level on the Sparc.
  */
-extern __inline__ void setipl(unsigned long __orig_psr)
+static __inline__ void setipl(unsigned long __orig_psr)
 {
 	__asm__ __volatile__(
 		"wr	%0, 0x0, %%psr\n\t"
@@ -164,7 +164,7 @@
 		: "memory", "cc");
 }
 
-extern __inline__ void __cli(void)
+static __inline__ void __cli(void)
 {
 	unsigned long tmp;
 
@@ -179,7 +179,7 @@
 		: "memory");
 }
 
-extern __inline__ void __sti(void)
+static __inline__ void __sti(void)
 {
 	unsigned long tmp;
 
@@ -194,7 +194,7 @@
 		: "memory");
 }
 
-extern __inline__ unsigned long getipl(void)
+static __inline__ unsigned long getipl(void)
 {
 	unsigned long retval;
 
@@ -202,7 +202,7 @@
 	return retval;
 }
 
-extern __inline__ unsigned long swap_pil(unsigned long __new_psr)
+static __inline__ unsigned long swap_pil(unsigned long __new_psr)
 {
 	unsigned long retval;
 
@@ -224,7 +224,7 @@
 	return retval;
 }
 
-extern __inline__ unsigned long read_psr_and_cli(void)
+static __inline__ unsigned long read_psr_and_cli(void)
 {
 	unsigned long retval;
 
@@ -291,7 +291,7 @@
 BTFIXUPDEF_CALL(void, ___xchg32, void)
 #endif
 
-extern __inline__ unsigned long xchg_u32(__volatile__ unsigned long *m, unsigned long val)
+static __inline__ unsigned long xchg_u32(__volatile__ unsigned long *m, unsigned long val)
 {
 #ifdef CONFIG_SMP
 	__asm__ __volatile__("swap [%2], %0"
diff -rbNu linux-2.4.20-std/include/asm-sparc/traps.h linux-2.4.20-kfi/include/asm-sparc/traps.h
--- linux-2.4.20-std/include/asm-sparc/traps.h	1998-04-15 02:44:24.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/traps.h	2004-12-30 22:15:17.000000000 +0100
@@ -22,7 +22,7 @@
 /* We set this to _start in system setup. */
 extern struct tt_entry *sparc_ttable;
 
-extern __inline__ unsigned long get_tbr(void)
+static __inline__ unsigned long get_tbr(void)
 {
 	unsigned long tbr;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/tsunami.h linux-2.4.20-kfi/include/asm-sparc/tsunami.h
--- linux-2.4.20-std/include/asm-sparc/tsunami.h	1996-11-09 09:30:19.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/tsunami.h	2004-12-30 22:15:17.000000000 +0100
@@ -45,13 +45,13 @@
 #define TSUNAMI_NF        0x00000002
 #define TSUNAMI_ME        0x00000001
 
-extern __inline__ void tsunami_flush_icache(void)
+static __inline__ void tsunami_flush_icache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_IC_FLCLEAR) : "memory");
 }
 
-extern __inline__ void tsunami_flush_dcache(void)
+static __inline__ void tsunami_flush_dcache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_DC_FLCLEAR) : "memory");
diff -rbNu linux-2.4.20-std/include/asm-sparc/turbosparc.h linux-2.4.20-kfi/include/asm-sparc/turbosparc.h
--- linux-2.4.20-std/include/asm-sparc/turbosparc.h	1998-10-04 19:22:44.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/turbosparc.h	2004-12-30 22:15:17.000000000 +0100
@@ -59,20 +59,20 @@
 #ifndef __ASSEMBLY__
 
 /* Bits [13:5] select one of 512 instruction cache tags */
-extern __inline__ void turbosparc_inv_insn_tag(unsigned long addr)
+static __inline__ void turbosparc_inv_insn_tag(unsigned long addr)
 {
         __asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
                              "r" (addr), "i" (ASI_M_TXTC_TAG));
 }
 
 /* Bits [13:5] select one of 512 data cache tags */
-extern __inline__ void turbosparc_inv_data_tag(unsigned long addr)
+static __inline__ void turbosparc_inv_data_tag(unsigned long addr)
 {
         __asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
                              "r" (addr), "i" (ASI_M_DATAC_TAG));
 }
 
-extern __inline__ void turbosparc_flush_icache(void)
+static __inline__ void turbosparc_flush_icache(void)
 {
 	unsigned long addr;
 
@@ -80,7 +80,7 @@
                 turbosparc_inv_insn_tag(addr);
 }
 
-extern __inline__ void turbosparc_flush_dcache(void)
+static __inline__ void turbosparc_flush_dcache(void)
 {
 	unsigned long addr;
 
@@ -88,7 +88,7 @@
                 turbosparc_inv_data_tag(addr);
 }
 
-extern __inline__ void turbosparc_idflash_clear(void)
+static __inline__ void turbosparc_idflash_clear(void)
 {
 	unsigned long addr;
 
@@ -98,14 +98,14 @@
 	}
 }
 
-extern __inline__ void turbosparc_set_ccreg(unsigned long regval)
+static __inline__ void turbosparc_set_ccreg(unsigned long regval)
 {
 	__asm__ __volatile__("sta %0, [%1] %2\n\t" : :
 			     "r" (regval), "r" (0x600),
 			     "i" (ASI_M_MMUREGS));
 }
 
-extern __inline__ unsigned long turbosparc_get_ccreg(void)
+static __inline__ unsigned long turbosparc_get_ccreg(void)
 {
 	unsigned long regval;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc/uaccess.h linux-2.4.20-kfi/include/asm-sparc/uaccess.h
--- linux-2.4.20-std/include/asm-sparc/uaccess.h	2001-10-31 00:08:11.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/uaccess.h	2004-12-30 22:15:17.000000000 +0100
@@ -44,7 +44,7 @@
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size)?0:-EFAULT;
 }
@@ -319,7 +319,7 @@
 	__copy_user((void *)(to),		\
 		    (void *)(from), n)
 
-extern __inline__ __kernel_size_t __clear_user(void *addr, __kernel_size_t size)
+static __inline__ __kernel_size_t __clear_user(void *addr, __kernel_size_t size)
 {
   __kernel_size_t ret;
   __asm__ __volatile__ (
@@ -360,7 +360,7 @@
 extern int __strlen_user(const char *);
 extern int __strnlen_user(const char *, long len);
 
-extern __inline__ int strlen_user(const char *str)
+static __inline__ int strlen_user(const char *str)
 {
 	if(!access_ok(VERIFY_READ, str, 0))
 		return 0;
@@ -368,7 +368,7 @@
 		return __strlen_user(str);
 }
 
-extern __inline__ int strnlen_user(const char *str, long len)
+static __inline__ int strnlen_user(const char *str, long len)
 {
 	if(!access_ok(VERIFY_READ, str, 0))
 		return 0;
diff -rbNu linux-2.4.20-std/include/asm-sparc/vac-ops.h linux-2.4.20-kfi/include/asm-sparc/vac-ops.h
--- linux-2.4.20-std/include/asm-sparc/vac-ops.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc/vac-ops.h	2004-12-30 22:15:16.000000000 +0100
@@ -108,7 +108,7 @@
 extern struct sun4c_vac_props sun4c_vacinfo;
 
 /* sun4c_enable_vac() enables the sun4c virtual address cache. */
-extern __inline__ void sun4c_enable_vac(void)
+static __inline__ void sun4c_enable_vac(void)
 {
   __asm__ __volatile__("lduba [%0] %1, %%g1\n\t"
 		       "or    %%g1, %2, %%g1\n\t"
@@ -120,7 +120,7 @@
 }
 
 /* sun4c_disable_vac() disables the virtual address cache. */
-extern __inline__ void sun4c_disable_vac(void)
+static __inline__ void sun4c_disable_vac(void)
 {
   __asm__ __volatile__("lduba [%0] %1, %%g1\n\t"
 		       "andn  %%g1, %2, %%g1\n\t"
diff -rbNu linux-2.4.20-std/include/asm-sparc/viking.h linux-2.4.20-kfi/include/asm-sparc/viking.h
--- linux-2.4.20-std/include/asm-sparc/viking.h	1997-04-24 04:01:28.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc/viking.h	2004-12-30 22:15:17.000000000 +0100
@@ -110,38 +110,38 @@
 
 #ifndef __ASSEMBLY__
 
-extern __inline__ void viking_flush_icache(void)
+static __inline__ void viking_flush_icache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_IC_FLCLEAR));
 }
 
-extern __inline__ void viking_flush_dcache(void)
+static __inline__ void viking_flush_dcache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%%g0] %0\n\t" : :
 			     "i" (ASI_M_DC_FLCLEAR));
 }
 
-extern __inline__ void viking_unlock_icache(void)
+static __inline__ void viking_unlock_icache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (0x80000000), "i" (ASI_M_IC_FLCLEAR));
 }
 
-extern __inline__ void viking_unlock_dcache(void)
+static __inline__ void viking_unlock_dcache(void)
 {
 	__asm__ __volatile__("sta %%g0, [%0] %1\n\t" : :
 			     "r" (0x80000000), "i" (ASI_M_DC_FLCLEAR));
 }
 
-extern __inline__ void viking_set_bpreg(unsigned long regval)
+static __inline__ void viking_set_bpreg(unsigned long regval)
 {
 	__asm__ __volatile__("sta %0, [%%g0] %1\n\t" : :
 			     "r" (regval),
 			     "i" (ASI_M_ACTION));
 }
 
-extern __inline__ unsigned long viking_get_bpreg(void)
+static __inline__ unsigned long viking_get_bpreg(void)
 {
 	unsigned long regval;
 
@@ -151,7 +151,7 @@
 	return regval;
 }
 
-extern __inline__ void viking_get_dcache_ptag(int set, int block,
+static __inline__ void viking_get_dcache_ptag(int set, int block,
 					      unsigned long *data)
 {
 	unsigned long ptag = ((set & 0x7f) << 5) | ((block & 0x3) << 26) |
@@ -168,7 +168,7 @@
 	data[1] = page;
 }
 
-extern __inline__ void viking_mxcc_turn_off_parity(unsigned long *mregp,
+static __inline__ void viking_mxcc_turn_off_parity(unsigned long *mregp,
 						   unsigned long *mxcc_cregp)
 {
 	unsigned long mreg = *mregp;
@@ -198,7 +198,7 @@
 	*mxcc_cregp = mxcc_creg;
 }
 
-extern __inline__ unsigned long viking_hwprobe(unsigned long vaddr)
+static __inline__ unsigned long viking_hwprobe(unsigned long vaddr)
 {
 	unsigned long val;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc64/auxio.h linux-2.4.20-kfi/include/asm-sparc64/auxio.h
--- linux-2.4.20-std/include/asm-sparc64/auxio.h	2001-06-12 04:15:27.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/auxio.h	2004-12-30 22:15:17.000000000 +0100
@@ -80,7 +80,7 @@
 } while(0)
 
 #ifndef __ASSEMBLY__
-extern __inline__ void set_auxio(unsigned char bits_on, unsigned char bits_off)
+static __inline__ void set_auxio(unsigned char bits_on, unsigned char bits_off)
 {
 	unsigned char regval;
 	unsigned long flags;
diff -rbNu linux-2.4.20-std/include/asm-sparc64/bitops.h linux-2.4.20-kfi/include/asm-sparc64/bitops.h
--- linux-2.4.20-std/include/asm-sparc64/bitops.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/bitops.h	2004-12-30 22:15:17.000000000 +0100
@@ -64,13 +64,13 @@
 #define smp_mb__before_clear_bit()	do { } while(0)
 #define smp_mb__after_clear_bit()	do { } while(0)
 
-extern __inline__ int test_bit(int nr, __const__ void *addr)
+static __inline__ int test_bit(int nr, __const__ void *addr)
 {
 	return (1UL & (((__const__ long *) addr)[nr >> 6] >> (nr & 63))) != 0UL;
 }
 
 /* The easy/cheese version for now. */
-extern __inline__ unsigned long ffz(unsigned long word)
+static __inline__ unsigned long ffz(unsigned long word)
 {
 	unsigned long result;
 
@@ -132,7 +132,7 @@
 
 #ifdef ULTRA_HAS_POPULATION_COUNT
 
-extern __inline__ unsigned int hweight32(unsigned int w)
+static __inline__ unsigned int hweight32(unsigned int w)
 {
 	unsigned int res;
 
@@ -140,7 +140,7 @@
 	return res;
 }
 
-extern __inline__ unsigned int hweight16(unsigned int w)
+static __inline__ unsigned int hweight16(unsigned int w)
 {
 	unsigned int res;
 
@@ -148,7 +148,7 @@
 	return res;
 }
 
-extern __inline__ unsigned int hweight8(unsigned int w)
+static __inline__ unsigned int hweight8(unsigned int w)
 {
 	unsigned int res;
 
@@ -170,7 +170,7 @@
  * on Linus's ALPHA routines, which are pretty portable BTW.
  */
 
-extern __inline__ unsigned long find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
+static __inline__ unsigned long find_next_zero_bit(void *addr, unsigned long size, unsigned long offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
@@ -219,7 +219,7 @@
 #define set_le_bit(nr,addr)		((void)___test_and_set_le_bit(nr,addr))
 #define clear_le_bit(nr,addr)		((void)___test_and_clear_le_bit(nr,addr))
 
-extern __inline__ int test_le_bit(int nr, __const__ void * addr)
+static __inline__ int test_le_bit(int nr, __const__ void * addr)
 {
 	int			mask;
 	__const__ unsigned char	*ADDR = (__const__ unsigned char *) addr;
@@ -232,7 +232,7 @@
 #define find_first_zero_le_bit(addr, size) \
         find_next_zero_le_bit((addr), (size), 0)
 
-extern __inline__ unsigned long find_next_zero_le_bit(void *addr, unsigned long size, unsigned long offset)
+static __inline__ unsigned long find_next_zero_le_bit(void *addr, unsigned long size, unsigned long offset)
 {
 	unsigned long *p = ((unsigned long *) addr) + (offset >> 6);
 	unsigned long result = offset & ~63UL;
diff -rbNu linux-2.4.20-std/include/asm-sparc64/checksum.h linux-2.4.20-kfi/include/asm-sparc64/checksum.h
--- linux-2.4.20-std/include/asm-sparc64/checksum.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/checksum.h	2004-12-30 22:15:17.000000000 +0100
@@ -40,7 +40,7 @@
  */
 extern unsigned int csum_partial_copy_sparc64(const char *src, char *dst, int len, unsigned int sum);
 			
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_partial_copy_nocheck (const char *src, char *dst, int len, 
 			   unsigned int sum)
 {
@@ -52,7 +52,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_partial_copy_from_user(const char *src, char *dst, int len, 
 			    unsigned int sum, int *err)
 {
@@ -66,7 +66,7 @@
  */
 #define HAVE_CSUM_COPY_USER
 extern unsigned int csum_partial_copy_user_sparc64(const char *src, char *dst, int len, unsigned int sum);
-extern __inline__ unsigned int 
+static __inline__ unsigned int 
 csum_and_copy_to_user(const char *src, char *dst, int len, 
 		      unsigned int sum, int *err)
 {
@@ -78,7 +78,7 @@
 /* ihl is always 5 or greater, almost always is 5, and iph is word aligned
  * the majority of the time.
  */
-extern __inline__ unsigned short ip_fast_csum(__const__ unsigned char *iph,
+static __inline__ unsigned short ip_fast_csum(__const__ unsigned char *iph,
 					      unsigned int ihl)
 {
 	unsigned short sum;
@@ -119,7 +119,7 @@
 }
 
 /* Fold a partial checksum without adding pseudo headers. */
-extern __inline__ unsigned short csum_fold(unsigned int sum)
+static __inline__ unsigned short csum_fold(unsigned int sum)
 {
 	unsigned int tmp;
 
@@ -134,7 +134,7 @@
 	return (sum & 0xffff);
 }
 
-extern __inline__ unsigned long csum_tcpudp_nofold(unsigned long saddr,
+static __inline__ unsigned long csum_tcpudp_nofold(unsigned long saddr,
 						   unsigned long daddr,
 						   unsigned int len,
 						   unsigned short proto,
@@ -201,7 +201,7 @@
 }
 
 /* this routine is used for miscellaneous IP-like checksums, mainly in icmp.c */
-extern __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len)
+static __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len)
 {
 	return csum_fold(csum_partial(buff, len, 0));
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc64/delay.h linux-2.4.20-kfi/include/asm-sparc64/delay.h
--- linux-2.4.20-std/include/asm-sparc64/delay.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/delay.h	2004-12-30 22:15:17.000000000 +0100
@@ -18,7 +18,7 @@
 extern unsigned long loops_per_jiffy;
 #endif 
 
-extern __inline__ void __delay(unsigned long loops)
+static __inline__ void __delay(unsigned long loops)
 {
 	__asm__ __volatile__(
 "	b,pt	%%xcc, 1f\n"
@@ -32,7 +32,7 @@
 	: "cc");
 }
 
-extern __inline__ void __udelay(unsigned long usecs, unsigned long lps)
+static __inline__ void __udelay(unsigned long usecs, unsigned long lps)
 {
 	usecs *= 0x00000000000010c6UL;		/* 2**32 / 1000000 */
 
diff -rbNu linux-2.4.20-std/include/asm-sparc64/fpumacro.h linux-2.4.20-kfi/include/asm-sparc64/fpumacro.h
--- linux-2.4.20-std/include/asm-sparc64/fpumacro.h	1999-05-27 18:55:22.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/fpumacro.h	2004-12-30 22:15:17.000000000 +0100
@@ -16,7 +16,7 @@
 
 #define FPUSTATE (struct fpustate *)(((unsigned long)current) + AOFF_task_fpregs)
 
-extern __inline__ unsigned long fprs_read(void)
+static __inline__ unsigned long fprs_read(void)
 {
 	unsigned long retval;
 
@@ -25,7 +25,7 @@
 	return retval;
 }
 
-extern __inline__ void fprs_write(unsigned long val)
+static __inline__ void fprs_write(unsigned long val)
 {
 	__asm__ __volatile__("wr %0, 0x0, %%fprs" : : "r" (val));
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc64/irq.h linux-2.4.20-kfi/include/asm-sparc64/irq.h
--- linux-2.4.20-std/include/asm-sparc64/irq.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/irq.h	2004-12-30 22:15:17.000000000 +0100
@@ -131,21 +131,21 @@
 			    unsigned long flags, __const__ char *devname,
 			    void *dev_id);
 
-extern __inline__ void set_softint(unsigned long bits)
+static __inline__ void set_softint(unsigned long bits)
 {
 	__asm__ __volatile__("wr	%0, 0x0, %%set_softint"
 			     : /* No outputs */
 			     : "r" (bits));
 }
 
-extern __inline__ void clear_softint(unsigned long bits)
+static __inline__ void clear_softint(unsigned long bits)
 {
 	__asm__ __volatile__("wr	%0, 0x0, %%clear_softint"
 			     : /* No outputs */
 			     : "r" (bits));
 }
 
-extern __inline__ unsigned long get_softint(void)
+static __inline__ unsigned long get_softint(void)
 {
 	unsigned long retval;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc64/page.h linux-2.4.20-kfi/include/asm-sparc64/page.h
--- linux-2.4.20-std/include/asm-sparc64/page.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/page.h	2004-12-30 22:15:17.000000000 +0100
@@ -141,7 +141,7 @@
 extern struct sparc_phys_banks sp_banks[SPARC_PHYS_BANKS];
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-sparc64/pci.h linux-2.4.20-kfi/include/asm-sparc64/pci.h
--- linux-2.4.20-std/include/asm-sparc64/pci.h	2002-02-25 20:38:13.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/pci.h	2004-12-30 22:15:18.000000000 +0100
@@ -17,12 +17,12 @@
 
 #define PCI_IRQ_NONE		0xffffffff
 
-extern inline void pcibios_set_master(struct pci_dev *dev)
+static inline void pcibios_set_master(struct pci_dev *dev)
 {
 	/* No special bus mastering setup handling */
 }
 
-extern inline void pcibios_penalize_isa_irq(int irq)
+static inline void pcibios_penalize_isa_irq(int irq)
 {
 	/* We don't do dynamic PCI IRQ allocation */
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc64/pgalloc.h linux-2.4.20-kfi/include/asm-sparc64/pgalloc.h
--- linux-2.4.20-std/include/asm-sparc64/pgalloc.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/pgalloc.h	2004-12-30 22:15:17.000000000 +0100
@@ -100,7 +100,7 @@
 
 #endif /* ! CONFIG_SMP */
 
-extern __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start,
+static __inline__ void flush_tlb_pgtables(struct mm_struct *mm, unsigned long start,
 					  unsigned long end)
 {
 	/* Note the signed type.  */
@@ -142,7 +142,7 @@
 
 #ifndef CONFIG_SMP
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
 	struct page *page = virt_to_page(pgd);
 
@@ -155,7 +155,7 @@
 	pgd_cache_size++;
 }
 
-extern __inline__ pgd_t *get_pgd_fast(void)
+static __inline__ pgd_t *get_pgd_fast(void)
 {
         struct page *ret;
 
@@ -191,14 +191,14 @@
 
 #else /* CONFIG_SMP */
 
-extern __inline__ void free_pgd_fast(pgd_t *pgd)
+static __inline__ void free_pgd_fast(pgd_t *pgd)
 {
 	*(unsigned long *)pgd = (unsigned long) pgd_quicklist;
 	pgd_quicklist = (unsigned long *) pgd;
 	pgtable_cache_size++;
 }
 
-extern __inline__ pgd_t *get_pgd_fast(void)
+static __inline__ pgd_t *get_pgd_fast(void)
 {
 	unsigned long *ret;
 
@@ -214,7 +214,7 @@
 	return (pgd_t *)ret;
 }
 
-extern __inline__ void free_pgd_slow(pgd_t *pgd)
+static __inline__ void free_pgd_slow(pgd_t *pgd)
 {
 	free_page((unsigned long)pgd);
 }
@@ -231,7 +231,7 @@
 
 #define pgd_populate(MM, PGD, PMD)	pgd_set(PGD, PMD)
 
-extern __inline__ pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
+static __inline__ pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
 	pmd_t *pmd = (pmd_t *)__get_free_page(GFP_KERNEL);
 	if (pmd)
@@ -239,7 +239,7 @@
 	return pmd;
 }
 
-extern __inline__ pmd_t *pmd_alloc_one_fast(struct mm_struct *mm, unsigned long address)
+static __inline__ pmd_t *pmd_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
 	unsigned long *ret;
 	int color = 0;
@@ -254,7 +254,7 @@
 	return (pmd_t *)ret;
 }
 
-extern __inline__ void free_pmd_fast(pmd_t *pmd)
+static __inline__ void free_pmd_fast(pmd_t *pmd)
 {
 	unsigned long color = DCACHE_COLOR((unsigned long)pmd);
 	*(unsigned long *)pmd = (unsigned long) pte_quicklist[color];
@@ -262,7 +262,7 @@
 	pgtable_cache_size++;
 }
 
-extern __inline__ void free_pmd_slow(pmd_t *pmd)
+static __inline__ void free_pmd_slow(pmd_t *pmd)
 {
 	free_page((unsigned long)pmd);
 }
@@ -271,7 +271,7 @@
 
 extern pte_t *pte_alloc_one(struct mm_struct *mm, unsigned long address);
 
-extern __inline__ pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
+static __inline__ pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
 	unsigned long color = VPTE_COLOR(address);
 	unsigned long *ret;
@@ -284,7 +284,7 @@
 	return (pte_t *)ret;
 }
 
-extern __inline__ void free_pte_fast(pte_t *pte)
+static __inline__ void free_pte_fast(pte_t *pte)
 {
 	unsigned long color = DCACHE_COLOR((unsigned long)pte);
 	*(unsigned long *)pte = (unsigned long) pte_quicklist[color];
@@ -292,7 +292,7 @@
 	pgtable_cache_size++;
 }
 
-extern __inline__ void free_pte_slow(pte_t *pte)
+static __inline__ void free_pte_slow(pte_t *pte)
 {
 	free_page((unsigned long)pte);
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc64/pgtable.h linux-2.4.20-kfi/include/asm-sparc64/pgtable.h
--- linux-2.4.20-std/include/asm-sparc64/pgtable.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/pgtable.h	2004-12-30 22:15:17.000000000 +0100
@@ -202,7 +202,7 @@
 
 #define mk_pte_phys(physpage, pgprot)	(__pte((physpage) | pgprot_val(pgprot) | _PAGE_SZBITS))
 
-extern inline pte_t pte_modify(pte_t orig_pte, pgprot_t new_prot)
+static inline pte_t pte_modify(pte_t orig_pte, pgprot_t new_prot)
 {
 	pte_t __pte;
 
@@ -279,7 +279,7 @@
 #define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
 
 /* Make a non-present pseudo-TTE. */
-extern inline pte_t mk_pte_io(unsigned long page, pgprot_t prot, int space)
+static inline pte_t mk_pte_io(unsigned long page, pgprot_t prot, int space)
 {
 	pte_t pte;
 	pte_val(pte) = ((page) | pgprot_val(prot) | _PAGE_E) & ~(unsigned long)_PAGE_CACHE;
@@ -301,7 +301,7 @@
 
 extern unsigned long prom_virt_to_phys(unsigned long, int *);
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 sun4u_get_pte (unsigned long addr)
 {
 	pgd_t *pgdp;
@@ -318,13 +318,13 @@
 	return pte_val (*ptep) & _PAGE_PADDR;
 }
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __get_phys (unsigned long addr)
 {
 	return sun4u_get_pte (addr);
 }
 
-extern __inline__ int
+static __inline__ int
 __get_iospace (unsigned long addr)
 {
 	return ((sun4u_get_pte (addr) & 0xf0000000) >> 28);
diff -rbNu linux-2.4.20-std/include/asm-sparc64/processor.h linux-2.4.20-kfi/include/asm-sparc64/processor.h
--- linux-2.4.20-std/include/asm-sparc64/processor.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/processor.h	2004-12-30 22:15:17.000000000 +0100
@@ -164,7 +164,7 @@
 #ifndef __ASSEMBLY__
 
 /* Return saved PC of a blocked thread. */
-extern __inline__ unsigned long thread_saved_pc(struct thread_struct *t)
+static __inline__ unsigned long thread_saved_pc(struct thread_struct *t)
 {
 	unsigned long ret = 0xdeadbeefUL;
 	
diff -rbNu linux-2.4.20-std/include/asm-sparc64/psrcompat.h linux-2.4.20-kfi/include/asm-sparc64/psrcompat.h
--- linux-2.4.20-std/include/asm-sparc64/psrcompat.h	1998-10-27 18:52:21.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/psrcompat.h	2004-12-30 22:15:17.000000000 +0100
@@ -24,7 +24,7 @@
 #define PSR_V8PLUS  0xff000000         /* fake impl/ver, meaning a 64bit CPU is present */
 #define PSR_XCC	    0x000f0000         /* if PSR_V8PLUS, this is %xcc */
 
-extern inline unsigned int tstate_to_psr(unsigned long tstate)
+static inline unsigned int tstate_to_psr(unsigned long tstate)
 {
 	return ((tstate & TSTATE_CWP)			|
 		PSR_S					|
@@ -33,7 +33,7 @@
 		PSR_V8PLUS);
 }
 
-extern inline unsigned long psr_to_tstate_icc(unsigned int psr)
+static inline unsigned long psr_to_tstate_icc(unsigned int psr)
 {
 	unsigned long tstate = ((unsigned long)(psr & PSR_ICC)) << 12;
 	if ((psr & (PSR_VERS|PSR_IMPL)) == PSR_V8PLUS)
diff -rbNu linux-2.4.20-std/include/asm-sparc64/sbus.h linux-2.4.20-kfi/include/asm-sparc64/sbus.h
--- linux-2.4.20-std/include/asm-sparc64/sbus.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/sbus.h	2004-12-30 22:15:17.000000000 +0100
@@ -27,12 +27,12 @@
  * numbers + offsets, and vice versa.
  */
 
-extern __inline__ unsigned long sbus_devaddr(int slotnum, unsigned long offset)
+static __inline__ unsigned long sbus_devaddr(int slotnum, unsigned long offset)
 {
   return (unsigned long) (SUN_SBUS_BVADDR+((slotnum)<<28)+(offset));
 }
 
-extern __inline__ int sbus_dev_slot(unsigned long dev_addr)
+static __inline__ int sbus_dev_slot(unsigned long dev_addr)
 {
   return (int) (((dev_addr)-SUN_SBUS_BVADDR)>>28);
 }
diff -rbNu linux-2.4.20-std/include/asm-sparc64/siginfo.h linux-2.4.20-kfi/include/asm-sparc64/siginfo.h
--- linux-2.4.20-std/include/asm-sparc64/siginfo.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/siginfo.h	2004-12-30 22:15:17.000000000 +0100
@@ -301,7 +301,7 @@
 
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		*to = *from;
diff -rbNu linux-2.4.20-std/include/asm-sparc64/smp.h linux-2.4.20-kfi/include/asm-sparc64/smp.h
--- linux-2.4.20-std/include/asm-sparc64/smp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/smp.h	2004-12-30 22:15:17.000000000 +0100
@@ -75,16 +75,16 @@
 extern __volatile__ int __cpu_number_map[NR_CPUS];
 extern __volatile__ int __cpu_logical_map[NR_CPUS];
 
-extern __inline__ int cpu_logical_map(int cpu)
+static __inline__ int cpu_logical_map(int cpu)
 {
 	return __cpu_logical_map[cpu];
 }
-extern __inline__ int cpu_number_map(int cpu)
+static __inline__ int cpu_number_map(int cpu)
 {
 	return __cpu_number_map[cpu];
 }
 
-extern __inline__ int hard_smp_processor_id(void)
+static __inline__ int hard_smp_processor_id(void)
 {
 	if (tlb_type == cheetah || tlb_type == cheetah_plus) {
 		unsigned long safari_config;
@@ -113,7 +113,7 @@
  *           delivery case, we detect that by just seeing
  *           if we are trying to send this to an idler or not.
  */
-extern __inline__ void smp_send_reschedule(int cpu)
+static __inline__ void smp_send_reschedule(int cpu)
 {
 	extern void smp_receive_signal(int);
 	if(cpu_data[cpu].idle_volume == 0)
@@ -123,7 +123,7 @@
 /* This is a nop as well because we capture all other cpus
  * anyways when making the PROM active.
  */
-extern __inline__ void smp_send_stop(void) { }
+static __inline__ void smp_send_stop(void) { }
 
 #endif /* !(__ASSEMBLY__) */
 
diff -rbNu linux-2.4.20-std/include/asm-sparc64/spinlock.h linux-2.4.20-kfi/include/asm-sparc64/spinlock.h
--- linux-2.4.20-std/include/asm-sparc64/spinlock.h	2001-12-21 18:42:03.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/spinlock.h	2004-12-30 22:15:18.000000000 +0100
@@ -40,7 +40,7 @@
 do {	membar("#LoadLoad");	\
 } while(*((volatile unsigned char *)lock))
 
-extern __inline__ void spin_lock(spinlock_t *lock)
+static __inline__ void spin_lock(spinlock_t *lock)
 {
 	__asm__ __volatile__(
 "1:	ldstub		[%0], %%g7\n"
@@ -57,7 +57,7 @@
 	: "g7", "memory");
 }
 
-extern __inline__ int spin_trylock(spinlock_t *lock)
+static __inline__ int spin_trylock(spinlock_t *lock)
 {
 	unsigned int result;
 	__asm__ __volatile__("ldstub [%1], %0\n\t"
@@ -68,7 +68,7 @@
 	return (result == 0);
 }
 
-extern __inline__ void spin_unlock(spinlock_t *lock)
+static __inline__ void spin_unlock(spinlock_t *lock)
 {
 	__asm__ __volatile__("membar	#StoreStore | #LoadStore\n\t"
 			     "stb	%%g0, [%0]"
diff -rbNu linux-2.4.20-std/include/asm-sparc64/spitfire.h linux-2.4.20-kfi/include/asm-sparc64/spitfire.h
--- linux-2.4.20-std/include/asm-sparc64/spitfire.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/spitfire.h	2004-12-30 22:15:17.000000000 +0100
@@ -56,7 +56,7 @@
 	 SPITFIRE_HIGHEST_LOCKED_TLBENT : \
 	 CHEETAH_HIGHEST_LOCKED_TLBENT)
 
-extern __inline__ unsigned long spitfire_get_isfsr(void)
+static __inline__ unsigned long spitfire_get_isfsr(void)
 {
 	unsigned long ret;
 
@@ -66,7 +66,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned long spitfire_get_dsfsr(void)
+static __inline__ unsigned long spitfire_get_dsfsr(void)
 {
 	unsigned long ret;
 
@@ -76,7 +76,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned long spitfire_get_sfar(void)
+static __inline__ unsigned long spitfire_get_sfar(void)
 {
 	unsigned long ret;
 
@@ -86,7 +86,7 @@
 	return ret;
 }
 
-extern __inline__ void spitfire_put_isfsr(unsigned long sfsr)
+static __inline__ void spitfire_put_isfsr(unsigned long sfsr)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -94,7 +94,7 @@
 			     : "r" (sfsr), "r" (TLB_SFSR), "i" (ASI_IMMU));
 }
 
-extern __inline__ void spitfire_put_dsfsr(unsigned long sfsr)
+static __inline__ void spitfire_put_dsfsr(unsigned long sfsr)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -102,7 +102,7 @@
 			     : "r" (sfsr), "r" (TLB_SFSR), "i" (ASI_DMMU));
 }
 
-extern __inline__ unsigned long spitfire_get_primary_context(void)
+static __inline__ unsigned long spitfire_get_primary_context(void)
 {
 	unsigned long ctx;
 
@@ -112,7 +112,7 @@
 	return ctx;
 }
 
-extern __inline__ void spitfire_set_primary_context(unsigned long ctx)
+static __inline__ void spitfire_set_primary_context(unsigned long ctx)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -122,7 +122,7 @@
 	__asm__ __volatile__ ("membar #Sync" : : : "memory");
 }
 
-extern __inline__ unsigned long spitfire_get_secondary_context(void)
+static __inline__ unsigned long spitfire_get_secondary_context(void)
 {
 	unsigned long ctx;
 
@@ -132,7 +132,7 @@
 	return ctx;
 }
 
-extern __inline__ void spitfire_set_secondary_context(unsigned long ctx)
+static __inline__ void spitfire_set_secondary_context(unsigned long ctx)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -145,7 +145,7 @@
 /* The data cache is write through, so this just invalidates the
  * specified line.
  */
-extern __inline__ void spitfire_put_dcache_tag(unsigned long addr, unsigned long tag)
+static __inline__ void spitfire_put_dcache_tag(unsigned long addr, unsigned long tag)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -160,7 +160,7 @@
  * a flush instruction (to any address) is sufficient to handle
  * this issue after the line is invalidated.
  */
-extern __inline__ void spitfire_put_icache_tag(unsigned long addr, unsigned long tag)
+static __inline__ void spitfire_put_icache_tag(unsigned long addr, unsigned long tag)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -168,7 +168,7 @@
 			     : "r" (tag), "r" (addr), "i" (ASI_IC_TAG));
 }
 
-extern __inline__ unsigned long spitfire_get_dtlb_data(int entry)
+static __inline__ unsigned long spitfire_get_dtlb_data(int entry)
 {
 	unsigned long data;
 
@@ -182,7 +182,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long spitfire_get_dtlb_tag(int entry)
+static __inline__ unsigned long spitfire_get_dtlb_tag(int entry)
 {
 	unsigned long tag;
 
@@ -192,7 +192,7 @@
 	return tag;
 }
 
-extern __inline__ void spitfire_put_dtlb_data(int entry, unsigned long data)
+static __inline__ void spitfire_put_dtlb_data(int entry, unsigned long data)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -201,7 +201,7 @@
 			       "i" (ASI_DTLB_DATA_ACCESS));
 }
 
-extern __inline__ unsigned long spitfire_get_itlb_data(int entry)
+static __inline__ unsigned long spitfire_get_itlb_data(int entry)
 {
 	unsigned long data;
 
@@ -215,7 +215,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long spitfire_get_itlb_tag(int entry)
+static __inline__ unsigned long spitfire_get_itlb_tag(int entry)
 {
 	unsigned long tag;
 
@@ -225,7 +225,7 @@
 	return tag;
 }
 
-extern __inline__ void spitfire_put_itlb_data(int entry, unsigned long data)
+static __inline__ void spitfire_put_itlb_data(int entry, unsigned long data)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -237,7 +237,7 @@
 /* Spitfire hardware assisted TLB flushes. */
 
 /* Context level flushes. */
-extern __inline__ void spitfire_flush_dtlb_primary_context(void)
+static __inline__ void spitfire_flush_dtlb_primary_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -245,7 +245,7 @@
 			     : "r" (0x40), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_primary_context(void)
+static __inline__ void spitfire_flush_itlb_primary_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -253,7 +253,7 @@
 			     : "r" (0x40), "i" (ASI_IMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_dtlb_secondary_context(void)
+static __inline__ void spitfire_flush_dtlb_secondary_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -261,7 +261,7 @@
 			     : "r" (0x50), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_secondary_context(void)
+static __inline__ void spitfire_flush_itlb_secondary_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -269,7 +269,7 @@
 			     : "r" (0x50), "i" (ASI_IMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_dtlb_nucleus_context(void)
+static __inline__ void spitfire_flush_dtlb_nucleus_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -277,7 +277,7 @@
 			     : "r" (0x60), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_nucleus_context(void)
+static __inline__ void spitfire_flush_itlb_nucleus_context(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -286,7 +286,7 @@
 }
 
 /* Page level flushes. */
-extern __inline__ void spitfire_flush_dtlb_primary_page(unsigned long page)
+static __inline__ void spitfire_flush_dtlb_primary_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -294,7 +294,7 @@
 			     : "r" (page), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_primary_page(unsigned long page)
+static __inline__ void spitfire_flush_itlb_primary_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -302,7 +302,7 @@
 			     : "r" (page), "i" (ASI_IMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_dtlb_secondary_page(unsigned long page)
+static __inline__ void spitfire_flush_dtlb_secondary_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -310,7 +310,7 @@
 			     : "r" (page | 0x10), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_secondary_page(unsigned long page)
+static __inline__ void spitfire_flush_itlb_secondary_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -318,7 +318,7 @@
 			     : "r" (page | 0x10), "i" (ASI_IMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_dtlb_nucleus_page(unsigned long page)
+static __inline__ void spitfire_flush_dtlb_nucleus_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -326,7 +326,7 @@
 			     : "r" (page | 0x20), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void spitfire_flush_itlb_nucleus_page(unsigned long page)
+static __inline__ void spitfire_flush_itlb_nucleus_page(unsigned long page)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -335,7 +335,7 @@
 }
 
 /* Cheetah has "all non-locked" tlb flushes. */
-extern __inline__ void cheetah_flush_dtlb_all(void)
+static __inline__ void cheetah_flush_dtlb_all(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -343,7 +343,7 @@
 			     : "r" (0x80), "i" (ASI_DMMU_DEMAP));
 }
 
-extern __inline__ void cheetah_flush_itlb_all(void)
+static __inline__ void cheetah_flush_itlb_all(void)
 {
 	__asm__ __volatile__("stxa	%%g0, [%0] %1\n\t"
 			     "membar	#Sync"
@@ -365,7 +365,7 @@
  * ASI_{D,I}TLB_DATA_ACCESS loads, doing the load twice fixes
  * the problem for me. -DaveM
  */
-extern __inline__ unsigned long cheetah_get_ldtlb_data(int entry)
+static __inline__ unsigned long cheetah_get_ldtlb_data(int entry)
 {
 	unsigned long data;
 
@@ -378,7 +378,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long cheetah_get_litlb_data(int entry)
+static __inline__ unsigned long cheetah_get_litlb_data(int entry)
 {
 	unsigned long data;
 
@@ -391,7 +391,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long cheetah_get_ldtlb_tag(int entry)
+static __inline__ unsigned long cheetah_get_ldtlb_tag(int entry)
 {
 	unsigned long tag;
 
@@ -403,7 +403,7 @@
 	return tag;
 }
 
-extern __inline__ unsigned long cheetah_get_litlb_tag(int entry)
+static __inline__ unsigned long cheetah_get_litlb_tag(int entry)
 {
 	unsigned long tag;
 
@@ -415,7 +415,7 @@
 	return tag;
 }
 
-extern __inline__ void cheetah_put_ldtlb_data(int entry, unsigned long data)
+static __inline__ void cheetah_put_ldtlb_data(int entry, unsigned long data)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -425,7 +425,7 @@
 			       "i" (ASI_DTLB_DATA_ACCESS));
 }
 
-extern __inline__ void cheetah_put_litlb_data(int entry, unsigned long data)
+static __inline__ void cheetah_put_litlb_data(int entry, unsigned long data)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -435,7 +435,7 @@
 			       "i" (ASI_ITLB_DATA_ACCESS));
 }
 
-extern __inline__ unsigned long cheetah_get_dtlb_data(int entry, int tlb)
+static __inline__ unsigned long cheetah_get_dtlb_data(int entry, int tlb)
 {
 	unsigned long data;
 
@@ -447,7 +447,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long cheetah_get_dtlb_tag(int entry, int tlb)
+static __inline__ unsigned long cheetah_get_dtlb_tag(int entry, int tlb)
 {
 	unsigned long tag;
 
@@ -457,7 +457,7 @@
 	return tag;
 }
 
-extern __inline__ void cheetah_put_dtlb_data(int entry, unsigned long data, int tlb)
+static __inline__ void cheetah_put_dtlb_data(int entry, unsigned long data, int tlb)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
@@ -467,7 +467,7 @@
 			       "i" (ASI_DTLB_DATA_ACCESS));
 }
 
-extern __inline__ unsigned long cheetah_get_itlb_data(int entry)
+static __inline__ unsigned long cheetah_get_itlb_data(int entry)
 {
 	unsigned long data;
 
@@ -480,7 +480,7 @@
 	return data;
 }
 
-extern __inline__ unsigned long cheetah_get_itlb_tag(int entry)
+static __inline__ unsigned long cheetah_get_itlb_tag(int entry)
 {
 	unsigned long tag;
 
@@ -490,7 +490,7 @@
 	return tag;
 }
 
-extern __inline__ void cheetah_put_itlb_data(int entry, unsigned long data)
+static __inline__ void cheetah_put_itlb_data(int entry, unsigned long data)
 {
 	__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
 			     "membar	#Sync"
diff -rbNu linux-2.4.20-std/include/asm-sparc64/system.h linux-2.4.20-kfi/include/asm-sparc64/system.h
--- linux-2.4.20-std/include/asm-sparc64/system.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/system.h	2004-12-30 22:15:17.000000000 +0100
@@ -231,7 +231,7 @@
 	}									\
 } while(0)
 
-extern __inline__ unsigned long xchg32(__volatile__ unsigned int *m, unsigned int val)
+static __inline__ unsigned long xchg32(__volatile__ unsigned int *m, unsigned int val)
 {
 	__asm__ __volatile__(
 "	mov		%0, %%g5\n"
@@ -247,7 +247,7 @@
 	return val;
 }
 
-extern __inline__ unsigned long xchg64(__volatile__ unsigned long *m, unsigned long val)
+static __inline__ unsigned long xchg64(__volatile__ unsigned long *m, unsigned long val)
 {
 	__asm__ __volatile__(
 "	mov		%0, %%g5\n"
@@ -291,7 +291,7 @@
 
 #define __HAVE_ARCH_CMPXCHG 1
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __cmpxchg_u32(volatile int *m, int old, int new)
 {
 	__asm__ __volatile__("cas [%2], %3, %0\n\t"
@@ -303,7 +303,7 @@
 	return new;
 }
 
-extern __inline__ unsigned long
+static __inline__ unsigned long
 __cmpxchg_u64(volatile long *m, unsigned long old, unsigned long new)
 {
 	__asm__ __volatile__("casx [%2], %3, %0\n\t"
diff -rbNu linux-2.4.20-std/include/asm-sparc64/uaccess.h linux-2.4.20-kfi/include/asm-sparc64/uaccess.h
--- linux-2.4.20-std/include/asm-sparc64/uaccess.h	2001-10-01 18:19:56.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/uaccess.h	2004-12-30 22:15:17.000000000 +0100
@@ -52,7 +52,7 @@
 #define __access_ok(addr,size) 1
 #define access_ok(type,addr,size) 1
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return 0;
 }
@@ -270,7 +270,7 @@
 	__copy_in_user((void *)(to), \
 	(void *) (from), (__kernel_size_t)(n))
 
-extern __inline__ __kernel_size_t __clear_user(void *addr, __kernel_size_t size)
+static __inline__ __kernel_size_t __clear_user(void *addr, __kernel_size_t size)
 {
 	extern __kernel_size_t __bzero_noasi(void *addr, __kernel_size_t size);
 	
diff -rbNu linux-2.4.20-std/include/asm-sparc64/upa.h linux-2.4.20-kfi/include/asm-sparc64/upa.h
--- linux-2.4.20-std/include/asm-sparc64/upa.h	1999-12-21 07:05:52.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-sparc64/upa.h	2004-12-30 22:15:17.000000000 +0100
@@ -25,7 +25,7 @@
 
 /* UPA I/O space accessors */
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__)
-extern __inline__ unsigned char _upa_readb(unsigned long addr)
+static __inline__ unsigned char _upa_readb(unsigned long addr)
 {
 	unsigned char ret;
 
@@ -36,7 +36,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned short _upa_readw(unsigned long addr)
+static __inline__ unsigned short _upa_readw(unsigned long addr)
 {
 	unsigned short ret;
 
@@ -47,7 +47,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned int _upa_readl(unsigned long addr)
+static __inline__ unsigned int _upa_readl(unsigned long addr)
 {
 	unsigned int ret;
 
@@ -58,7 +58,7 @@
 	return ret;
 }
 
-extern __inline__ unsigned long _upa_readq(unsigned long addr)
+static __inline__ unsigned long _upa_readq(unsigned long addr)
 {
 	unsigned long ret;
 
@@ -69,28 +69,28 @@
 	return ret;
 }
 
-extern __inline__ void _upa_writeb(unsigned char b, unsigned long addr)
+static __inline__ void _upa_writeb(unsigned char b, unsigned long addr)
 {
 	__asm__ __volatile__("stba\t%0, [%1] %2\t/* upa_writeb */"
 			     : /* no outputs */
 			     : "r" (b), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
 }
 
-extern __inline__ void _upa_writew(unsigned short w, unsigned long addr)
+static __inline__ void _upa_writew(unsigned short w, unsigned long addr)
 {
 	__asm__ __volatile__("stha\t%0, [%1] %2\t/* upa_writew */"
 			     : /* no outputs */
 			     : "r" (w), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
 }
 
-extern __inline__ void _upa_writel(unsigned int l, unsigned long addr)
+static __inline__ void _upa_writel(unsigned int l, unsigned long addr)
 {
 	__asm__ __volatile__("stwa\t%0, [%1] %2\t/* upa_writel */"
 			     : /* no outputs */
 			     : "r" (l), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));
 }
 
-extern __inline__ void _upa_writeq(unsigned long q, unsigned long addr)
+static __inline__ void _upa_writeq(unsigned long q, unsigned long addr)
 {
 	__asm__ __volatile__("stxa\t%0, [%1] %2\t/* upa_writeq */"
 			     : /* no outputs */
diff -rbNu linux-2.4.20-std/include/asm-sparc64/visasm.h linux-2.4.20-kfi/include/asm-sparc64/visasm.h
--- linux-2.4.20-std/include/asm-sparc64/visasm.h	2001-04-27 07:17:26.000000000 +0200
+++ linux-2.4.20-kfi/include/asm-sparc64/visasm.h	2004-12-30 22:15:18.000000000 +0100
@@ -44,7 +44,7 @@
 	wr		%o5, 0, %fprs;
 
 #ifndef __ASSEMBLY__	
-extern __inline__ void save_and_clear_fpu(void) {
+static __inline__ void save_and_clear_fpu(void) {
 	__asm__ __volatile__ (
 "		rd %%fprs, %%o5\n"
 "		andcc %%o5, %0, %%g0\n"
diff -rbNu linux-2.4.20-std/include/asm-x86_64/apic.h linux-2.4.20-kfi/include/asm-x86_64/apic.h
--- linux-2.4.20-std/include/asm-x86_64/apic.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/apic.h	2004-12-30 22:15:13.000000000 +0100
@@ -78,7 +78,7 @@
 extern void smp_local_timer_interrupt (struct pt_regs * regs);
 extern void setup_APIC_clocks (void);
 extern void setup_apic_nmi_watchdog (void);
-extern inline void nmi_watchdog_tick (struct pt_regs * regs);
+extern void nmi_watchdog_tick (struct pt_regs * regs);
 extern int APIC_init_uniprocessor (void);
 extern void disable_APIC_timer(void);
 extern void enable_APIC_timer(void);
diff -rbNu linux-2.4.20-std/include/asm-x86_64/fixmap.h linux-2.4.20-kfi/include/asm-x86_64/fixmap.h
--- linux-2.4.20-std/include/asm-x86_64/fixmap.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/fixmap.h	2004-12-30 22:15:13.000000000 +0100
@@ -73,7 +73,7 @@
  * directly without tranlation, we catch the bug with a NULL-deference
  * kernel oops. Illegal ranges of incoming indices are caught too.
  */
-extern inline unsigned long fix_to_virt(const unsigned int idx)
+static inline unsigned long fix_to_virt(const unsigned int idx)
 {
 	/*
 	 * this branch gets completely eliminated after inlining,
diff -rbNu linux-2.4.20-std/include/asm-x86_64/io.h linux-2.4.20-kfi/include/asm-x86_64/io.h
--- linux-2.4.20-std/include/asm-x86_64/io.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/io.h	2004-12-30 22:15:13.000000000 +0100
@@ -52,7 +52,7 @@
  * Talk about misusing macros..
  */
 #define __OUT1(s,x) \
-extern inline void out##s(unsigned x value, unsigned short port) {
+static inline void out##s(unsigned x value, unsigned short port) {
 
 #define __OUT2(s,s1,s2) \
 __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
@@ -62,7 +62,7 @@
 __OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
 
 #define __IN1(s) \
-extern inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
 
 #define __IN2(s,s1,s2) \
 __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
@@ -72,12 +72,12 @@
 __IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
 
 #define __INS(s) \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; ins" #s \
 : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
 #define __OUTS(s) \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
 { __asm__ __volatile__ ("rep ; outs" #s \
 : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
 
@@ -127,12 +127,12 @@
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
  */
-extern inline unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void * address)
 {
 	return __pa(address);
 }
 
-extern inline void * phys_to_virt(unsigned long address)
+static inline void * phys_to_virt(unsigned long address)
 {
 	return __va(address);
 }
@@ -148,7 +148,7 @@
 
 extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
 
-extern inline void * ioremap (unsigned long offset, unsigned long size)
+static inline void * ioremap (unsigned long offset, unsigned long size)
 {
 	return __ioremap(offset, size, 0);
 }
@@ -158,7 +158,7 @@
  * it's useful if some control registers are in such an area and write combining
  * or read caching is not desirable:
  */
-extern inline void * ioremap_nocache (unsigned long offset, unsigned long size)
+static inline void * ioremap_nocache (unsigned long offset, unsigned long size)
 {
         return __ioremap(offset, size, _PAGE_PCD);
 }
diff -rbNu linux-2.4.20-std/include/asm-x86_64/locks.h linux-2.4.20-kfi/include/asm-x86_64/locks.h
--- linux-2.4.20-std/include/asm-x86_64/locks.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/locks.h	2004-12-30 22:15:13.000000000 +0100
@@ -10,7 +10,7 @@
  *	to borrow for other processors if it was just assembler.
  */
 
-extern __inline__ void prim_spin_lock(struct spinlock *sp)
+static __inline__ void prim_spin_lock(struct spinlock *sp)
 {
 	int processor=smp_processor_id();
 	
@@ -56,7 +56,7 @@
  *	Release a spin lock
  */
  
-extern __inline__ int prim_spin_unlock(struct spinlock *sp)
+static __inline__ int prim_spin_unlock(struct spinlock *sp)
 {
 	/* This is safe. The decrement is still guarded by the lock. A multilock would
 	   not be safe this way */
@@ -73,7 +73,7 @@
  *	Non blocking lock grab
  */
  
-extern __inline__ int prim_spin_lock_nb(struct spinlock *sp)
+static __inline__ int prim_spin_lock_nb(struct spinlock *sp)
 {
 	if(lock_set_bit(0,&sp->lock))
 		return 0;		/* Locked already */
@@ -86,7 +86,7 @@
  *	These wrap the locking primitives up for usage
  */
  
-extern __inline__ void spinlock(struct spinlock *sp)
+static __inline__ void spinlock(struct spinlock *sp)
 {
 	if(sp->priority<current->lock_order)
 		panic("lock order violation: %s (%d)\n", sp->name, current->lock_order);
@@ -100,7 +100,7 @@
 	}
 }
 
-extern __inline__ void spinunlock(struct spinlock *sp)
+static __inline__ void spinunlock(struct spinlock *sp)
 {
 	int pri;
 	if(current->lock_order!=sp->priority)
@@ -116,7 +116,7 @@
 	}	
 }
 
-extern __inline__ void spintestlock(struct spinlock *sp)
+static __inline__ void spintestlock(struct spinlock *sp)
 {
 	/*
 	 *	We do no sanity checks, it's legal to optimistically
@@ -125,7 +125,7 @@
 	prim_spin_lock_nb(sp);
 }
 
-extern __inline__ void spintestunlock(struct spinlock *sp)
+static __inline__ void spintestunlock(struct spinlock *sp)
 {
 	/*
 	 *	A testlock doesn't update the lock chain so we
diff -rbNu linux-2.4.20-std/include/asm-x86_64/page.h linux-2.4.20-kfi/include/asm-x86_64/page.h
--- linux-2.4.20-std/include/asm-x86_64/page.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/page.h	2004-12-30 22:15:13.000000000 +0100
@@ -92,7 +92,7 @@
 #define PAGE_BUG(page) BUG()
 
 /* Pure 2^n version of get_order */
-extern __inline__ int get_order(unsigned long size)
+static __inline__ int get_order(unsigned long size)
 {
 	int order;
 
diff -rbNu linux-2.4.20-std/include/asm-x86_64/pgalloc.h linux-2.4.20-kfi/include/asm-x86_64/pgalloc.h
--- linux-2.4.20-std/include/asm-x86_64/pgalloc.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/pgalloc.h	2004-12-30 22:15:13.000000000 +0100
@@ -17,12 +17,12 @@
 #define pgd_populate(mm, pgd, pmd) \
 		set_pgd(pgd, __pgd(_PAGE_TABLE | __pa(pmd)))
 
-extern __inline__ pmd_t *get_pmd_slow(void)
+static __inline__ pmd_t *get_pmd_slow(void)
 {
 	return (pmd_t *)get_zeroed_page(GFP_KERNEL);
 }
 
-extern __inline__ pmd_t *get_pmd_fast(void)
+static __inline__ pmd_t *get_pmd_fast(void)
 {
 	unsigned long *ret;
 
@@ -35,14 +35,14 @@
 	return (pmd_t *)ret;
 }
 
-extern __inline__ void pmd_free(pmd_t *pmd)
+static __inline__ void pmd_free(pmd_t *pmd)
 {
 	*(unsigned long *)pmd = (unsigned long) read_pda(pmd_quick);
 	write_pda(pmd_quick,(unsigned long *) pmd);
 	inc_pgcache_size();
 }
 
-extern __inline__ void pmd_free_slow(pmd_t *pmd)
+static __inline__ void pmd_free_slow(pmd_t *pmd)
 {
 	if ((unsigned long)pmd & (PAGE_SIZE-1)) 
 		out_of_line_bug(); 
@@ -109,7 +109,7 @@
 	return (pte_t *)get_zeroed_page(GFP_KERNEL); 
 }
 
-extern __inline__ pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
+static __inline__ pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
 	unsigned long *ret;
 
@@ -124,14 +124,14 @@
 /* Should really implement gc for free page table pages. This could be done with 
    a reference count in struct page. */
 
-extern __inline__ void pte_free(pte_t *pte)
+static __inline__ void pte_free(pte_t *pte)
 {	
 	*(unsigned long *)pte = (unsigned long) read_pda(pte_quick);
 	write_pda(pte_quick, (unsigned long *) pte); 
 	inc_pgcache_size();
 }
 
-extern __inline__ void pte_free_slow(pte_t *pte)
+static __inline__ void pte_free_slow(pte_t *pte)
 {
 	if ((unsigned long)pte & (PAGE_SIZE-1))
 		out_of_line_bug();
@@ -210,7 +210,7 @@
 
 #endif
 
-extern inline void flush_tlb_pgtables(struct mm_struct *mm,
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
 				      unsigned long start, unsigned long end)
 {
 	flush_tlb_mm(mm);
diff -rbNu linux-2.4.20-std/include/asm-x86_64/pgtable.h linux-2.4.20-kfi/include/asm-x86_64/pgtable.h
--- linux-2.4.20-std/include/asm-x86_64/pgtable.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/pgtable.h	2004-12-30 22:15:13.000000000 +0100
@@ -116,7 +116,7 @@
 #define pgd_none(x)	(!pgd_val(x))
 
 
-extern inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
+static inline int pgd_present(pgd_t pgd)	{ return !pgd_none(pgd); }
 
 static inline void set_pte(pte_t *dst, pte_t val)
 {
@@ -138,12 +138,12 @@
 	pml4_val(*dst) = pml4_val(val);
 } 
 
-extern inline void __pgd_clear (pgd_t * pgd)
+static inline void __pgd_clear (pgd_t * pgd)
 {
 	set_pgd(pgd, __pgd(0));
 }
 
-extern inline void pgd_clear (pgd_t * pgd)
+static inline void pgd_clear (pgd_t * pgd)
 {
 	__pgd_clear(pgd);
 	__flush_tlb();
@@ -311,22 +311,22 @@
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
  */
-extern inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
-extern inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
-extern inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
-extern inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
-
-extern inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
-extern inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
-extern inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
-extern inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
-extern inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
-extern inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
 static inline  int ptep_test_and_clear_dirty(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep); }
 static inline  int ptep_test_and_clear_young(pte_t *ptep)	{ return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
 static inline void ptep_set_wrprotect(pte_t *ptep)		{ clear_bit(_PAGE_BIT_RW, ptep); }
@@ -354,7 +354,7 @@
 	return __pte;
 }
 
-extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 { 
 	set_pte(&pte, __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot))); 
 	return pte; 
diff -rbNu linux-2.4.20-std/include/asm-x86_64/processor.h linux-2.4.20-kfi/include/asm-x86_64/processor.h
--- linux-2.4.20-std/include/asm-x86_64/processor.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/processor.h	2004-12-30 22:15:13.000000000 +0100
@@ -116,7 +116,7 @@
  *	Generic CPUID function
  * 	FIXME: This really belongs to msr.h
  */
-extern inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+static inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
 {
 	__asm__("cpuid"
 		: "=a" (*eax),
@@ -129,7 +129,7 @@
 /*
  * CPUID functions returning a single datum
  */
-extern inline unsigned int cpuid_eax(unsigned int op)
+static inline unsigned int cpuid_eax(unsigned int op)
 {
 	unsigned int eax;
 
@@ -139,7 +139,7 @@
 		: "bx", "cx", "dx");
 	return eax;
 }
-extern inline unsigned int cpuid_ebx(unsigned int op)
+static inline unsigned int cpuid_ebx(unsigned int op)
 {
 	unsigned int eax, ebx;
 
@@ -149,7 +149,7 @@
 		: "cx", "dx" );
 	return ebx;
 }
-extern inline unsigned int cpuid_ecx(unsigned int op)
+static inline unsigned int cpuid_ecx(unsigned int op)
 {
 	unsigned int eax, ecx;
 
@@ -159,7 +159,7 @@
 		: "bx", "dx" );
 	return ecx;
 }
-extern inline unsigned int cpuid_edx(unsigned int op)
+static inline unsigned int cpuid_edx(unsigned int op)
 {
 	unsigned int eax, edx;
 
@@ -367,7 +367,7 @@
  * What is this good for? it will be always the scheduler or ret_from_fork.
  */
 
-extern inline unsigned long thread_saved_pc(struct thread_struct *t)
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
 { 
 	return *(unsigned long *)(t->rsp - 8);
 } 
@@ -388,7 +388,7 @@
 #define init_stack	(init_task_union.stack)
 
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
-extern inline void rep_nop(void)
+static inline void rep_nop(void)
 {
 	__asm__ __volatile__("rep;nop");
 }
diff -rbNu linux-2.4.20-std/include/asm-x86_64/siginfo.h linux-2.4.20-kfi/include/asm-x86_64/siginfo.h
--- linux-2.4.20-std/include/asm-x86_64/siginfo.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/siginfo.h	2004-12-30 22:15:13.000000000 +0100
@@ -216,7 +216,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -rbNu linux-2.4.20-std/include/asm-x86_64/signal.h linux-2.4.20-kfi/include/asm-x86_64/signal.h
--- linux-2.4.20-std/include/asm-x86_64/signal.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/signal.h	2004-12-30 22:15:13.000000000 +0100
@@ -155,23 +155,23 @@
 #undef __HAVE_ARCH_SIG_BITOPS
 #if 0
 
-extern __inline__ void sigaddset(sigset_t *set, int _sig)
+static __inline__ void sigaddset(sigset_t *set, int _sig)
 {
 	__asm__("btsq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
 }
 
-extern __inline__ void sigdelset(sigset_t *set, int _sig)
+static __inline__ void sigdelset(sigset_t *set, int _sig)
 {
 	__asm__("btrq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
 }
 
-extern __inline__ int __const_sigismember(sigset_t *set, int _sig)
+static __inline__ int __const_sigismember(sigset_t *set, int _sig)
 {
 	unsigned long sig = _sig - 1;
 	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig & ~(_NSIG_BPW-1)));
 }
 
-extern __inline__ int __gen_sigismember(sigset_t *set, int _sig)
+static __inline__ int __gen_sigismember(sigset_t *set, int _sig)
 {
 	int ret;
 	__asm__("btq %2,%1\n\tsbbq %0,%0"
@@ -186,7 +186,7 @@
 
 #define sigmask(sig)	(1UL << ((sig) - 1))
 
-extern __inline__ int sigfindinword(unsigned long word)
+static __inline__ int sigfindinword(unsigned long word)
 {
 	__asm__("bsfq %1,%0" : "=r"(word) : "rm"(word) : "cc");
 	return word;
diff -rbNu linux-2.4.20-std/include/asm-x86_64/smp.h linux-2.4.20-kfi/include/asm-x86_64/smp.h
--- linux-2.4.20-std/include/asm-x86_64/smp.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/smp.h	2004-12-30 22:15:13.000000000 +0100
@@ -48,11 +48,11 @@
  * This simplifies scheduling and IPI sending and
  * compresses data structures.
  */
-extern inline int cpu_logical_map(int cpu)
+static inline int cpu_logical_map(int cpu)
 {
 	return cpu;
 }
-extern inline int cpu_number_map(int cpu)
+static inline int cpu_number_map(int cpu)
 {
 	return cpu;
 }
@@ -82,7 +82,7 @@
 #define stack_smp_processor_id() (stack_current()->processor)
 
 
-extern __inline int hard_smp_processor_id(void)
+static __inline int hard_smp_processor_id(void)
 {
 	/* we don't want to mark this access volatile - bad code generation */
 	return GET_APIC_ID(*(unsigned long *)(APIC_BASE+APIC_ID));
diff -rbNu linux-2.4.20-std/include/asm-x86_64/smplock.h linux-2.4.20-kfi/include/asm-x86_64/smplock.h
--- linux-2.4.20-std/include/asm-x86_64/smplock.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/smplock.h	2004-12-30 22:15:13.000000000 +0100
@@ -39,7 +39,7 @@
  * so we only need to worry about other
  * CPU's.
  */
-extern __inline__ void lock_kernel(void)
+static __inline__ void lock_kernel(void)
 {
 #if 1
 	if (!++current->lock_depth)
@@ -55,7 +55,7 @@
 #endif
 }
 
-extern __inline__ void unlock_kernel(void)
+static __inline__ void unlock_kernel(void)
 {
 	if (current->lock_depth < 0)
 		out_of_line_bug();
diff -rbNu linux-2.4.20-std/include/asm-x86_64/socket32.h linux-2.4.20-kfi/include/asm-x86_64/socket32.h
--- linux-2.4.20-std/include/asm-x86_64/socket32.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/socket32.h	2004-12-30 22:15:13.000000000 +0100
@@ -10,7 +10,7 @@
 extern struct socket *sockfd_lookup(int fd, int *err);
 
 /* XXX This as well... */
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/include/asm-x86_64/spinlock.h linux-2.4.20-kfi/include/asm-x86_64/spinlock.h
--- linux-2.4.20-std/include/asm-x86_64/spinlock.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/spinlock.h	2004-12-30 22:15:13.000000000 +0100
@@ -149,7 +149,7 @@
  */
 /* the spinlock helpers are in arch/x86_64/kernel/semaphore.S */
 
-extern inline void read_lock(rwlock_t *rw)
+static inline void read_lock(rwlock_t *rw)
 {
 #if SPINLOCK_DEBUG
 	if (rw->magic != RWLOCK_MAGIC)
diff -rbNu linux-2.4.20-std/include/asm-x86_64/system.h linux-2.4.20-kfi/include/asm-x86_64/system.h
--- linux-2.4.20-std/include/asm-x86_64/system.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/system.h	2004-12-30 22:15:13.000000000 +0100
@@ -116,7 +116,7 @@
 
 #define __xg(x) ((volatile long *)(x))
 
-extern inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
 {
 	*ptr = val;
 }
diff -rbNu linux-2.4.20-std/include/asm-x86_64/uaccess.h linux-2.4.20-kfi/include/asm-x86_64/uaccess.h
--- linux-2.4.20-std/include/asm-x86_64/uaccess.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/uaccess.h	2004-12-30 22:15:13.000000000 +0100
@@ -47,7 +47,7 @@
 
 #define access_ok(type,addr,size) (__range_not_ok(addr,size) == 0)
 
-extern inline int verify_area(int type, const void * addr, unsigned long size)
+static inline int verify_area(int type, const void * addr, unsigned long size)
 {
 	return access_ok(type,addr,size) ? 0 : -EFAULT;
 }
diff -rbNu linux-2.4.20-std/include/asm-x86_64/unistd.h linux-2.4.20-kfi/include/asm-x86_64/unistd.h
--- linux-2.4.20-std/include/asm-x86_64/unistd.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/asm-x86_64/unistd.h	2004-12-30 22:15:13.000000000 +0100
@@ -657,7 +657,7 @@
 }
 
 extern long sys_exit(int) __attribute__((noreturn));
-extern inline long exit(int error_code)
+static inline long exit(int error_code)
 {
 	sys_exit(error_code);
 }
diff -rbNu linux-2.4.20-std/include/linux/blkdev.h linux-2.4.20-kfi/include/linux/blkdev.h
--- linux-2.4.20-std/include/linux/blkdev.h	2004-12-30 17:14:41.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/blkdev.h	2004-12-31 14:48:20.000000000 +0100
@@ -149,7 +149,7 @@
 
 #ifdef CONFIG_HIGHMEM
 extern struct buffer_head *create_bounce(int, struct buffer_head *);
-extern inline struct buffer_head *blk_queue_bounce(request_queue_t *q, int rw,
+static inline struct buffer_head *blk_queue_bounce(request_queue_t *q, int rw,
 						   struct buffer_head *bh)
 {
 	struct page *page = bh->b_page;
@@ -199,7 +199,7 @@
 extern void grok_partitions(struct gendisk *dev, int drive, unsigned minors, long size);
 extern void register_disk(struct gendisk *dev, kdev_t first, unsigned minors, struct block_device_operations *ops, long size);
 extern void generic_make_request(int rw, struct buffer_head * bh);
-extern inline request_queue_t *blk_get_queue(kdev_t dev);
+extern request_queue_t *blk_get_queue(kdev_t dev);
 extern void blkdev_release_request(struct request *);
 
 /*
@@ -211,7 +211,7 @@
 extern void blk_queue_headactive(request_queue_t *, int);
 extern void blk_queue_make_request(request_queue_t *, make_request_fn *);
 extern void generic_unplug_device(void *);
-extern inline int blk_seg_merge_ok(struct buffer_head *, struct buffer_head *);
+extern int blk_seg_merge_ok(struct buffer_head *, struct buffer_head *);
 
 extern int * blk_size[MAX_BLKDEV];
 
diff -rbNu linux-2.4.20-std/include/linux/i2c-proc.h linux-2.4.20-kfi/include/linux/i2c-proc.h
--- linux-2.4.20-std/include/linux/i2c-proc.h	2001-10-11 17:05:47.000000000 +0200
+++ linux-2.4.20-kfi/include/linux/i2c-proc.h	2004-12-30 22:15:15.000000000 +0100
@@ -362,7 +362,7 @@
 
 /* This macro is used to scale user-input to sensible values in almost all
    chip drivers. */
-extern inline int SENSORS_LIMIT(long value, long low, long high)
+static inline int SENSORS_LIMIT(long value, long low, long high)
 {
 	if (value < low)
 		return low;
diff -rbNu linux-2.4.20-std/include/linux/ide.h linux-2.4.20-kfi/include/linux/ide.h
--- linux-2.4.20-std/include/linux/ide.h	2004-12-30 17:15:59.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/ide.h	2004-12-31 14:48:49.000000000 +0100
@@ -879,12 +879,12 @@
  */
 #define ide_rq_offset(rq) (((rq)->hard_cur_sectors - (rq)->current_nr_sectors) << 9)
 
-extern inline void *ide_map_buffer(struct request *rq, unsigned long *flags)
+static inline void *ide_map_buffer(struct request *rq, unsigned long *flags)
 {
 	return bh_kmap_irq(rq->bh, flags) + ide_rq_offset(rq);
 }
 
-extern inline void ide_unmap_buffer(char *buffer, unsigned long *flags)
+static inline void ide_unmap_buffer(char *buffer, unsigned long *flags)
 {
 	bh_kunmap_irq(buffer, flags);
 }
diff -rbNu linux-2.4.20-std/include/linux/init.h linux-2.4.20-kfi/include/linux/init.h
--- linux-2.4.20-std/include/linux/init.h	2004-12-30 17:14:37.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/init.h	2004-12-31 14:48:10.000000000 +0100
@@ -155,6 +155,14 @@
 #define __devexitdata __exitdata
 #endif
 
+#ifndef __ASSEMBLY__
+#define __instrument
+#define __noinstrument __attribute__ ((no_instrument_function))
+#ifdef CONFIG_KFI
+extern int kfi_dump_log(char* buf);
+#endif
+#endif
+
 /* Functions marked as __devexit may be discarded at kernel link time, depending
    on config options.  Newer versions of binutils detect references from
    retained sections to discarded sections and flag an error.  Pointers to
diff -rbNu linux-2.4.20-std/include/linux/intermezzo_fs.h linux-2.4.20-kfi/include/linux/intermezzo_fs.h
--- linux-2.4.20-std/include/linux/intermezzo_fs.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/intermezzo_fs.h	2004-12-30 22:15:14.000000000 +0100
@@ -425,8 +425,8 @@
                        struct presto_file_set **);
 /* cache.c */
 extern struct presto_cache *presto_cache_init(void);
-extern inline void presto_cache_add(struct presto_cache *cache, kdev_t dev);
-extern inline void presto_cache_init_hash(void);
+extern void presto_cache_add(struct presto_cache *cache, kdev_t dev);
+extern void presto_cache_init_hash(void);
 
 struct presto_cache *presto_cache_find(kdev_t dev);
 
diff -rbNu linux-2.4.20-std/include/linux/kernel_stat.h linux-2.4.20-kfi/include/linux/kernel_stat.h
--- linux-2.4.20-std/include/linux/kernel_stat.h	2004-12-30 17:14:43.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/kernel_stat.h	2004-12-31 14:48:10.000000000 +0100
@@ -50,7 +50,7 @@
 /*
  * Number of interrupts per specific IRQ source, since bootup
  */
-extern inline int kstat_irqs (int irq)
+static inline int kstat_irqs (int irq)
 {
 	int i, sum=0;
 
diff -rbNu linux-2.4.20-std/include/linux/kfi.h linux-2.4.20-kfi/include/linux/kfi.h
--- linux-2.4.20-std/include/linux/kfi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/kfi.h	2004-12-30 22:14:48.000000000 +0100
@@ -0,0 +1,84 @@
+#ifndef _LINUX_KFI_H
+#define _LINUX_KFI_H
+
+#define KFI_DEBUG
+
+typedef struct kfi_entry {
+	void *va;            /* VA of instrumented function */
+	void *call_site;     /* where this func was called */
+	unsigned long time;  /* function entry time since trigger start time,
+				in usec */
+	unsigned long delta; /* delta time from entry to exit, in usec */
+	int           pid;
+} kfi_entry_t;
+
+#define INTR_CONTEXT -1
+
+typedef enum kfi_trigger_type {
+	TRIGGER_NONE = 0,
+	TRIGGER_TIME,
+	TRIGGER_FUNC_ENTRY,
+	TRIGGER_FUNC_EXIT,
+	TRIGGER_PROC,
+	TRIGGER_DEV,
+	TRIGGER_LOG_FULL
+} kfi_trigger_type_t;
+
+typedef struct kfi_trigger {
+	enum kfi_trigger_type type;
+	union {
+		unsigned long time; // time since boot, in usec
+		void * func_addr;
+	};
+	unsigned long mark; // time at which this trigger occured
+} kfi_trigger_t;
+
+#define MAX_RUN_LOG_ENTRIES 8092
+#define MAX_FUNC_LIST_ENTRIES 512
+
+typedef struct kfi_filters {
+	unsigned long min_delta;
+	unsigned long max_delta;
+	int no_ints;
+	int only_ints;
+	void** func_list;
+	int func_list_size;
+#ifdef KFI_DEBUG
+	struct {
+		int delta;
+		int no_ints;
+		int only_ints;
+		int func_list;
+	} cnt;
+#endif
+} kfi_filters_t;
+
+typedef struct kfi_run {
+	int triggered;
+	int complete;
+	struct kfi_trigger start_trigger;
+	struct kfi_trigger stop_trigger;
+	struct kfi_filters filters;
+	struct kfi_entry* log;
+	int num_entries;
+	int next_entry;
+	int id;
+	struct kfi_run * next;
+
+#ifdef KFI_DEBUG
+	int notfound;
+#endif
+} kfi_run_t;
+
+/* Use 'i' as magic number */
+#define KFI_MAGIC  'i'
+
+#define KFI_RESET      _IO  (KFI_MAGIC, 0)
+#define KFI_NEW_RUN    _IOWR(KFI_MAGIC, 1, struct kfi_run)
+#define KFI_START      _IOR (KFI_MAGIC, 2, int)
+#define KFI_STOP       _IOR (KFI_MAGIC, 3, int)
+#define KFI_READ       _IOWR(KFI_MAGIC, 4, struct kfi_run)
+#define KFI_READ_CURR  _IOWR(KFI_MAGIC, 5, struct kfi_run)
+#define KFI_READ_TIMER _IOR (KFI_MAGIC, 6, unsigned long)
+
+#endif // _LINUX_KFI_H
diff -rbNu linux-2.4.20-std/include/linux/netfilter_ipv4/ip_conntrack.h linux-2.4.20-kfi/include/linux/netfilter_ipv4/ip_conntrack.h
--- linux-2.4.20-std/include/linux/netfilter_ipv4/ip_conntrack.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/netfilter_ipv4/ip_conntrack.h	2004-12-30 22:15:15.000000000 +0100
@@ -220,7 +220,7 @@
 ip_conntrack_get(struct sk_buff *skb, enum ip_conntrack_info *ctinfo);
 
 /* decrement reference count on a conntrack */
-extern inline void ip_conntrack_put(struct ip_conntrack *ct);
+extern void ip_conntrack_put(struct ip_conntrack *ct);
 
 /* find unconfirmed expectation based on tuple */
 struct ip_conntrack_expect *
diff -rbNu linux-2.4.20-std/include/linux/parport_pc.h linux-2.4.20-kfi/include/linux/parport_pc.h
--- linux-2.4.20-std/include/linux/parport_pc.h	2001-11-14 23:52:47.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/parport_pc.h	2004-12-30 22:15:14.000000000 +0100
@@ -41,7 +41,7 @@
 	struct pci_dev *dev;
 };
 
-extern __inline__ void parport_pc_write_data(struct parport *p, unsigned char d)
+static __inline__ void parport_pc_write_data(struct parport *p, unsigned char d)
 {
 #ifdef DEBUG_PARPORT
 	printk (KERN_DEBUG "parport_pc_write_data(%p,0x%02x)\n", p, d);
@@ -49,7 +49,7 @@
 	outb(d, DATA(p));
 }
 
-extern __inline__ unsigned char parport_pc_read_data(struct parport *p)
+static __inline__ unsigned char parport_pc_read_data(struct parport *p)
 {
 	unsigned char val = inb (DATA (p));
 #ifdef DEBUG_PARPORT
@@ -60,7 +60,7 @@
 }
 
 #ifdef DEBUG_PARPORT
-extern __inline__ void dump_parport_state (char *str, struct parport *p)
+static __inline__ void dump_parport_state (char *str, struct parport *p)
 {
 	/* here's hoping that reading these ports won't side-effect anything underneath */
 	unsigned char ecr = inb (ECONTROL (p));
@@ -124,17 +124,17 @@
 	return ctr;
 }
 
-extern __inline__ void parport_pc_data_reverse (struct parport *p)
+static __inline__ void parport_pc_data_reverse (struct parport *p)
 {
 	__parport_pc_frob_control (p, 0x20, 0x20);
 }
 
-extern __inline__ void parport_pc_data_forward (struct parport *p)
+static __inline__ void parport_pc_data_forward (struct parport *p)
 {
 	__parport_pc_frob_control (p, 0x20, 0x00);
 }
 
-extern __inline__ void parport_pc_write_control (struct parport *p,
+static __inline__ void parport_pc_write_control (struct parport *p,
 						 unsigned char d)
 {
 	const unsigned char wm = (PARPORT_CONTROL_STROBE |
@@ -152,7 +152,7 @@
 	__parport_pc_frob_control (p, wm, d & wm);
 }
 
-extern __inline__ unsigned char parport_pc_read_control(struct parport *p)
+static __inline__ unsigned char parport_pc_read_control(struct parport *p)
 {
 	const unsigned char rm = (PARPORT_CONTROL_STROBE |
 				  PARPORT_CONTROL_AUTOFD |
@@ -162,7 +162,7 @@
 	return priv->ctr & rm; /* Use soft copy */
 }
 
-extern __inline__ unsigned char parport_pc_frob_control (struct parport *p,
+static __inline__ unsigned char parport_pc_frob_control (struct parport *p,
 							 unsigned char mask,
 							 unsigned char val)
 {
@@ -189,18 +189,18 @@
 	return __parport_pc_frob_control (p, mask, val);
 }
 
-extern __inline__ unsigned char parport_pc_read_status(struct parport *p)
+static __inline__ unsigned char parport_pc_read_status(struct parport *p)
 {
 	return inb(STATUS(p));
 }
 
 
-extern __inline__ void parport_pc_disable_irq(struct parport *p)
+static __inline__ void parport_pc_disable_irq(struct parport *p)
 {
 	__parport_pc_frob_control (p, 0x10, 0x00);
 }
 
-extern __inline__ void parport_pc_enable_irq(struct parport *p)
+static __inline__ void parport_pc_enable_irq(struct parport *p)
 {
 	__parport_pc_frob_control (p, 0x10, 0x10);
 }
diff -rbNu linux-2.4.20-std/include/linux/quotaops.h linux-2.4.20-kfi/include/linux/quotaops.h
--- linux-2.4.20-std/include/linux/quotaops.h	2004-12-30 17:34:03.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/quotaops.h	2004-12-31 14:49:48.000000000 +0100
@@ -174,7 +174,7 @@
 #define DQUOT_SYNC(dev)				do { } while(0)
 #define DQUOT_OFF(sb)				do { } while(0)
 #define DQUOT_TRANSFER(inode, iattr)		(0)
-extern __inline__ int DQUOT_PREALLOC_BLOCK_NODIRTY(struct inode *inode, int nr)
+static __inline__ int DQUOT_PREALLOC_BLOCK_NODIRTY(struct inode *inode, int nr)
 {
 	lock_kernel();
 	inode->i_blocks += nr << (inode->i_sb->s_blocksize_bits - 9);
@@ -182,14 +182,14 @@
 	return 0;
 }
 
-extern __inline__ int DQUOT_PREALLOC_BLOCK(struct inode *inode, int nr)
+static __inline__ int DQUOT_PREALLOC_BLOCK(struct inode *inode, int nr)
 {
 	DQUOT_PREALLOC_BLOCK_NODIRTY(inode, nr);
 	mark_inode_dirty(inode);
 	return 0;
 }
 
-extern __inline__ int DQUOT_ALLOC_BLOCK_NODIRTY(struct inode *inode, int nr)
+static __inline__ int DQUOT_ALLOC_BLOCK_NODIRTY(struct inode *inode, int nr)
 {
 	lock_kernel();
 	inode->i_blocks += nr << (inode->i_sb->s_blocksize_bits - 9);
@@ -197,21 +197,21 @@
 	return 0;
 }
 
-extern __inline__ int DQUOT_ALLOC_BLOCK(struct inode *inode, int nr)
+static __inline__ int DQUOT_ALLOC_BLOCK(struct inode *inode, int nr)
 {
 	DQUOT_ALLOC_BLOCK_NODIRTY(inode, nr);
 	mark_inode_dirty(inode);
 	return 0;
 }
 
-extern __inline__ void DQUOT_FREE_BLOCK_NODIRTY(struct inode *inode, int nr)
+static __inline__ void DQUOT_FREE_BLOCK_NODIRTY(struct inode *inode, int nr)
 {
 	lock_kernel();
 	inode->i_blocks -= nr << (inode->i_sb->s_blocksize_bits - 9);
 	unlock_kernel();
 }
 
-extern __inline__ void DQUOT_FREE_BLOCK(struct inode *inode, int nr)
+static __inline__ void DQUOT_FREE_BLOCK(struct inode *inode, int nr)
 {
 	DQUOT_FREE_BLOCK_NODIRTY(inode, nr);
 	mark_inode_dirty(inode);
diff -rbNu linux-2.4.20-std/include/linux/reiserfs_fs.h linux-2.4.20-kfi/include/linux/reiserfs_fs.h
--- linux-2.4.20-std/include/linux/reiserfs_fs.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/reiserfs_fs.h	2004-12-30 22:15:13.000000000 +0100
@@ -1629,26 +1629,26 @@
 
 /* stree.c */
 int B_IS_IN_TREE(const struct buffer_head *);
-extern inline void copy_short_key (void * to, const void * from);
-extern inline void copy_item_head(struct item_head * p_v_to, 
+extern void copy_short_key (void * to, const void * from);
+extern void copy_item_head(struct item_head * p_v_to, 
 								  const struct item_head * p_v_from);
 
 // first key is in cpu form, second - le
-extern inline int comp_keys (const struct key * le_key, 
+extern int comp_keys (const struct key * le_key, 
 			     const struct cpu_key * cpu_key);
-extern inline int  comp_short_keys (const struct key * le_key, 
+extern int  comp_short_keys (const struct key * le_key, 
 				    const struct cpu_key * cpu_key);
-extern inline void le_key2cpu_key (struct cpu_key * to, const struct key * from);
+extern void le_key2cpu_key (struct cpu_key * to, const struct key * from);
 
 // both are cpu keys
-extern inline int comp_cpu_keys (const struct cpu_key *, const struct cpu_key *);
-extern inline int comp_short_cpu_keys (const struct cpu_key *, 
+extern int comp_cpu_keys (const struct cpu_key *, const struct cpu_key *);
+extern int comp_short_cpu_keys (const struct cpu_key *, 
 				       const struct cpu_key *);
-extern inline void cpu_key2cpu_key (struct cpu_key *, const struct cpu_key *);
+extern void cpu_key2cpu_key (struct cpu_key *, const struct cpu_key *);
 
 // both are in le form
-extern inline int comp_le_keys (const struct key *, const struct key *);
-extern inline int comp_short_le_keys (const struct key *, const struct key *);
+extern int comp_le_keys (const struct key *, const struct key *);
+extern int comp_short_le_keys (const struct key *, const struct key *);
 
 //
 // get key version from on disk key - kludge
@@ -1683,7 +1683,7 @@
 int search_for_position_by_key (struct super_block * p_s_sb, 
 								const struct cpu_key * p_s_cpu_key, 
 								struct path * p_s_search_path);
-extern inline void decrement_bcount (struct buffer_head * p_s_bh);
+extern void decrement_bcount (struct buffer_head * p_s_bh);
 void decrement_counters_in_path (struct path * p_s_search_path);
 void pathrelse (struct path * p_s_search_path);
 int reiserfs_check_path(struct path *p) ;
@@ -1955,7 +1955,7 @@
 int is_reusable (struct super_block * s, unsigned long block, int bit_value);
 void reiserfs_free_block (struct reiserfs_transaction_handle *th, unsigned long);
 int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t * , int, int);
-extern inline int reiserfs_new_form_blocknrs (struct tree_balance * tb,
+static inline int reiserfs_new_form_blocknrs (struct tree_balance * tb,
 					      b_blocknr_t *new_blocknrs, int amount_needed)
 {
     reiserfs_blocknr_hint_t hint = {
@@ -1969,7 +1969,7 @@
     return reiserfs_allocate_blocknrs(&hint, new_blocknrs, amount_needed, 0);
 }
 
-extern inline int reiserfs_new_unf_blocknrs (struct reiserfs_transaction_handle *th,
+static inline int reiserfs_new_unf_blocknrs (struct reiserfs_transaction_handle *th,
 					     struct inode *inode,
 					     b_blocknr_t *new_blocknrs,
 					     struct path * path, long block)
@@ -1986,7 +1986,7 @@
 }
 
 #ifdef REISERFS_PREALLOCATE
-extern inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle *th,
+static inline int reiserfs_new_unf_blocknrs2(struct reiserfs_transaction_handle *th,
 					     struct inode * inode,
 					     b_blocknr_t *new_blocknrs,
 					     struct path * path, long block)
diff -rbNu linux-2.4.20-std/include/linux/sched.h linux-2.4.20-kfi/include/linux/sched.h
--- linux-2.4.20-std/include/linux/sched.h	2004-12-30 17:14:38.000000000 +0100
+++ linux-2.4.20-kfi/include/linux/sched.h	2004-12-31 14:48:10.000000000 +0100
@@ -762,7 +762,7 @@
 extern void end_lazy_tlb(struct mm_struct *mm);
 
 /* mmdrop drops the mm and the page tables */
-extern inline void FASTCALL(__mmdrop(struct mm_struct *));
+extern void FASTCALL(__mmdrop(struct mm_struct *));
 static inline void mmdrop(struct mm_struct * mm)
 {
 	if (atomic_dec_and_test(&mm->mm_count))
diff -rbNu linux-2.4.20-std/include/linux/sysrq.h linux-2.4.20-kfi/include/linux/sysrq.h
--- linux-2.4.20-std/include/linux/sysrq.h	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.20-kfi/include/linux/sysrq.h	2004-12-30 22:15:14.000000000 +0100
@@ -56,7 +56,7 @@
 struct sysrq_key_op *__sysrq_get_key_op (int key);
 void __sysrq_put_key_op (int key, struct sysrq_key_op *op_p);
 
-extern __inline__ int
+static __inline__ int
 __sysrq_swap_key_ops_nolock(int key, struct sysrq_key_op *insert_op_p,
 				struct sysrq_key_op *remove_op_p)
 {
@@ -70,7 +70,7 @@
 	return retval;
 }
 
-extern __inline__ int
+static __inline__ int
 __sysrq_swap_key_ops(int key, struct sysrq_key_op *insert_op_p,
 				struct sysrq_key_op *remove_op_p) {
 	int retval;
diff -rbNu linux-2.4.20-std/include/net/ax25.h linux-2.4.20-kfi/include/net/ax25.h
--- linux-2.4.20-std/include/net/ax25.h	2004-12-30 17:33:13.000000000 +0100
+++ linux-2.4.20-kfi/include/net/ax25.h	2004-12-31 14:49:03.000000000 +0100
@@ -343,8 +343,8 @@
 extern void ax25_register_sysctl(void);
 extern void ax25_unregister_sysctl(void);
 #else
-extern inline void ax25_register_sysctl(void) {};
-extern inline void ax25_unregister_sysctl(void) {};
+static inline void ax25_register_sysctl(void) {};
+static inline void ax25_unregister_sysctl(void) {};
 #endif /* CONFIG_SYSCTL */
 
 #endif
diff -rbNu linux-2.4.20-std/include/net/ip.h linux-2.4.20-kfi/include/net/ip.h
--- linux-2.4.20-std/include/net/ip.h	2004-12-30 17:34:27.000000000 +0100
+++ linux-2.4.20-kfi/include/net/ip.h	2004-12-31 14:50:08.000000000 +0100
@@ -136,7 +136,7 @@
 void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,
 		   unsigned int len); 
 
-extern __inline__ int ip_finish_output(struct sk_buff *skb);
+extern int ip_finish_output(struct sk_buff *skb);
 
 struct ipv4_config
 {
diff -rbNu linux-2.4.20-std/include/net/irda/irda_device.h linux-2.4.20-kfi/include/net/irda/irda_device.h
--- linux-2.4.20-std/include/net/irda/irda_device.h	2001-06-20 02:08:05.000000000 +0200
+++ linux-2.4.20-kfi/include/net/irda/irda_device.h	2004-12-30 22:15:17.000000000 +0100
@@ -202,7 +202,7 @@
 )
 
 #if 0
-extern inline __u16 irda_get_mtt(struct sk_buff *skb)
+static inline __u16 irda_get_mtt(struct sk_buff *skb)
 {
 	__u16 mtt;
 
@@ -230,7 +230,7 @@
 )
 
 #if 0
-extern inline __u32 irda_get_next_speed(struct sk_buff *skb)
+static inline __u32 irda_get_next_speed(struct sk_buff *skb)
 {
 	__u32 speed;
 
diff -rbNu linux-2.4.20-std/include/net/tcp.h linux-2.4.20-kfi/include/net/tcp.h
--- linux-2.4.20-std/include/net/tcp.h	2004-12-30 17:35:24.000000000 +0100
+++ linux-2.4.20-kfi/include/net/tcp.h	2004-12-31 14:50:29.000000000 +0100
@@ -597,19 +597,19 @@
  * and worry about wraparound (automatic with unsigned arithmetic).
  */
 
-extern __inline int before(__u32 seq1, __u32 seq2)
+static __inline int before(__u32 seq1, __u32 seq2)
 {
         return (__s32)(seq1-seq2) < 0;
 }
 
-extern __inline int after(__u32 seq1, __u32 seq2)
+static __inline int after(__u32 seq1, __u32 seq2)
 {
 	return (__s32)(seq2-seq1) < 0;
 }
 
 
 /* is s2<=s1<=s3 ? */
-extern __inline int between(__u32 seq1, __u32 seq2, __u32 seq3)
+static __inline int between(__u32 seq1, __u32 seq2, __u32 seq3)
 {
 	return seq3 - seq2 >= seq1 - seq2;
 }
diff -rbNu linux-2.4.20-std/include/video/newport.h linux-2.4.20-kfi/include/video/newport.h
--- linux-2.4.20-std/include/video/newport.h	2001-04-12 21:20:31.000000000 +0200
+++ linux-2.4.20-kfi/include/video/newport.h	2004-12-30 22:15:18.000000000 +0100
@@ -384,7 +384,7 @@
 #define VC2_IREG_CONTROL       0x10
 #define VC2_IREG_CONFIG        0x20
 
-extern __inline__ void newport_vc2_set(struct newport_regs *regs, unsigned char vc2ireg,
+static __inline__ void newport_vc2_set(struct newport_regs *regs, unsigned char vc2ireg,
 				   unsigned short val)
 {
 	regs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_INDEX | NPORT_DMODE_W3 |
@@ -392,7 +392,7 @@
 	regs->set.dcbdata0.byword = (vc2ireg << 24) | (val << 8);
 }
 
-extern __inline__ unsigned short newport_vc2_get(struct newport_regs *regs,
+static __inline__ unsigned short newport_vc2_get(struct newport_regs *regs,
 					     unsigned char vc2ireg)
 {
 	regs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_INDEX | NPORT_DMODE_W1 |
diff -rbNu linux-2.4.20-std/init/main.c linux-2.4.20-kfi/init/main.c
--- linux-2.4.20-std/init/main.c	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.20-kfi/init/main.c	2004-12-30 22:14:48.000000000 +0100
@@ -540,6 +540,12 @@
 
 extern void prepare_namespace(void);
 
+#ifdef CONFIG_KFI_STATIC_RUN
+void to_userspace()
+{
+}
+#endif /* CONFIG_KFI_STATIC_RUN */
+
 static int init(void * unused)
 {
 	lock_kernel();
@@ -568,6 +574,10 @@
 	 * trying to recover a really broken machine.
 	 */
 
+#ifdef CONFIG_KFI_STATIC_RUN
+	to_userspace();
+#endif /* CONFIG_KFI_STATIC_RUN */
+
 	if (execute_command)
 		execve(execute_command,argv_init,envp_init);
 	execve("/sbin/init",argv_init,envp_init);
diff -rbNu linux-2.4.20-std/ipc/util.h linux-2.4.20-kfi/ipc/util.h
--- linux-2.4.20-std/ipc/util.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/ipc/util.h	2004-12-30 22:15:24.000000000 +0100
@@ -45,12 +45,12 @@
 void* ipc_alloc(int size);
 void ipc_free(void* ptr, int size);
 
-extern inline void ipc_lockall(struct ipc_ids* ids)
+static inline void ipc_lockall(struct ipc_ids* ids)
 {
 	spin_lock(&ids->ary);
 }
 
-extern inline struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id)
+static inline struct kern_ipc_perm* ipc_get(struct ipc_ids* ids, int id)
 {
 	struct kern_ipc_perm* out;
 	int lid = id % SEQ_MULTIPLIER;
@@ -61,11 +61,11 @@
 	return out;
 }
 
-extern inline void ipc_unlockall(struct ipc_ids* ids)
+static inline void ipc_unlockall(struct ipc_ids* ids)
 {
 	spin_unlock(&ids->ary);
 }
-extern inline struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id)
+static inline struct kern_ipc_perm* ipc_lock(struct ipc_ids* ids, int id)
 {
 	struct kern_ipc_perm* out;
 	int lid = id % SEQ_MULTIPLIER;
@@ -79,17 +79,17 @@
 	return out;
 }
 
-extern inline void ipc_unlock(struct ipc_ids* ids, int id)
+static inline void ipc_unlock(struct ipc_ids* ids, int id)
 {
 	spin_unlock(&ids->ary);
 }
 
-extern inline int ipc_buildid(struct ipc_ids* ids, int id, int seq)
+static inline int ipc_buildid(struct ipc_ids* ids, int id, int seq)
 {
 	return SEQ_MULTIPLIER*seq + id;
 }
 
-extern inline int ipc_checkid(struct ipc_ids* ids, struct kern_ipc_perm* ipcp, int uid)
+static inline int ipc_checkid(struct ipc_ids* ids, struct kern_ipc_perm* ipcp, int uid)
 {
 	if(uid/SEQ_MULTIPLIER != ipcp->seq)
 		return 1;
diff -rbNu linux-2.4.20-std/kernel/sys.c linux-2.4.20-kfi/kernel/sys.c
--- linux-2.4.20-std/kernel/sys.c	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.20-kfi/kernel/sys.c	2004-12-30 22:14:48.000000000 +0100
@@ -14,7 +14,9 @@
 #include <linux/prctl.h>
 #include <linux/init.h>
 #include <linux/highuid.h>
-
+#ifdef CONFIG_KFI
+#include <linux/kfi.h>
+#endif
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
@@ -285,6 +287,9 @@
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "Restarting system.\n");
 		machine_restart(NULL);
 		break;
@@ -299,6 +304,9 @@
 
 	case LINUX_REBOOT_CMD_HALT:
 		notifier_call_chain(&reboot_notifier_list, SYS_HALT, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "System halted.\n");
 		machine_halt();
 		do_exit(0);
@@ -306,6 +314,9 @@
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
 		notifier_call_chain(&reboot_notifier_list, SYS_POWER_OFF, NULL);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		printk(KERN_EMERG "Power down.\n");
 		machine_power_off();
 		do_exit(0);
@@ -320,6 +331,9 @@
 
 		notifier_call_chain(&reboot_notifier_list, SYS_RESTART, buffer);
 		printk(KERN_EMERG "Restarting system with command '%s'.\n", buffer);
+#ifdef CONFIG_KFI
+		kfi_dump_log(NULL);
+#endif
 		machine_restart(buffer);
 		break;
 
diff -rbNu linux-2.4.20-std/lib/err linux-2.4.20-kfi/lib/err
--- linux-2.4.20-std/lib/err	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-kfi/lib/err	2004-12-30 22:34:43.000000000 +0100
@@ -0,0 +1,2 @@
+Makefile:29: /Rules.make: No such file or directory
+make: *** No rule to make target `/Rules.make'.  Stop.
diff -rbNu linux-2.4.20-std/lib/inflate.c linux-2.4.20-kfi/lib/inflate.c
--- linux-2.4.20-std/lib/inflate.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/lib/inflate.c	2004-12-30 23:02:55.000000000 +0100
@@ -271,7 +271,7 @@
 STATIC unsigned hufts;         /* track memory usage */
 
 
-STATIC int huft_build(b, n, s, d, e, t, m)
+STATIC int __noinstrument huft_build(b, n, s, d, e, t, m)
 unsigned *b;            /* code lengths in bits (all assumed <= BMAX) */
 unsigned n;             /* number of codes (assumed <= N_MAX) */
 unsigned s;             /* number of simple-valued codes (0..s-1) */
@@ -489,7 +489,7 @@
 
 
 
-STATIC int huft_free(t)
+STATIC int __noinstrument huft_free(t)
 struct huft *t;         /* table to free */
 /* Free the malloc'ed tables built by huft_build(), which makes a linked
    list of the tables it made, with the links in a dummy first entry of
@@ -510,7 +510,7 @@
 }
 
 
-STATIC int inflate_codes(tl, td, bl, bd)
+STATIC int __noinstrument inflate_codes(tl, td, bl, bd)
 struct huft *tl, *td;   /* literal/length and distance decoder tables */
 int bl, bd;             /* number of bits decoded by tl[] and td[] */
 /* inflate (decompress) the codes in a deflated (compressed) block.
@@ -619,7 +619,7 @@
 
 
 
-STATIC int inflate_stored()
+STATIC int __noinstrument inflate_stored()
 /* "decompress" an inflated type 0 (stored) block. */
 {
   unsigned n;           /* number of bytes in block */
@@ -675,7 +675,7 @@
 
 
 
-STATIC int inflate_fixed()
+STATIC int __noinstrument inflate_fixed()
 /* decompress an inflated type 1 (fixed Huffman codes) block.  We should
    either replace this with a custom decoder, or at least precompute the
    Huffman tables. */
@@ -729,7 +729,7 @@
 
 
 
-STATIC int inflate_dynamic()
+STATIC int __noinstrument inflate_dynamic()
 /* decompress an inflated type 2 (dynamic Huffman codes) block. */
 {
   int i;                /* temporary variables */
@@ -907,7 +907,7 @@
 
 
 
-STATIC int inflate_block(e)
+STATIC int __noinstrument inflate_block(e)
 int *e;                 /* last block flag */
 /* decompress an inflated block */
 {
@@ -954,7 +954,7 @@
 
 
 
-STATIC int inflate()
+STATIC int __noinstrument inflate()
 /* decompress an inflated entry */
 {
   int e;                /* last block flag */
@@ -1016,7 +1016,7 @@
  * gzip-1.0.3/makecrc.c.
  */
 
-static void
+static void __noinstrument
 makecrc(void)
 {
 /* Not copyrighted 1990 Mark Adler	*/
@@ -1064,7 +1064,7 @@
 /*
  * Do the uncompression!
  */
-static int gunzip(void)
+static int __noinstrument gunzip(void)
 {
     uch flags;
     unsigned char magic[2]; /* magic header */
diff -rbNu linux-2.4.20-std/net/appletalk/ddp.c linux-2.4.20-kfi/net/appletalk/ddp.c
--- linux-2.4.20-std/net/appletalk/ddp.c	2001-09-10 16:57:00.000000000 +0200
+++ linux-2.4.20-kfi/net/appletalk/ddp.c	2004-12-30 22:15:22.000000000 +0100
@@ -106,8 +106,8 @@
 #endif /* APPLETALK_DEBUG */
 
 #ifdef CONFIG_SYSCTL
-extern inline void atalk_register_sysctl(void);
-extern inline void atalk_unregister_sysctl(void);
+extern void atalk_register_sysctl(void);
+extern void atalk_unregister_sysctl(void);
 #endif /* CONFIG_SYSCTL */
 
 struct datalink_proto *ddp_dl, *aarp_dl;
@@ -122,7 +122,7 @@
 static struct sock *atalk_sockets;
 static spinlock_t atalk_sockets_lock = SPIN_LOCK_UNLOCKED;
 
-extern inline void atalk_insert_socket(struct sock *sk)
+static inline void atalk_insert_socket(struct sock *sk)
 {
 	spin_lock_bh(&atalk_sockets_lock);
 	sk->next = atalk_sockets;
@@ -133,7 +133,7 @@
 	spin_unlock_bh(&atalk_sockets_lock);
 }
 
-extern inline void atalk_remove_socket(struct sock *sk)
+static inline void atalk_remove_socket(struct sock *sk)
 {
 	spin_lock_bh(&atalk_sockets_lock);
 	if (sk->pprev) {
@@ -225,7 +225,7 @@
 	}
 }
 
-extern inline void atalk_destroy_socket(struct sock *sk)
+static inline void atalk_destroy_socket(struct sock *sk)
 {
 	atalk_remove_socket(sk);
 	skb_queue_purge(&sk->receive_queue);
diff -rbNu linux-2.4.20-std/net/bridge/br_private_timer.h linux-2.4.20-kfi/net/bridge/br_private_timer.h
--- linux-2.4.20-std/net/bridge/br_private_timer.h	2000-02-18 23:51:22.000000000 +0100
+++ linux-2.4.20-kfi/net/bridge/br_private_timer.h	2004-12-30 22:15:23.000000000 +0100
@@ -21,12 +21,12 @@
 	unsigned long expires;
 };
 
-extern __inline__ void br_timer_clear(struct br_timer *t)
+static __inline__ void br_timer_clear(struct br_timer *t)
 {
 	t->running = 0;
 }
 
-extern __inline__ unsigned long br_timer_get_residue(struct br_timer *t)
+static __inline__ unsigned long br_timer_get_residue(struct br_timer *t)
 {
 	if (t->running)
 		return jiffies - t->expires;
@@ -34,18 +34,18 @@
 	return 0;
 }
 
-extern __inline__ void br_timer_set(struct br_timer *t, unsigned long x)
+static __inline__ void br_timer_set(struct br_timer *t, unsigned long x)
 {
 	t->expires = x;
 	t->running = 1;
 }
 
-extern __inline__ int br_timer_is_running(struct br_timer *t)
+static __inline__ int br_timer_is_running(struct br_timer *t)
 {
 	return t->running;
 }
 
-extern __inline__ int br_timer_has_expired(struct br_timer *t, unsigned long to)
+static __inline__ int br_timer_has_expired(struct br_timer *t, unsigned long to)
 {
 	return t->running && time_after_eq(jiffies, t->expires + to);
 }
diff -rbNu linux-2.4.20-std/net/core/dev.c linux-2.4.20-kfi/net/core/dev.c
--- linux-2.4.20-std/net/core/dev.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/core/dev.c	2004-12-30 22:15:22.000000000 +0100
@@ -655,7 +655,7 @@
 
 #else
 
-extern inline void dev_load(const char *unused){;}
+static inline void dev_load(const char *unused){;}
 
 #endif
 
diff -rbNu linux-2.4.20-std/net/core/rtnetlink.c linux-2.4.20-kfi/net/core/rtnetlink.c
--- linux-2.4.20-std/net/core/rtnetlink.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/core/rtnetlink.c	2004-12-30 22:15:22.000000000 +0100
@@ -394,7 +394,7 @@
  * Malformed skbs with wrong lengths of messages are discarded silently.
  */
 
-extern __inline__ int rtnetlink_rcv_skb(struct sk_buff *skb)
+static __inline__ int rtnetlink_rcv_skb(struct sk_buff *skb)
 {
 	int err;
 	struct nlmsghdr * nlh;
diff -rbNu linux-2.4.20-std/net/ipv4/fib_hash.c linux-2.4.20-kfi/net/ipv4/fib_hash.c
--- linux-2.4.20-std/net/ipv4/fib_hash.c	2001-12-21 18:42:05.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/fib_hash.c	2004-12-30 22:15:22.000000000 +0100
@@ -137,12 +137,12 @@
 	return fz->fz_hash[fn_hash(key, fz).datum];
 }
 
-extern __inline__ int fn_key_eq(fn_key_t a, fn_key_t b)
+static __inline__ int fn_key_eq(fn_key_t a, fn_key_t b)
 {
 	return a.datum == b.datum;
 }
 
-extern __inline__ int fn_key_leq(fn_key_t a, fn_key_t b)
+static __inline__ int fn_key_leq(fn_key_t a, fn_key_t b)
 {
 	return a.datum <= b.datum;
 }
@@ -703,7 +703,7 @@
 	return -ESRCH;
 }
 
-extern __inline__ int
+static __inline__ int
 fn_flush_list(struct fib_node ** fp, int z, struct fn_hash *table)
 {
 	int found = 0;
diff -rbNu linux-2.4.20-std/net/ipv4/netfilter/ipchains_core.c linux-2.4.20-kfi/net/ipv4/netfilter/ipchains_core.c
--- linux-2.4.20-std/net/ipv4/netfilter/ipchains_core.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/netfilter/ipchains_core.c	2004-12-30 22:15:23.000000000 +0100
@@ -269,7 +269,7 @@
 #define IP_FW_OUTPUT_CHAIN (ip_fw_chains->next->next)
 
 /* Returns 1 if the port is matched by the range, 0 otherwise */
-extern inline int port_match(__u16 min, __u16 max, __u16 port,
+static inline int port_match(__u16 min, __u16 max, __u16 port,
 			     int frag, int invert)
 {
 	if (frag) /* Fragments fail ANY port test. */
diff -rbNu linux-2.4.20-std/net/ipv4/netfilter/ipfwadm_core.c linux-2.4.20-kfi/net/ipv4/netfilter/ipfwadm_core.c
--- linux-2.4.20-std/net/ipv4/netfilter/ipfwadm_core.c	2002-02-25 20:38:14.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/netfilter/ipfwadm_core.c	2004-12-30 22:15:23.000000000 +0100
@@ -186,7 +186,7 @@
  *	Returns 1 if the port is matched by the vector, 0 otherwise
  */
 
-extern inline int port_match(unsigned short *portptr,int nports,unsigned short port,int range_flag)
+static inline int port_match(unsigned short *portptr,int nports,unsigned short port,int range_flag)
 {
 	if (!nports)
 		return 1;
diff -rbNu linux-2.4.20-std/net/ipv4/tcp.c linux-2.4.20-kfi/net/ipv4/tcp.c
--- linux-2.4.20-std/net/ipv4/tcp.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/tcp.c	2004-12-30 22:15:22.000000000 +0100
@@ -2065,7 +2065,7 @@
 
 /* These states need RST on ABORT according to RFC793 */
 
-extern __inline__ int tcp_need_reset(int state)
+static __inline__ int tcp_need_reset(int state)
 {
 	return ((1 << state) &
 	       	(TCPF_ESTABLISHED|TCPF_CLOSE_WAIT|TCPF_FIN_WAIT1|
diff -rbNu linux-2.4.20-std/net/ipv4/tcp_diag.c linux-2.4.20-kfi/net/ipv4/tcp_diag.c
--- linux-2.4.20-std/net/ipv4/tcp_diag.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/tcp_diag.c	2004-12-30 22:15:22.000000000 +0100
@@ -578,7 +578,7 @@
 }
 
 
-extern __inline__ void tcpdiag_rcv_skb(struct sk_buff *skb)
+static __inline__ void tcpdiag_rcv_skb(struct sk_buff *skb)
 {
 	int err;
 	struct nlmsghdr * nlh;
diff -rbNu linux-2.4.20-std/net/ipv4/tcp_input.c linux-2.4.20-kfi/net/ipv4/tcp_input.c
--- linux-2.4.20-std/net/ipv4/tcp_input.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv4/tcp_input.c	2004-12-30 22:15:22.000000000 +0100
@@ -2097,14 +2097,14 @@
 	return 1;
 }
 
-extern __inline__ void
+static __inline__ void
 tcp_store_ts_recent(struct tcp_opt *tp)
 {
 	tp->ts_recent = tp->rcv_tsval;
 	tp->ts_recent_stamp = xtime.tv_sec;
 }
 
-extern __inline__ void
+static __inline__ void
 tcp_replace_ts_recent(struct tcp_opt *tp, u32 seq)
 {
 	if (tp->saw_tstamp && !after(seq, tp->rcv_wup)) {
@@ -2163,7 +2163,7 @@
 		(s32)(tp->ts_recent - tp->rcv_tsval) <= (tp->rto*1024)/HZ);
 }
 
-extern __inline__ int tcp_paws_discard(struct tcp_opt *tp, struct sk_buff *skb)
+static __inline__ int tcp_paws_discard(struct tcp_opt *tp, struct sk_buff *skb)
 {
 	return ((s32)(tp->ts_recent - tp->rcv_tsval) > TCP_PAWS_WINDOW &&
 		xtime.tv_sec < tp->ts_recent_stamp + TCP_PAWS_24DAYS &&
diff -rbNu linux-2.4.20-std/net/ipv6/reassembly.c linux-2.4.20-kfi/net/ipv6/reassembly.c
--- linux-2.4.20-std/net/ipv6/reassembly.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-2.4.20-kfi/net/ipv6/reassembly.c	2004-12-30 22:15:23.000000000 +0100
@@ -126,19 +126,19 @@
 atomic_t ip6_frag_mem = ATOMIC_INIT(0);
 
 /* Memory Tracking Functions. */
-extern __inline__ void frag_kfree_skb(struct sk_buff *skb)
+static __inline__ void frag_kfree_skb(struct sk_buff *skb)
 {
 	atomic_sub(skb->truesize, &ip6_frag_mem);
 	kfree_skb(skb);
 }
 
-extern __inline__ void frag_free_queue(struct frag_queue *fq)
+static __inline__ void frag_free_queue(struct frag_queue *fq)
 {
 	atomic_sub(sizeof(struct frag_queue), &ip6_frag_mem);
 	kfree(fq);
 }
 
-extern __inline__ struct frag_queue *frag_alloc_queue(void)
+static __inline__ struct frag_queue *frag_alloc_queue(void)
 {
 	struct frag_queue *fq = kmalloc(sizeof(struct frag_queue), GFP_ATOMIC);
 
diff -rbNu linux-2.4.20-std/net/sched/sch_csz.c linux-2.4.20-kfi/net/sched/sch_csz.c
--- linux-2.4.20-std/net/sched/sch_csz.c	2001-12-21 18:42:06.000000000 +0100
+++ linux-2.4.20-kfi/net/sched/sch_csz.c	2004-12-30 22:15:23.000000000 +0100
@@ -301,7 +301,7 @@
 
 #if 0
 /* Scan forward */
-extern __inline__ void csz_insert_finish(struct csz_head *b,
+static __inline__ void csz_insert_finish(struct csz_head *b,
 					 struct csz_flow *this)
 {
 	struct csz_head *f = b->fnext;
@@ -318,7 +318,7 @@
 }
 #else
 /* Scan backward */
-extern __inline__ void csz_insert_finish(struct csz_head *b,
+static __inline__ void csz_insert_finish(struct csz_head *b,
 					 struct csz_flow *this)
 {
 	struct csz_head *f = b->fprev;
@@ -339,7 +339,7 @@
    flow with greater start number.
  */
 
-extern __inline__ void csz_insert_start(struct csz_head *b,
+static __inline__ void csz_insert_start(struct csz_head *b,
 					struct csz_flow *this)
 {
 	struct csz_head *f = b->snext;
diff -rbNu linux-2.4.20-std/net/sched/sch_sfq.c linux-2.4.20-kfi/net/sched/sch_sfq.c
--- linux-2.4.20-std/net/sched/sch_sfq.c	2002-08-03 02:39:46.000000000 +0200
+++ linux-2.4.20-kfi/net/sched/sch_sfq.c	2004-12-30 22:15:23.000000000 +0100
@@ -170,7 +170,7 @@
 	return sfq_fold_hash(q, h, h2);
 }
 
-extern __inline__ void sfq_link(struct sfq_sched_data *q, sfq_index x)
+static __inline__ void sfq_link(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
 	int d = q->qs[x].qlen + SFQ_DEPTH;
@@ -182,7 +182,7 @@
 	q->dep[p].next = q->dep[n].prev = x;
 }
 
-extern __inline__ void sfq_dec(struct sfq_sched_data *q, sfq_index x)
+static __inline__ void sfq_dec(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
 
@@ -197,7 +197,7 @@
 	sfq_link(q, x);
 }
 
-extern __inline__ void sfq_inc(struct sfq_sched_data *q, sfq_index x)
+static __inline__ void sfq_inc(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
 	int d;
diff -rbNu linux-2.4.20-std/net/socket.c linux-2.4.20-kfi/net/socket.c
--- linux-2.4.20-std/net/socket.c	2002-11-29 00:53:16.000000000 +0100
+++ linux-2.4.20-kfi/net/socket.c	2004-12-30 22:15:22.000000000 +0100
@@ -373,7 +373,7 @@
 	return fd;
 }
 
-extern __inline__ struct socket *socki_lookup(struct inode *inode)
+static __inline__ struct socket *socki_lookup(struct inode *inode)
 {
 	return &inode->u.socket_i;
 }
@@ -418,7 +418,7 @@
 	return sock;
 }
 
-extern __inline__ void sockfd_put(struct socket *sock)
+static __inline__ void sockfd_put(struct socket *sock)
 {
 	fput(sock->file);
 }
diff -rbNu linux-2.4.20-std/net/unix/af_unix.c linux-2.4.20-kfi/net/unix/af_unix.c
--- linux-2.4.20-std/net/unix/af_unix.c	2002-11-29 00:53:16.000000000 +0100
+++ linux-2.4.20-kfi/net/unix/af_unix.c	2004-12-30 22:15:22.000000000 +0100
@@ -159,7 +159,7 @@
 	return peer;
 }
 
-extern inline void unix_release_addr(struct unix_address *addr)
+static inline void unix_release_addr(struct unix_address *addr)
 {
 	if (atomic_dec_and_test(&addr->refcnt))
 		kfree(addr);
diff -rbNu linux-2.4.20-std/net/unix/garbage.c linux-2.4.20-kfi/net/unix/garbage.c
--- linux-2.4.20-std/net/unix/garbage.c	2002-02-25 20:38:16.000000000 +0100
+++ linux-2.4.20-kfi/net/unix/garbage.c	2004-12-30 22:15:22.000000000 +0100
@@ -92,7 +92,7 @@
 atomic_t unix_tot_inflight = ATOMIC_INIT(0);
 
 
-extern inline unix_socket *unix_get_socket(struct file *filp)
+static inline unix_socket *unix_get_socket(struct file *filp)
 {
 	unix_socket * u_sock = NULL;
 	struct inode *inode = filp->f_dentry->d_inode;
@@ -141,19 +141,19 @@
  *	Garbage Collector Support Functions
  */
 
-extern inline unix_socket *pop_stack(void)
+static inline unix_socket *pop_stack(void)
 {
 	unix_socket *p=gc_current;
 	gc_current = p->protinfo.af_unix.gc_tree;
 	return p;
 }
 
-extern inline int empty_stack(void)
+static inline int empty_stack(void)
 {
 	return gc_current == GC_HEAD;
 }
 
-extern inline void maybe_unmark_and_push(unix_socket *x)
+static inline void maybe_unmark_and_push(unix_socket *x)
 {
 	if (x->protinfo.af_unix.gc_tree != GC_ORPHAN)
 		return;
diff -rbNu linux-2.4.20-std/scripts/mkkfirun.pl linux-2.4.20-kfi/scripts/mkkfirun.pl
--- linux-2.4.20-std/scripts/mkkfirun.pl	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-kfi/scripts/mkkfirun.pl	2004-12-30 22:14:48.000000000 +0100
@@ -0,0 +1,241 @@
+#!/usr/bin/perl
+#
+# BRIEF MODULE DESCRIPTION
+#    Parses a Kernel Function Instrumentation config file. The output
+#    is C code representing the KFI logging run parameters listed in
+#    in the config file.
+#
+# Copyright 2002 MontaVista Software Inc.
+# Author: MontaVista Software, Inc.
+#		stevel@mvista.com or source@mvista.com
+#
+#  This program is free software; you can redistribute	 it and/or modify it
+#  under  the terms of	 the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the	License, or (at your
+#  option) any later version.
+#
+#  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+#  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+#  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+#  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+#  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+#  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#  You should have received a copy of the  GNU General Public License along
+#  with this program; if not, write  to the Free Software Foundation, Inc.,
+#  675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+sub parse_args {
+    local($argstr) = $_[0];
+    local(@arglist);
+    local($i) = 0;
+
+    for (;;) {
+	while ($argstr =~ /^\s*$/ || $argstr =~ /^\s*\#/) {
+	    $argstr = <RUNFILE>;
+	}
+    
+	while ($argstr =~ s/^\s*(\w+)\s*(.*)/\2/) {
+	    $arglist[$i++] = $1;
+	    if (!($argstr =~ s/^\,(.*)/\1/)) {
+		return @arglist;
+	    }
+	}
+    }
+}
+
+sub parse_run {
+    local($thisrun, $nextrun) = @_;
+    local($start_type) = "TRIGGER_NONE";
+    local($stop_type) = "TRIGGER_NONE";
+
+    local($filter_noint) = 0;
+    local($filter_onlyint) = 0;
+    local(@filter_func_list) = (0);
+    local($filter_func_list_size) = 0;
+    local(@filter_time_args) = (0,0);
+    local($logsize) = "MAX_RUN_LOG_ENTRIES";
+
+    while (<RUNFILE>) {
+
+	last if /^\s*end\b/;
+	
+	if ( /^\s*trigger\s+(\w+)\s+(\w+)\b\s*([\w\,\s]*)/ ) {
+
+	    $trigwhich = $1;
+	    $trigtype = $2;
+	    @trigargs = &parse_args($3);
+	    
+	    if ($trigwhich eq "start") {
+		if ($trigtype eq "entry") {
+		    $start_type = "TRIGGER_FUNC_ENTRY";
+		} elsif ($trigtype eq "exit") {
+		    $start_type = "TRIGGER_FUNC_EXIT";
+		} elsif ($trigtype eq "time") {
+		    $start_type = "TRIGGER_TIME";
+		} else {
+		    die "#### PARSE ERROR: invalid trigger type ####\n";
+		    }
+		@start_args = @trigargs;
+	    } elsif ($trigwhich eq "stop") {
+		if ($trigtype eq "entry") {
+		    $stop_type = "TRIGGER_FUNC_ENTRY";
+		} elsif ($trigtype eq "exit") {
+		    $stop_type = "TRIGGER_FUNC_EXIT";
+		} elsif ($trigtype eq "time") {
+		    $stop_type = "TRIGGER_TIME";
+		} else {
+		    die "#### PARSE ERROR: invalid trigger type ####\n";
+		    }
+		@stop_args = @trigargs;
+	    } else {
+		die "#### PARSE ERROR: invalid trigger ####\n";
+		}
+	    
+	} elsif ( /^\s*filter\s+(\w+)\b\s*([\w\,\s]*)/ ) {
+	    
+	    $filtertype = $1;
+	    
+	    if ($filtertype eq "time") {
+		@filter_time_args = &parse_args($2);
+	    } elsif ($filtertype eq "noint") {
+		$filter_noint = 1;
+	    } elsif ($filtertype eq "onlyint") {
+		$filter_onlyint = 1;
+	    } elsif ($filtertype eq "funclist") {
+		@filter_func_list = &parse_args($2);
+		$filter_func_list_size = $#filter_func_list + 1;
+	    } else {
+		die "#### PARSE ERROR: invalid filter ####\n";
+		}
+	    
+	} elsif ( /^\s*logsize\s+(\d+)/ ) {
+	    @logargs = &parse_args($1);
+	    $logsize = $logargs[0];
+	}
+    }
+
+    # done parsing this run, now spit out the C code
+
+    # print forward reference to next run
+    if ($nextrun != 0) {
+	printf("kfi_run_t kfi_run%d;\n", $nextrun);
+    }
+
+    if ($start_type eq "TRIGGER_FUNC_ENTRY" ||
+	$start_type eq "TRIGGER_FUNC_EXIT") {
+	printf("extern void %s(void);\n\n", $start_args[0]);
+    }
+    
+    if ($stop_type eq "TRIGGER_FUNC_ENTRY" ||
+	$stop_type eq "TRIGGER_FUNC_EXIT") {
+	printf("extern void %s(void);\n\n", $stop_args[0]);
+    }
+    
+    if ($filter_func_list_size) {
+	$funclist_name = sprintf("run%d_func_list", $thisrun);
+
+	for ($i = 0; $i < $filter_func_list_size; $i++) {
+	    print "extern void $filter_func_list[$i](void);\n"
+		if (!($filter_func_list[$i] =~ /^[0-9]/));
+	}
+	
+	printf("\nstatic void* %s[] = {\n", $funclist_name);
+	
+	for ($i = 0; $i < $filter_func_list_size; $i++) {
+	    printf("\t(void*)%s,\n", $filter_func_list[$i]);
+	}
+	printf("};\n\n");
+    } else {
+	$funclist_name = "NULL";
+    }
+    
+    printf("static kfi_entry_t run%d_log[%s];\n\n", $thisrun, $logsize);
+    
+    printf("kfi_run_t kfi_run%d = {\n", $thisrun);
+    
+    printf("\t0, 0,\n"); # triggered and complete flags
+    
+    # start trigger struct
+    if ($start_type eq "TRIGGER_FUNC_ENTRY" ||
+	$start_type eq "TRIGGER_FUNC_EXIT") {
+	printf("\t{ %s, { func_addr: (void*)%s } },\n",
+	       $start_type, $start_args[0]);
+    } elsif ($start_type eq "TRIGGER_TIME") {
+	printf("\t{ %s, { time: %d } },\n", $start_type, $start_args[0]);
+    } else {
+	printf("\t{ %s, {0} },\n", $start_type);
+    }
+    
+    # stop trigger struct
+    if ($stop_type eq "TRIGGER_FUNC_ENTRY" ||
+	$stop_type eq "TRIGGER_FUNC_EXIT") {
+	printf("\t{ %s, { func_addr: (void*)%s } },\n",
+	       $stop_type, $stop_args[0]);
+    } elsif ($stop_type eq "TRIGGER_TIME") {
+	printf("\t{ %s, { time: %d } },\n", $stop_type, $stop_args[0]);
+    } else {
+	printf("\t{ %s, {0} },\n", $stop_type);
+    }
+
+    # filters struct
+    printf("\t{ %d, %d, %d, %d, %s, %d, {0} },\n",
+	   $filter_time_args[0], $filter_time_args[1],
+	   $filter_noint, $filter_onlyint,
+	   $funclist_name, $filter_func_list_size);
+
+    if ($nextrun != 0) {
+	printf("\trun%d_log, %s, 0, %d, &kfi_run%d,\n",
+	       $thisrun, $logsize, $thisrun, $nextrun);
+    } else {
+	printf("\trun%d_log, %s, 0, %d, NULL,\n",
+	       $thisrun, $logsize, $thisrun);
+    }
+    
+    printf("};\n\n");
+}
+
+
+$numrun = 0;
+
+open(RUNFILE, $ARGV[0]) || die "Can't open KFI run config file";
+
+# first pass get number of run configs listed
+while (<RUNFILE>) {
+    if ( /^\s*begin\b/ ) {
+	$numrun++;
+    }
+}
+
+$numrun != 0 || die "No run listed???\n";
+    
+close(RUNFILE);
+open(RUNFILE, "$ARGV[0]");
+
+# print warning
+print "/* DO NOT EDIT! It was automatically generated by mkkfirun.pl */\n\n";
+
+# print needed headers
+print "#include <linux/types.h>\n";
+print "#include <linux/kfi.h>\n\n";
+
+$runindex = 0;
+while (<RUNFILE>) {
+    if ( /^\s*begin\b/ ) {
+	if ($runindex == $numrun-1) {
+	    &parse_run($runindex, 0);
+	} else {
+	    &parse_run($runindex, $runindex+1);
+	}
+	$runindex++;
+    }
+}
+
+printf("const int kfi_num_runs = %d;\n", $numrun);
+printf("kfi_run_t* kfi_first_run = &kfi_run0;\n");
+printf("kfi_run_t* kfi_last_run = &kfi_run%d;\n", $numrun-1);

#!/usr/bin/env python
#
# show_deltas:
# Read data from an instrumented printk list, and format with
# time deltas.
#
# Also, you can show the times relative to a fixed point in the
# bootup.
#
# You can have this program use the sec.usec data or the
# cycles data from the printk output.  The cycles data is
# more accurate, but you must know the frequency of the
# clock used to gather the data for timed bootup.

# FIXTHIS - you MUST put your clock frequency here
# if you have use_cycles=1
#clock_hz = 645206000L
clock_hz = 2002520000L 

# Set this to 1 to use (by default) the cycles values
# instead of the sec.usec values from the prink lines
# This can be overridden with a command line arg (-c or -s).
use_cycles = 1


import sys
import string

def usage():
	print """usage: show_delta [<options>] <filename>

This program parses the output from a set of printk message lines
which have been instrumented with time and cycle information using
the CONFIG_TIME_BOOTUP option.  When run with no options, the time
information is converted to show the time in seconds.microseconds
from each printk to the next (the delta between each line).  When
run with the '-b' option, all delta times are relative to a fixed
point in time.

Options:
  -h            Show this usage help.
  -b <base>	Specify a base for time references.
		<base> can be a number or a string.
		If it is a string, the first message line
		which matches (at the first part of the
		line) is used as the time reference.
  -c            Use the cycles data for timing info
  -s		Use the seconds data for timing info

ex: dmesg >timefile
    show_delta -b NET4 timefile

will show times relative to the line in the kernel output
line starting with "NET4".
"""
	sys.exit(1)

def arch_cycles_to_nsec(cycles):
	# this requires clock_hz to be set accurately
	if type(cycles) != type(1L):
		raise TypeError
	return (cycles * 1000000000)/clock_hz

# returns a triple containing the seconds, cycles, and
# text message for each line
# seconds is returned as a float, and cycles is returned
# as a long
# if use_cycles is set, then seconds is calculated from
# the cycles instead of just parsed from the line
def get_times_rest(line):
	global use_cycles

	if line[0]!="[":
		return None

	# FIXTHIS - should convert this to use regular expressions
	(times, rest) = string.split(line[1:],']',1)
	times = times[:-1]
	#print "times=", times

	(seconds_str, cycles_str) = string.split(times,'<',1)
	seconds = string.atof(seconds_str)
	(slow, fast) = string.split(cycles_str,':',1)
	slow_num = string.atol(slow)
	fast_num = string.atol(fast)
	cycles = (slow_num * 4294967296L) + fast_num

	if use_cycles:
		# override seconds value in line with one calculated from
		# cycles
		seconds = float(arch_cycles_to_nsec(cycles))/1000000000.0
	return (seconds, cycles, rest)


# average line looks like:
# [    0.084282 <    2:5019>] VFS: Mounted root (romfs filesystem) readonly 
# read first part of line as seconds.useconds, and second
# part as cycles_high.cycles_low
# add deltas for seconds abd useconds (and strip off cycles
last_seconds = 0.0
def convert_line(line, base_num):
	global last_seconds, use_cycles

	# make sure time stamp is on this line
	# if not, don't convert anything
	if line[0]!="[":
		return line

	try:
		(seconds, cycles, rest) = get_times_rest(line)
	except:
		return line

	if base_num:
		# show time from base
		delta = seconds - base_num
	else:
		# just show time from last printk
		delta = seconds - last_seconds
		last_seconds = seconds

	return ("[%5.6f < %5.6f >] " % (seconds, delta)) + rest
	#return "["+seconds+" <"+cycles+">] "+rest

def main():
	global use_cycles
	base_str = ""
	filein = ""
	for arg in sys.argv[1:]:
		if arg=="-b":
			base_str = sys.argv[sys.argv.index("-b")+1]
		elif arg=="-c":
			use_cycles = 1
		elif arg=="-s":
			use_cycles = 0
		else:
			filein = arg

	if not filein:
		usage()

	try:
		lines = open(filein,"r").readlines()
	except:
		print "Problem opening file: %s" % filein
		sys.exit(1)

	print 'base= "%s"' % base_str
	print 'use_cycles=', use_cycles
	if base_str:
		# assume a numeric base.  If that fails, try searching
		# for a matching line.
		try:
			base_num = float(base_str)
		except:
			# search for line matching <base> string
			found = 0
			for line in lines:
				try:
					(seconds, cycles, rest) = get_times_rest(line)
				except:
					continue
				if rest.find(base_str)==1:
					base_num = seconds
					found = 1
					# stop at first match
					break
			if not found:
				print 'Couldn\'t find line matching base pattern "%s"' % base
				sys.exit(1)
	else:
		base_num = 0.0

	for line in lines:
		print convert_line(line, base_num),

main()


